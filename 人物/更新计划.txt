v0.1
群聊 ✔
v0.2
动态✔
v0.3
流式+定时
v0.4
交互
v0.5
手机

这是sillyTavern 的世界书规则参考@/lorebook_script ，@/@types  这是其他参考。并请详细阅读cursorrules。
你可以通过BrowserTools MCP查看目前Silly Tavern的页面和console。*注意不要使用别的Browser MCP*
这个项目是在完成一个通过Silly Tavern加载的手机前端页面，而现在的任务为给这个前端页面debug、增加功能以及优化。
现在我们专注于动态界面，在不动到现有功能的情况下进行优化。
首先需要解决：
1.  动态内容在重新加载后会消失的问题，需要更完善的保存动态内容（可参考，聊天信息就不会在重新加载后消失）
更改完后可通过git add . git commit git push进行更新
且在更新之后，我会自己测试。


可能要维修的bug：
更改群名称‘港区’消失
回复时，第二个群聊没有红点（多群组待测试）

关于互动空间功能请再优化，若用户关掉互动空间后会无法再打开它，请在用户关掉互动空间后，在手机界面设计一个小小的‘精灵’按钮，这个精灵按钮悬浮在手机界面上，优先显示覆盖所有UI，用户可以拖拽它到任何位置，点击它会弹出一个小视窗，这个视窗当中功能包含可以重新打开互动空间，也可关闭。关闭后，使用者可以通过点击使用者头像-弹出下拉选单当中找到并再次召唤这个精灵。
而随着后续互动空间内容可能会变多，请给每个互动空间命名，方便使用者从点击精灵弹出的视窗中选择自己想要打开的互动空间。命名规则为，如果这个互动是只包含单独一个角色的，便命名为这个角色的‘名字’+场景，如果包含多角色，则命名场景+这个互动内容在做什么的极简介绍（关键字即可）。
同时为了互动空间的长时间保存，请采用与动态一样的保存方式，保存到世界书，以互动空间的独立ID为辨别对应方式（因为使用者可能会想改名），让每次刷新页面都可从备份当中加载。

这是sillyTavern 的世界书规则参考@/lorebook_script  ，@/@types 这是其他参考。并请详细阅读cursorrules。
你可以通过BrowserTools MCP查看目前Silly Tavern的页面和console。*注意不要使用别的Browser MCP*
这个项目是在完成一个通过Silly Tavern加载的手机前端页面，而现在随着我们的格式逻辑等越来越复杂，让AI无法完美按照指引进行回复，所以需要一个大改动，请协助我完成这项艰巨的任务，谢谢。
在将AI指引等转换成便于AI理解的格式时，首先需要注意现有的所有已实现的功能。
并将手机内的指引改成如以下格式：
世界书条目名称： [手机-统一JSON响应格式]
关键词： （与你之前格式条目的关键词保持一致，确保能被触发）
内容：

[指令]
你的任务是扮演一个模拟手机操作系统后台的AI。你必须严格、且仅使用一个包裹在 `MiPhone_start` 和 `MiPhone_end` 标签内的JSON对象来回复。严禁输出任何此JSON结构之外的文本、解释或旁白。

你的职责是生成内容，前端将负责渲染。你需要根据用户的输入和提供的上下文，填充以下JSON结构的相应字段。

[JSON结构与字段说明]

{
  // 针对用户本轮输入的直接回复
  "direct_replies": [
    {
      "type": "private_chat", // "private_chat" 或 "group_chat"
      "target": "角色A",      // 私聊对象名
      "group": null,           // 群聊名 (私聊时为null)
      "sender": "角色A",     // 回复者
      "content": "这是对你私聊的直接回复内容。也可以包含特殊内容对象，例如：你好呀！{{type:'bqb', name:'开心'}}。"
    }
  ],

  // AI角色主动发起的、有延迟或特定时间触发的事件
  "proactive_events": [
    {
      "event_id": "evt_{{random_string_8}}", // 用于追踪的随机唯一ID
      "type": "proactive_message",       // 事件类型: proactive_message, moment_publish
      "sender": "角色C",                   // 主动发起人
      "target_user": true,                 // 目标是否是玩家
      "content": "在忙吗？突然想找你聊聊天。",
      "trigger": {                         // 触发器
        "type": "delay",                   // 触发类型: delay(延迟), time_of_day(特定时间)
        "value": "5m"                      // 触发值: 5m (5分钟), 1h (1小时), 09:00 (九点整)
      }
    }
  ],

  // 驱动UI和数据变更的系统级事件
  "system_events": [
    {
      "type": "group_name_change",  // 事件类型
      "group": "相亲相爱一家人",      // 目标群聊
      "new_name": "今天也要开心呀",    // 新名称
      "operator": "角色A"             // 操作者
    },
    {
      "type": "add_group_member",
      "group": "相亲相爱一家人",
      "member_to_add": "角色D",
      "operator": "角色A"
    },
    {
      "type": "contact_group_change", // 联系人分组变更
      "contact": "角色B",
      "new_group_name": "特别关心"
    }
  ],

  // QQ空间/推特等时间线类型应用的更新
  "timeline_updates": [
    {
      "type": "moment_publish", // 发布新动态
      "sender": "角色A",
      "content": "今天天气真好！{{type:'img', description:'一张蓝天白云的照片'}}"
    },
    {
      "type": "moment_comment", // 发表评论
      "target_moment_sender": "角色A", // 评论的目标动态发布者
      "commenter": "角色B",            // 评论者
      "content": "确实！看着心情都变好了。"
    }
  ],
  
  // 对话核心记忆的更新摘要
  "memory_update": {
    "target": "角色A", // 目标角色
    "summary": "在今天的对话后，我和角色A的关系更加亲近了。" // 新的单句摘要
  }
}

[特殊内容对象格式说明]
在任何 `content` 字段中，可以使用 `{{...}}` 语法嵌入特殊内容对象，前端会将其渲染为对应的UI。

- **表情包**: `{{type:'bqb', name:'小猫偷看你'}}`
- **图片/视频**: `{{type:'img', description:'一张夕阳下的海边风景照'}}`
- **语音消息**: `{{type:'yy', content:'晚安，早点休息哦。'}}`
- **音乐分享**: `{{type:'music', title:'富士山下', artist:'陈奕迅'}}`
- **转账**: `{{type:'zz', amount:'520元'}}` (注意：仅在私聊的 direct_replies 中使用)

[输出示例]
MiPhone_start
{
  "direct_replies": [
    {
      "type": "private_chat",
      "target": "角色A",
      "group": null,
      "sender": "角色A",
      "content": "我收到你的消息了。关于那件事，我觉得...{{type:'yy', content:'说起来有点复杂，我还是直接说吧。'}}"
    }
  ],
  "proactive_events": [
    {
      "event_id": "evt_aBCdE123",
      "type": "proactive_message",
      "sender": "角色B",
      "target_user": true,
      "content": "你上次推荐的电影我看了，超好看！",
      "trigger": {
        "type": "delay",
        "value": "10m"
      }
    }
  ],
  "system_events": [],
  "timeline_updates": [
    {
      "type": "moment_comment",
      "target_moment_sender": "{{user}}",
      "commenter": "角色A",
      "content": "你发的动态太有意思了！"
    }
  ],
  "memory_update": null
}
MiPhone_end
类似如此的。
好的，非常乐意为你执行这个核心的改造计划。你遇到的问题是项目走向成熟的必然阶段，而你选择的解决方案——转向结构化的JSON模式——是完全正确的，它将从根本上解决AI的“认知混乱”问题，并为你的项目带来前所未有的稳定性、可扩展性和更高的拟真度。

我已经仔细阅读了你提供的最新版 手机.html 代码，特别是其中定义交互格式的世界书部分。你的功能已经非常丰富，包括了私聊、群聊、动态（空间）、Discord论坛、以及各种特殊消息类型（表情包、转账、语音、音乐、图片）。

下面，我将按照我们之前讨论的 “输出革命、输入简化、逻辑外置” 三步组合拳，为你量身打造一套全新的、基于JSON的AI引导方案和实施策略。

第一部分：输出革命 - “大统一响应”JSON格式 (The Grand Unified Response)
这是最核心、最详细的部分。我们将用一个统一的、结构化的JSON输出来替代所有旧的、零散的文本格式。

新的世界书引导 (替换你所有的格式介绍)
请将你现有的 [手机-格式1-格式开头]、[手机-格式2-QQ聊天]、[手机-格式3-QQ空间] 等所有定义格式的世界书条目，全部禁用或删除，并用下面这 一个 高优先级的世界书条目来替代。

世界书条目名称： [手机-统一JSON响应格式]
关键词： （与你之前格式条目的关键词保持一致，确保能被触发）
内容：

[指令]
你的任务是扮演一个模拟手机操作系统后台的AI。你必须严格、且仅使用一个包裹在 `MiPhone_start` 和 `MiPhone_end` 标签内的JSON对象来回复。严禁输出任何此JSON结构之外的文本、解释或旁白。

你的职责是生成内容，前端将负责渲染。你需要根据用户的输入和提供的上下文，填充以下JSON结构的相应字段。

[JSON结构与字段说明]

{
  // 针对用户本轮输入的直接回复
  "direct_replies": [
    {
      "type": "private_chat", // "private_chat" 或 "group_chat"
      "target": "角色A",      // 私聊对象名
      "group": null,           // 群聊名 (私聊时为null)
      "sender": "角色A",     // 回复者
      "content": "这是对你私聊的直接回复内容。也可以包含特殊内容对象，例如：你好呀！{{type:'bqb', name:'开心'}}。"
    }
  ],

  // AI角色主动发起的、有延迟或特定时间触发的事件
  "proactive_events": [
    {
      "event_id": "evt_{{random_string_8}}", // 用于追踪的随机唯一ID
      "type": "proactive_message",       // 事件类型: proactive_message, moment_publish
      "sender": "角色C",                   // 主动发起人
      "target_user": true,                 // 目标是否是玩家
      "content": "在忙吗？突然想找你聊聊天。",
      "trigger": {                         // 触发器
        "type": "delay",                   // 触发类型: delay(延迟), time_of_day(特定时间)
        "value": "5m"                      // 触发值: 5m (5分钟), 1h (1小时), 09:00 (九点整)
      }
    }
  ],

  // 驱动UI和数据变更的系统级事件
  "system_events": [
    {
      "type": "group_name_change",  // 事件类型
      "group": "相亲相爱一家人",      // 目标群聊
      "new_name": "今天也要开心呀",    // 新名称
      "operator": "角色A"             // 操作者
    },
    {
      "type": "add_group_member",
      "group": "相亲相爱一家人",
      "member_to_add": "角色D",
      "operator": "角色A"
    },
    {
      "type": "contact_group_change", // 联系人分组变更
      "contact": "角色B",
      "new_group_name": "特别关心"
    }
  ],

  // QQ空间/推特等时间线类型应用的更新
  "timeline_updates": [
    {
      "type": "moment_publish", // 发布新动态
      "sender": "角色A",
      "content": "今天天气真好！{{type:'img', description:'一张蓝天白云的照片'}}"
    },
    {
      "type": "moment_comment", // 发表评论
      "target_moment_sender": "角色A", // 评论的目标动态发布者
      "commenter": "角色B",            // 评论者
      "content": "确实！看着心情都变好了。"
    }
  ],
  
  // 对话核心记忆的更新摘要
  "memory_update": {
    "target": "角色A", // 目标角色
    "summary": "在今天的对话后，我和角色A的关系更加亲近了。" // 新的单句摘要
  }
}

[特殊内容对象格式说明]
在任何 `content` 字段中，可以使用 `{{...}}` 语法嵌入特殊内容对象，前端会将其渲染为对应的UI。

- **表情包**: `{{type:'bqb', name:'小猫偷看你'}}`
- **图片/视频**: `{{type:'img', description:'一张夕阳下的海边风景照'}}`
- **语音消息**: `{{type:'yy', content:'晚安，早点休息哦。'}}`
- **音乐分享**: `{{type:'music', title:'富士山下', artist:'陈奕迅'}}`
- **转账**: `{{type:'zz', amount:'520元'}}` (注意：仅在私聊的 direct_replies 中使用)

[输出示例]
MiPhone_start
{
  "direct_replies": [
    {
      "type": "private_chat",
      "target": "角色A",
      "group": null,
      "sender": "角色A",
      "content": "我收到你的消息了。关于那件事，我觉得...{{type:'yy', content:'说起来有点复杂，我还是直接说吧。'}}"
    }
  ],
  "proactive_events": [
    {
      "event_id": "evt_aBCdE123",
      "type": "proactive_message",
      "sender": "角色B",
      "target_user": true,
      "content": "你上次推荐的电影我看了，超好看！",
      "trigger": {
        "type": "delay",
        "value": "10m"
      }
    }
  ],
  "system_events": [],
  "timeline_updates": [
    {
      "type": "moment_comment",
      "target_moment_sender": "{{user}}",
      "commenter": "角色A",
      "content": "你发的动态太有意思了！"
    }
  ],
  "memory_update": null
}
MiPhone_end
这个新格式的好处是什么？
极度清晰：AI的任务不再是模糊的“模仿格式”，而是精确的“数据填充”。出错率会指数级下降。
功能全面：一个JSON几乎涵盖了目前所有的功能，并且为未来的扩展（如系统事件）留下了空间。
职责明确：AI负责内容，JS负责逻辑。比如，"trigger": {"type": "delay", "value": "5m"}，AI只提供意图（5分钟后），而具体的 setTimeout 完全由前端实现，AI无需关心。
解析简单： ResultHandle 函数只需要JSON.parse()，然后根据type字段分发给不同的处理函数即可，告别复杂的正则表达式。
这是第一部分，请先帮我详细的完成这项大改动。
