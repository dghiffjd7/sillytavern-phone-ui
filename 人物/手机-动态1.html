<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />
        <title>Document</title>
        <style type="text/css">
            @import url(https://static.zeoseven.com/zsft/59/main/result.css);
            .QQ_chat_page {
                padding-top: 10px;
                background-color: rgb(244, 245, 246);
                width: 100%;
                height: 100%;
                /* 填满视口高度 */
                /* background-image: url("http://sharkpan.xyz/f/eWhZ/00017-2763077315.png"); */
                background-size: cover;
                background-repeat: no-repeat;
                background-position: top center;
                display: flex;
                flex-direction: column;
                overflow-y: auto;
                /* 允许内容区域垂直滚动 */
                box-sizing: border-box;
                /* 防止内边距溢出 */
                border-radius: var(--yj);
                /* padding-bottom: 60px; */

                position: relative;
                overflow-x: hidden;

                /* z-index: 9999; */
                /* font-family: "字魂萌宠天地体"; */
            }

            .input-container {
                max-width: 100%;
                position: absolute;
                /* bottom: 20px; */
                bottom: 0px;
                left: 0;
                width: 100%;
                background-color: rgb(255, 255, 255, 0.2);
                border-bottom-right-radius: 10px;
                border-bottom-left-radius: 10px;
                box-sizing: border-box;
                padding: 10px 0;
                border-top: 1px solid black;
            }

            .msgcontent {
                flex: 1;
                overflow-y: auto;
                box-sizing: border-box;
                /* margin-top: 20px; */
                margin-bottom: 50px;
                padding-left: 8px;
                padding-right: 8px;
                scrollbar-width: none;
                /* Firefox */
                -ms-overflow-style: none;
                /* IE and Edge */
            }

            .userInput {
                font: inherit;
                height: 30px;
                border-radius: 30px;
                letter-spacing: 0.7px;
                width: 100%;
                padding-left: 10px;
                padding-right: 10px;
                border: 1px solid rgb(0, 0, 0, 0.5);
            }

            /* 聊天设置弹窗样式 */
            .chat-setting-popup {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 80%;
                max-width: 350px;
                background-color: #fff;
                border-radius: 10px;
                box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
                z-index: 1000;
                display: none;
            }

            .chat-setting-header {
                padding: 15px;
                border-bottom: 1px solid #eee;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }

            .chat-setting-header span {
                font-weight: bold;
                font-size: 16px;
            }

            .close-setting-btn {
                cursor: pointer;
            }

            .chat-setting-content {
                padding: 15px;
            }

            .setting-item {
                margin-bottom: 15px;
                display: flex;
                justify-content: space-between;
                align-items: center;
                gap: 10px;
            }

            .setting-item span {
                font-size: 14px;
            }

            .setting-item input[type="text"] {
                flex: 1;
                padding: 5px;
                border: 1px solid #ccc;
                border-radius: 5px;
            }

            .color-picker {
                width: 30px;
                height: 30px;
                padding: 0;
                border: 1px solid #ccc;
                border-radius: 3px;
                cursor: pointer;
            }

            .chat-setting-footer {
                padding: 10px 15px;
                text-align: right;
                border-top: 1px solid #eee;
            }

            .chat-setting-footer button {
                padding: 6px 15px;
                margin-left: 10px;
                border: none;
                border-radius: 5px;
                cursor: pointer;
            }

            #save-setting-btn {
                background-color: #019aff;
                color: white;
            }

            #cancel-setting-btn {
                background-color: #f5f5f5;
                color: #333;
            }

            /* 弹窗遮罩层 */
            .popup-overlay {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.5);
                border-radius: 35px;
                z-index: 999;
                display: none;
            }

            /* 搜索框悬浮相关样式 */
            #floating_search_box:hover {
                background-color: rgba(239, 243, 255, 0.95) !important;
                border-color: rgba(25, 154, 255, 0.4) !important;
                transform: translateY(-1px);
            }

            #contact_search_input::placeholder {
                color: #999;
                font-style: italic;
            }

            #search_clear_btn:hover {
                background-color: #999 !important;
                transform: scale(1.1);
            }

            /* 联络人列表滚动时的搜索框效果 */
            #QQ_home_chars::-webkit-scrollbar {
                display: none !important;
            }

            /* 搜索结果高亮样式 */
            .search-highlight {
                background-color: #ffeb3b !important;
                color: #333 !important;
                padding: 1px 2px;
                border-radius: 2px;
                font-weight: bold;
            }

            .QQ_chat_fakeimg {
                width: 100%;
                background-color: white;
                aspect-ratio: 1 / 1;
                padding: 5px 18px 0 20px;
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                font-size: 1.3em;
                /* overflow-y: auto; */
                -ms-overflow-style: none !important;
                scrollbar-width: none !important;
                text-align: center;
            }

            .QQ_chat_fakeimg::-webkit-scrollbar {
                display: none !important;
            }

            .QQ_chat_fakeimg div {
                max-height: 100%;
                display: flex;
                align-items: flex-start;
                overflow-y: auto;
                -ms-overflow-style: none !important;
                scrollbar-width: none !important;
            }

            .QQ_chat_fakeimg div::-webkit-scrollbar {
                display: none !important;
            }

            .discord {
                background-color: #f2f3f5;
                width: 100%;
                height: 100%;
                line-height: 1.4;
                letter-spacing: 1px;
            }

            .discord-top {
                background-color: white;
                width: 100%;
                height: 80px;
                padding-top: 30px;
                padding-left: 10px;
                display: flex;
                align-items: center;
            }

            .discord-top-title {
                font-size: 20px;
                text-align: center;
                margin-top: -3px;
            }

            .discord-top-button {
                display: flex;
                align-items: center;
                margin-bottom: 10px;
            }

            .sortbutton {
                display: flex;
                align-items: center;
                gap: 4px;
                margin-bottom: -1px;
                height: 32px;
                background-color: #e8e9eb;
                padding: 8px 8px 8px 12px;
                width: fit-content;
                border-radius: 24px;
                margin-top: 10px;
                margin-left: 10px;
            }

            .tagbutton {
                display: flex;
                align-items: center;
                margin-left: auto;
                margin-right: 10px;
                background-color: #e8e9eb;
                padding: 8px 8px 8px 12px;
                width: fit-content;
                height: 32px;
                border-radius: 24px;
                margin-top: 10px;
            }

            .discord-cardlist {
                display: flex;
                flex-direction: column;
                width: 100%;
                height: 100%;
                overflow-y: auto;
                padding: 0 10px 150px 10px;
                scrollbar-width: none;
                -ms-overflow-style: none;
            }

            .discord-cardlist::-webkit-scrollbar {
                display: none !important;
            }

            .discord-card {
                width: 100%;
                height: auto;
                background-color: white;
                border-radius: 15px;
                margin-top: 15px;
                padding-left: 13px;
                padding-right: 13px;
                padding-bottom: 10px;
                border: 1px solid #dfdfe1;
            }

            .discord-card:active {
                background-color: rgb(244, 243, 243);
            }

            .discord-card-tags {
                width: 100%;
                display: flex;
                flex-wrap: wrap;
                gap: 5px;
                padding-top: 10px;
            }

            .discord-card-tag {
                background-color: #eeeff1;
                color: #4f5055;
                width: fit-content;
                padding: 5px 15px;
                border-radius: 24px;
                margin-top: 5px;
                margin-left: -1px;
                font-size: 15px;
                text-align: center;
                font-weight: bold;
            }

            .discord-card-author {
                color: #9d8ef3;
                margin-top: 8px;
                font-size: 18px;
                display: inline-block;
                font-weight: bold;
            }

            .discord-card-title {
                font-weight: bold;
                font-size: 19px;
                margin-top: 5px;

                display: -webkit-box;
                -webkit-box-orient: vertical;
                -webkit-line-clamp: 2;

                /* 文本溢出时显示省略号 */
                overflow: hidden;
                text-overflow: ellipsis;

                /* 确保文本换行 */
                white-space: normal;
                word-break: break-word;
                /* 避免长单词溢出 */
            }

            .discord-card-content {
                margin-top: 2px;
                color: #313133;
                font-size: 16px;

                display: -webkit-box;
                -webkit-box-orient: vertical;
                -webkit-line-clamp: 3;

                /* 文本溢出时显示省略号 */
                overflow: hidden;
                text-overflow: ellipsis;

                /* 确保文本换行 */
                white-space: normal;
                word-break: break-word;
                /* 避免长单词溢出 */
            }

            .discord-card-interact {
                display: flex;
                align-items: center;
                margin-top: 15px;
            }

            .discord-card-interact-icon {
                margin-left: auto;
                color: #333237;
                background-color: #ececec;
                border-radius: 10px;
                font-size: 16px;
                padding: 2px 8px 2px 6px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .discord-card-fakeimg {
                text-align: center;
                margin-top: 9px;
                font-size: 1.2rem;
                background-color: rgb(239 237 238);
                padding: 30px 10px;
                width: 100%;
                border: 1px solid #dfdfe1;
                border-radius: 5px;
                text-align: center;
                text-wrap: balance;
            }

            .discord-thread {
                width: 100%;
                height: 100%;
                background-color: white;
                padding-top: 30px;
                position: relative;
                /* overflow-x: hidden; */
            }

            .discord-thread-top {
                display: grid;
                grid-template-columns: 32px 43px 1fr;
                align-items: center;
                width: 100%;
                height: 50px;
                padding: 0 10px;
            }

            .discord-thread-title {
                font-weight: bold;
                font-size: 20px;
                overflow: hidden;
                text-overflow: ellipsis;
                width: 100%;
                white-space: nowrap;
            }

            .discord-thread-content {
                overflow-y: auto;
                padding: 0 10px;
                width: 100%;
                height: auto;
            }

            .discord-thread-content-title {
                font-weight: bold;
                font-size: 24px;
                margin-top: 10px;
                margin-bottom: 3px;
            }

            .discord-thread-content-tags {
                width: 100%;
                display: flex;
                flex-wrap: wrap;
                gap: 5px;

                .discord-card-tag {
                    margin-top: 5px;
                }
            }

            .discord-thread-content-original {
                display: grid;
                grid-template-columns: 55px 1fr;
                align-items: start;
                margin-top: 20px;
                margin-bottom: 10px;
            }

            .discord-thread-content-original-author-head {
                width: 45px;
                height: 45px;
                background-size: cover;
                border-radius: 50%;
            }

            .discord-thread-content-original-author-name {
                color: #9d8ef3;
                font-size: 18px;
                display: inline-block;
                font-weight: bold;
            }

            .discord-thread-content-original-content {
                white-space: pre-wrap;
                margin-top: 3px;
            }

            .discord-thread-content-likes {
                width: fit-content;
                padding: 5px 8px 5px 8px;
                text-align: center;
                background-color: #f2f3f5;
                border-radius: 8px;
                display: flex;
                align-items: center;
                gap: 5px;
                color: #525358;
                font-size: 16px;
                height: 34px;
            }

            .discord-thread-content-reaction {
                background-color: #eeeeef;
                padding: 5px;
                align-items: center;
                justify-content: center;
                border-radius: 10px;
                display: flex;
                margin-left: 6px;
                height: 34px;
            }

            .discord-thread-comment-list {
                padding: 0 10px;
                width: 100%;
            }

            .discord-thread-comment {
                display: grid;
                grid-template-columns: 50px 1fr;
                margin-top: 20px;
            }

            .discord-thread-comment-head {
                width: 40px;
                height: 40px;
                background-size: cover;
                border-radius: 50%;
                /* margin-top: 5px; */
            }

            .discord-name-creator {
                color: #9d8ef3;
                font-size: 16px;
                display: inline-block;
                font-weight: bold;
                position: relative;
            }

            .discord-thread-comment-name {
                font-size: 16px;
                display: inline-block;
                font-weight: bold;
                position: relative;
            }

            .discord-thread-comment-content {
                margin-top: 3px;
            }

            .discord-name-creator::after {
                position: absolute;
                top: 0%;
                left: 100%;
                margin-left: 3px;
                height: 20px;
                width: 20px;
                display: inline-block;
                content: "";
                background-size: contain;
                background-image: url("data:image/webp;base64,UklGRkoCAABXRUJQVlA4WAoAAAAQAAAAHQAAHwAAQUxQSIEAAAABcFpt27K8L91pkm0KTxwGIMEO7pYcGolE9BUs0VxHkEqy3/+fl0qKiAkAAEAABEIESdtoYr1SrlBkurFzB8MSPlSiHPsT7Px17MvmHmUXRQmnJRgKU/pBjOknQ3rvo8jHsKRTNYixzZIyAZCOMCRsVkZ7oXk2fRJgrCyWpGOU+CkAVlA4IKIBAABwCQCdASoeACAAPmEoj0WkIqGb/VQAQAYEswBhsa8KA3gFgAdKgvwVsdYAxwUyDx3fSu/J9AD9dBN4HzXUGnIffZmZ+Xi6UOW2PLIrM//asS4J9gAA+nzKAwpZUP5tD9q71GP2da5pzrXFQhw7pRv+CMeoEN+kh+aUE4VmdB7sPfZs8IsDkQx5uoj5AjWh089yG//EwIyr/se6feMyVX1jaa8+MnQrGmsfLaVAoTq9RrJ37OhatyX20m/e/5Ph5E/2P/FpTDWXvb7Ta8uM487hoffTtj8mtyn8Fc4n6KteA//0CAaACYby7EAYe8857OPwrIv+/3fyVUAr4ga3+Uc/qEdrqwZ67A7Y0t4qBlDcm8Yk4xtY7wVHEKsF/rNmiezTq+r0Ysk1j3xNln94b5jV3f2/9VUZXqbv1fNiMWWdlm8cV5lf86F2H81wUKVQuoPeG7hAZhvU3NJ6DDmTY3fijNc29rpXd5tHHovD4H816Ukg7x4+L7ulAwyBuE8T3FhuuXF690Bq9sa/4l27s0Q8DeM8DKDkFM9s0CKf8J5QMYAA");
                /* background-image: url('https://cdn.discordapp.com/role-icons/1336817752844796016/da610f5548f174d9e04d49b1b28c3af1.webp?size=32&amp;quality=lossless'); */
            }

            .discord-scroll-container {
                width: 100%;
                height: 100%;
                overflow-y: auto;
                padding-bottom: 130px;
                scrollbar-width: none;
                -ms-overflow-style: none;
            }

            .discord-scroll-container::-webkit-scrollbar {
                display: none !important;
            }

            .discord-thread-input {
                position: absolute;
                left: 0;
                bottom: 0;
                width: 100%;
                height: 50px;
                border-top: 2px solid #e4e4e4;
                background-color: white;
                display: flex;
                align-items: center;
                padding: 0 5px;
                gap: 5px;
            }

            .discord-thread-input-svgbackground {
                width: 35px;
                min-width: 35px;
                height: 35px;
                border-radius: 50%;
                background-color: #ececec;
                display: flex;
                align-items: center;
                justify-content: center;

                svg {
                    width: 22px;
                    height: 22px;
                }
            }

            .discord-thread-input-userinput {
                height: 30px;
                flex: 1;
                border-radius: 24px;
                border: 0px;
                background-color: #ececec;
                padding: 0 5px 0 10px;
                box-sizing: border-box;
                display: block;
                min-width: 50px;
                outline: none;
            }

            .discord-thread-input-userinput:focus {
                outline: none;
            }

            .discord-thread-input-userinput::placeholder {
                display: inline-block;
                width: 100%;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
                direction: ltr;
            }

            .discord-cardget {
                background-color: #e8e9eb;
                padding: 10px 20px;
                border-radius: 100px;
                margin: auto;
                font-size: 1.5rem;
            }
            body {
                --yj: 22px;
                overflow: auto !important;
                -ms-overflow-style: none !important;
                scrollbar-width: none !important;
                letter-spacing: 0.7px;
                font-family: "JiangChengYuanTi";
                font-weight: normal;
            }
            .head {
                width: 40px;
                height: 40px;
                border-radius: 50%;
                min-width: 40px;
            }
            .user_avatar {
                width: 40px;
                height: 40px;
                border-radius: 50%;
                background-size: cover;
            }
            body::-webkit-scrollbar {
                display: none !important;
            }
            .card {
                max-width: min(350px, 95%);
                width: min(350px, 95%);
                position: relative;
                height: auto;
                aspect-ratio: 1/2;
                background: #1b1717;
                border-radius: 35px;
                border: 2px solid #810000;
                padding: 7px;
                box-shadow: 2px 3px 3px rgba(0, 0, 0, 0.25);
                margin-left: 5px;
                box-sizing: border-box;
            }
            .card-int {
                background-size: 200% 200%;
                background-position: 0% 0%;
                height: 100%;
                border-radius: 25px;
                transition: all 0.6s ease-out;
                overflow: hidden;
                box-sizing: border-box;
                position: relative;
            }
            .card:hover .card-int {
                background-position: 100% 100%;
            }
            #App_Page {
                background-size: 200% 200%;
                background-position: 0% 0%;
                height: 100%;
                border-radius: 25px;
                transition: all 0.6s ease-out;
                overflow: hidden;
                box-sizing: border-box;
                position: relative;
            }
            .top {
                position: absolute;
                top: 0px;
                right: 50%;
                -webkit-transform: translate(50%, 0%);
                transform: translate(50%, 0%);
                width: 35%;
                height: 22px;
                background-color: #1b1717;
                border-bottom-left-radius: 13px;
                border-bottom-right-radius: 13px;
                z-index: 9999999;
            }
            .speaker {
                position: absolute;
                top: 2px;
                right: 50%;
                -webkit-transform: translate(50%, 0%);
                transform: translate(50%, 0%);
                width: 40%;
                height: 2px;
                border-radius: 2px;
                background-color: rgb(20, 20, 20);
            }
            .camera {
                position: absolute;
                top: 6px;
                right: 84%;
                -webkit-transform: translate(50%, 0%);
                transform: translate(50%, 0%);
                width: 6px;
                height: 6px;
                border-radius: 50%;
                background-color: rgba(255, 255, 255, 0.048);
            }
            .int {
                position: absolute;
                width: 3px;
                height: 3px;
                border-radius: 50%;
                top: 50%;
                right: 50%;
                -webkit-transform: translate(50%, -50%);
                transform: translate(50%, -50%);
                background-color: rgba(0, 0, 255, 0.212);
            }
            .btn1,
            .btn2,
            .btn3,
            .btn4 {
                position: absolute;
                width: 2px;
            }
            .btn1,
            .btn2,
            .btn3 {
                height: 45px;
                top: 30%;
                right: -4px;
                background-color: #ce1212;
            }
            .btn2,
            .btn3 {
                -webkit-transform: scale(-1);
                transform: scale(-1);
                left: -4px;
            }
            .btn2,
            .btn3 {
                -webkit-transform: scale(-1);
                transform: scale(-1);
                height: 30px;
            }
            .btn2 {
                top: 26%;
            }
            .btn3 {
                top: 36%;
            }
            .hidden {
                display: block;
                opacity: 0;
                transition: all 0.3s ease-in;
            }
            .card:hover .hidden {
                opacity: 1;
            }
            .card:hover .hello {
                -webkit-transform: translateY(-20px);
                transform: translateY(-20px);
            }
            .btn {
                position: absolute;
                width: 2px;
            }
            .backdiv {
                background-color: white;
                height: 100%;
                width: 100%;
                position: relative;
                background-size: cover;
                background-position: top center;
                background-repeat: no-repeat;
                background-image: url("http://sharkpan.xyz/f/6osR/00005-660646865.png");
                box-sizing: border-box;
            }
            .dibu {
                position: absolute;
                bottom: 40px;
                left: 3%;
                right: 3%;
                background-color: black;
                height: auto;
                display: -webkit-flex;
                display: flex;
                -webkit-align-items: center;
                align-items: center;
                -webkit-justify-content: space-around;
                justify-content: space-around;
                padding: 0 5px 0 5px;
                border-radius: 30px;
                --a: 10px;
                background-color: rgba(255, 255, 255, 0.2);
                backdrop-filter: blur(var(--a));
                -webkit-backdrop-filter: blur(var(--a));
            }
            .dibu svg {
                -webkit-transform: scale(0.85);
                transform: scale(0.85);
                -webkit-transform-origin: center;
                transform-origin: center;
            }
            .dinbu {
                position: absolute;
                top: 10px;
                left: 7%;
                right: 2%;
                color: #626367;
                display: -webkit-flex;
                display: flex;
                -webkit-align-items: center;
                align-items: center;
                -webkit-justify-content: space-between;
                justify-content: space-between;
                z-index: 9999999;
            }
            .zhong {
                position: absolute;
                border-radius: 20px;
                --a: 3px;
                background-color: rgba(255, 255, 255, 0.2);
                backdrop-filter: blur(var(--a));
                -webkit-backdrop-filter: blur(var(--a));
                top: 30%;
                left: 4%;
                right: 4%;
                color: black;
                padding: 10px 15px 10px 10px;
                font-size: 32px;
                display: -webkit-flex;
                display: flex;
                -webkit-align-items: center;
                align-items: center;
                -webkit-justify-content: space-between;
                justify-content: space-between;
                letter-spacing: 2px;
            }
            .app {
                position: absolute;
                bottom: 120px;
                left: 4%;
                right: 4%;
                display: -webkit-flex;
                display: flex;
                -webkit-align-items: center;
                align-items: center;
                -webkit-justify-content: space-evenly;
                justify-content: space-evenly;
                color: black;
                box-sizing: border-box;
                max-width: 92%;
                -webkit-flex-wrap: wrap;
                flex-wrap: wrap;
            }
            .app-svg-div {
                max-width: 20%;
                -webkit-transform: scale(0.8);
                transform: scale(0.8);
                -webkit-transform-origin: center;
                transform-origin: center;
            }
            .QQ_home_head {
                border-radius: 50%;
                margin-right: 15px;
                margin-left: 5px;
                width: 40px;
                height: 40px;
                font-size: 0;
                min-width: 40px;
                background-size: cover;
            }
            .QQ_home_usermsg {
                --head_size: 40px;
                width: 100%;
                display: -webkit-flex;
                display: flex;
                font-size: 14px;
                -webkit-align-items: center;
                align-items: center;
                height: 60px;
                align-items: center;
                position: relative;
            }
            .QQ_home_usermsg > * {
                position: relative;
                z-index: 1;
            }
            .QQ_home_usermsg:active::before {
                content: "";
                position: absolute;
                top: 0;
                left: -10px;
                right: -10px;
                height: 100%;
                background-color: #d5d5d5;
            }
            .QQ_home_usermsg_new {
                background-color: red;
                border-radius: 50%;
                width: 17px;
                height: 17px;
                color: white;
                display: -webkit-flex;
                display: flex;
                -webkit-align-items: center;
                align-items: center;
                -webkit-justify-content: center;
                justify-content: center;
                font-size: 13px;
                justify-self: end;
                padding: 2px;
            }
            .QQ_home_usermsg_new_hidden {
                background-color: #dbdbdb;
                border-radius: 10px;
                width: 2rem;
                height: 17px;
                color: white;
                display: -webkit-flex;
                display: flex;
                -webkit-align-items: center;
                align-items: center;
                -webkit-justify-content: center;
                justify-content: center;
                font-size: 13px;
                justify-self: end;
                padding: 2px;
            }
            

            .QQ_bottom_nav {
                position: absolute;
                bottom: 0px;
                width: 100%;
                height: 40px;
                display: -webkit-flex;
                display: flex;
                -webkit-align-items: center;
                align-items: center;
                -webkit-justify-content: space-evenly;
                justify-content: space-evenly;
                font-size: 10px;
                background-color: white;
                z-index: 1000;
                border-top: 1px solid #e6e6e6;
            }
            body div {
                box-sizing: border-box !important;
            }
            .page_button {
                display: -webkit-flex;
                display: flex;
                -webkit-align-items: center;
                align-items: center;
                -webkit-justify-content: space-evenly;
                justify-content: space-evenly;
                width: 100%;
                z-index: 99;
                position: absolute;
                bottom: 0px;
                left: 0;
                height: 22px;
                box-sizing: border-box;
                padding-bottom: 4px;
            }
            @media (max-width: 768px) {
                .zhong {
                    font-size: 20px;
                }
            }
            #space_page {
                width: 100%;
                height: 820px;
                background-color: #fff;
                display: none;
            }
            .user_moment_title {
                --head_size: 40px;
                width: 100%;
                display: -webkit-flex;
                display: flex;
                font-size: 14px;
                -webkit-align-items: start;
                align-items: start;
                margin-bottom: 5px;
            }
            .user_moment {
                padding-left: 7px;
                padding-right: 7px;
                position: relative;
            }
            .moment_button {
                display: -webkit-flex;
                display: flex;
                -webkit-align-items: center;
                align-items: center;
                gap: 5px;
                margin-left: auto;
                -webkit-transform: scale(0.9);
                transform: scale(0.9);
                -webkit-transform-origin: center;
                transform-origin: center;
            }

            /* 动态点赞按钮样式 */
            .moment-like-button {
                cursor: pointer;
                transition: all 0.2s ease;
                filter: drop-shadow(0 1px 2px rgba(0,0,0,0.1));
            }

            .moment-like-button:hover {
                transform: scale(1.1);
                filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2));
            }

            .moment-like-button.liked {
                fill: #1677ff !important;
                animation: likeAnimation 0.3s ease-out;
                filter: drop-shadow(0 2px 6px rgba(22,119,255,0.3));
            }

            @keyframes likeAnimation {
                0% { transform: scale(1); }
                50% { transform: scale(1.3); }
                100% { transform: scale(1); }
            }

            /* 点赞弹窗样式 */
            .moment-like-popup {
                position: absolute;
                bottom: 25px;
                left: 0;
                background: #fff;
                border: 1px solid #ddd;
                border-radius: 4px;
                padding: 4px 8px;
                font-size: 12px;
                color: #666;
                display: none;
                box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                z-index: 1000;
                white-space: nowrap;
                animation: popupFadeIn 0.3s ease-out;
            }

            @keyframes popupFadeIn {
                0% { 
                    opacity: 0; 
                    transform: translateY(10px); 
                }
                100% { 
                    opacity: 1; 
                    transform: translateY(0); 
                }
            }

            /* 点赞数量样式 */
            .moment-like-count {
                color: #474545;
                font-size: 14px;
                transition: color 0.2s ease;
            }

            /* === 👍按钮点赞功能样式 === */
            /* 👍按钮点赞状态样式 */
            .liked-thumb {
                filter: drop-shadow(0 0 8px #1677ff) !important;
                transform: scale(1.2) !important;
                transition: all 0.3s ease !important;
            }
            
            /* 脉冲动画效果 */
            .pulse-animation {
                animation: thumbPulse 0.8s ease-in-out;
            }
            
            @keyframes thumbPulse {
                0% { transform: scale(1); filter: none; }
                50% { transform: scale(1.3); filter: drop-shadow(0 0 12px #1677ff); }
                100% { transform: scale(1.2); filter: drop-shadow(0 0 8px #1677ff); }
            }
            
            /* 用户已点赞提示样式 */
            .user-liked-tip {
                animation: slideInFromLeft 0.3s ease;
                display: block;
            }
            
            @keyframes slideInFromLeft {
                0% { opacity: 0; transform: translateX(-20px); }
                100% { opacity: 1; transform: translateX(0); }
            }
            
            /* 👍按钮悬停效果 */
            .moment_button svg:hover {
                transform: scale(1.1) !important;
                transition: all 0.2s ease !important;
                cursor: pointer !important;
            }
            
            /* 👍按钮基础样式 */
            .moment_button svg {
                transition: all 0.2s ease;
                cursor: pointer;
            }

            /* 动态评论发送按钮扩展点击范围 */
            .moment_comment {
                cursor: pointer;
                padding: 8px; /* 扩大点击范围 */
                margin: -8px; /* 使用负边距抵消padding的视觉影响 */
                border-radius: 6px;
                transition: all 0.2s ease;
                /* 增大发送按钮图标大小 */
                transform: scale(1.4);
                transform-origin: center;
            }
            
            .moment_comment:hover {
                background-color: rgba(0, 0, 0, 0.05); /* 悬停效果 */
                transform: scale(1.5); /* 悬停时稍微再放大 */
            }
            .moment_msg {
                background-color: #fff;
                margin-top: 5px;
                max-width: 60%;
                border-radius: 7px;
                font-size: 15px;
                padding: 6px;
                width: -webkit-fit-content;
                width: fit-content;
                white-space: normal;
                letter-spacing: 1px;
                line-height: 1.4;
                margin-bottom: 10px;
                box-shadow: 1px 1px 2px rgba(32, 32, 32, 0.2);
            }
            #Home_page {
                width: 100%;
                height: 100%;
                background-image: url("http://sharkpan.xyz/f/nBUl/%E6%89%8B%E6%9C%BA%E5%A3%81%E7%BA%B82.jpg");
                background-size: cover;
                background-position: top center;
                background-repeat: no-repeat;
            }
            .QQ_chat_head {
                width: 40px;
                height: 40px;
                border-radius: 50%;
                background-size: cover;
                min-width: 40px;
            }
            .user_avatar {
                width: 40px;
                height: 40px;
                border-radius: 50%;
                background-size: cover;
            }
            .QQ_chat_msg {
                font-size: 14px;
                margin-right: 5px;
                margin-left: 5px;
            }
            .QQ_chat_mymsg {
                max-width: 70%;
                margin-left: auto;
                display: grid;
                grid-template-columns: 1fr 50px;
                grid-template-rows: auto auto;
                justify-items: end;
                text-align: right;
                -webkit-align-items: start;
                align-items: start;
                margin-bottom: 20px;
                margin-right: 15px; /* 减少右边距让头像靠近边缘 */
            }
            .QQ_chat_charmsg {
                max-width: 80%;
                display: grid;
                grid-template-columns: 47px 1fr;
                grid-template-rows: auto auto;
                -webkit-align-items: start;
                align-items: start;
                margin-bottom: 20px;
                margin-left: 15px; /* 减少左边距让头像靠近边缘 */
            }
            .QQ_chat_msgdiv {
                box-shadow: 2px 2px 2px rgba(15, 15, 15, 0.3);
                letter-spacing: 1px;
                line-height: 1.4;
                font-size: 15px;
                width: -webkit-fit-content;
                width: fit-content;
                background-color: rgb(239, 206, 242, 0.65);
                color: black;
                border-radius: 7px;
                padding: 7px;
                text-align: left;
                box-sizing: border-box;
                margin-left: -2px;
            }
            .QQ_chat_name {
                font-size: 13px;
                color: black;
            }
            .QQ_chat_msgimg {
                width: 100%;
                background-color: white;
            }
            .msgimg {
                max-width: 100%;
                height: auto;
                display: block;
            }
            .QQ_chat_time {
                display: -webkit-flex;
                display: flex;
                -webkit-align-items: center;
                align-items: center;
                -webkit-justify-content: center;
                justify-content: center;
                width: 100%;
                height: 10px;
                margin-bottom: 10px;
                color: #a1a1a1;
            }
            .mimictwitter hr {
                background-color: rgb(240, 244, 245);
                border: none;
                height: 1px;
            }
            .twitterhead {
                width: 45px;
                height: 45px;
                border-radius: 50%;
                margin-left: 4px;
                min-width: 45px;
            }
            .interactsvg {
                width: 15.5px;
                height: 15.5px;
            }
            .twitter-content {
                -webkit-flex: 1;
                flex: 1;
                overflow-y: auto;
                box-sizing: border-box;
                padding-top: 10px;
                padding-right: 3px;
            }
            .mimictwitter {
                background-color: white;
                width: 100%;
                max-width: 100%;
                border-radius: 10px;
                height: 100%;
                box-sizing: border-box;
                padding-top: 10px;
                display: -webkit-flex;
                display: flex;
                -webkit-flex-direction: column;
                flex-direction: column;
                position: relative;
                overflow-x: hidden;
            }
            .twitter {
                overflow-x: hidden;
                font-size: 16px;
                height: 100%;
            }
            .twitter_moment {
                display: grid;
                grid-template-columns: 50px 1fr 0px;
                grid-template-rows: auto auto;
            }
            img {
                box-sizing: border-box !important;
            }
            * {
                box-sizing: border-box;
            }
            .user_leave_message {
                font-size: 13px;
                margin-top: 7px;
                display: -webkit-flex;
                display: flex;
                -webkit-flex-direction: column;
                flex-direction: column;
                span {
                    line-height: 1.5;
                }
            }
            .space_contents {
                scrollbar-width: none;
                -ms-overflow-style: none;
            }
            .give_money {
                margin-top: 10px;
                border-radius: 8px;
                overflow: hidden;
            }
            #QQ_home_chars {
                background-color: #fefefe;
                width: 100%;
                -webkit-flex: 1;
                flex: 1;
                border-radius: 20px 20px 20px 20px;
                padding: 5px 20px 20px 20px;
                box-sizing: border-box;
                overflow: auto !important;
                -ms-overflow-style: none !important;
                scrollbar-width: none !important;
                margin-bottom: 40px;
            }
            #QQ_home_chars::-webkit-scrollbar {
                display: none !important;
            }
            #QQ_home_page {
                display: -webkit-flex;
                display: flex;
                -webkit-flex-direction: column;
                flex-direction: column;
                height: 100%;
            }
            span {
                word-break: break-word;
            }
            .QQ_chat_music {
                background-color: #fefefe;
                border-radius: 10px;
                padding-top: 10px;
                padding-right: 10px;
                padding-left: 10px;
                padding-bottom: 5px;
                width: 100%;
            }
            .hide-title {
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }
            .music-play-button {
                position: absolute;
                border-radius: 50%;
                background-color: hsla(0, 0%, 100%, 0.2862745098);
                height: 32px;
                width: 32px;
                top: 50%;
                left: 50%;
                -webkit-transform: translate(-50%, -50%);
                transform: translate(-50%, -50%);
                z-index: 2;
                border: 2px solid white;
                display: -webkit-flex;
                display: flex;
                -webkit-justify-content: center;
                justify-content: center;
                -webkit-align-items: center;
                align-items: center;
            }
            .space_fakeimg {
                text-align: center;
                margin-top: 5px;
                font-size: 1.2rem;
                background-color: rgb(239 237 238);
                padding: 30px 10px;
                width: 100%;
                border: 1px solid black;
                border-radius: 5px;
                text-align: center;
            }
            .QQ_home_lasttime {
                overflow: hidden;
                white-space: nowrap;
                text-overflow: ellipsis;
                max-width: 4rem;
                margin-right: 5px;
            }
            #QQ_message_list_chars {
                background-color: #fefefe;
                width: 100%;
                -webkit-flex: 1;
                flex: 1;
                border-radius: 20px 20px 20px 20px;
                padding: 5px 20px 20px 20px;
                box-sizing: border-box;
                overflow: auto !important;
                -ms-overflow-style: none !important;
                scrollbar-width: none !important;
                margin-bottom: 40px;
            }
            #QQ_message_list_chars::-webkit-scrollbar {
                display: none !important;
            }
            
            /* 群聊管理下拉菜单样式 */
            .group-management-dropdown {
                position: absolute;
                top: 100%;
                left: 0;
                right: 0;
                background: white;
                border: 1px solid #e0e0e0;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                z-index: 10000;
                max-height: 300px;
                overflow-y: auto;
                margin-top: 5px;
            }
            
            .group-management-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 12px 15px;
                border-bottom: 1px solid #f0f0f0;
                background: #f8f9fa;
                border-radius: 8px 8px 0 0;
            }
            
            .group-management-title {
                font-size: 14px;
                font-weight: bold;
                color: #333;
            }
            
            .group-settings-icon {
                width: 20px;
                height: 20px;
                cursor: pointer;
                opacity: 0.7;
                transition: opacity 0.2s;
            }
            
            .group-settings-icon:hover {
                opacity: 1;
            }
            
            .group-members-list {
                padding: 8px 0;
            }
            
            .group-member-item {
                display: flex;
                align-items: center;
                padding: 8px 15px;
                transition: background-color 0.2s;
            }
            
            .group-member-item:hover {
                background-color: #f5f5f5;
            }
            
            .group-member-avatar {
                width: 32px;
                height: 32px;
                border-radius: 50%;
                margin-right: 10px;
                flex-shrink: 0;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 12px;
                font-weight: bold;
                color: white;
                background: linear-gradient(135deg, #667eea, #764ba2);
            }
            
            .group-member-name {
                flex: 1;
                font-size: 14px;
                color: #333;
            }
            
            /* 群聊设置模态窗口样式 */
            .group-settings-modal {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.5);
                display: none;
                justify-content: center;
                align-items: center;
                z-index: 20000;
            }
            
            .group-settings-content {
                background: white;
                border-radius: 12px;
                width: 90%;
                max-width: 400px;
                max-height: 80vh;
                overflow-y: auto;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            }
            
            .group-settings-header {
                padding: 20px;
                border-bottom: 1px solid #f0f0f0;
                text-align: center;
            }
            
            .group-settings-title {
                font-size: 18px;
                font-weight: bold;
                color: #333;
                margin: 0;
            }
            
            .group-settings-body {
                padding: 20px;
            }
            
            .group-settings-section {
                margin-bottom: 20px;
            }
            
            .group-settings-section-title {
                font-size: 14px;
                font-weight: bold;
                color: #333;
                margin-bottom: 10px;
            }
            
            .group-settings-input {
                width: 100%;
                padding: 10px;
                border: 1px solid #ddd;
                border-radius: 6px;
                font-size: 14px;
                box-sizing: border-box;
            }
            
            .group-settings-member-list {
                max-height: 200px;
                overflow-y: auto;
                border: 1px solid #f0f0f0;
                border-radius: 6px;
            }
            
            .group-settings-member-item {
                display: flex;
                align-items: center;
                justify-content: space-between;
                padding: 10px;
                border-bottom: 1px solid #f8f8f8;
            }
            
            .group-settings-member-item:last-child {
                border-bottom: none;
            }
            
            .group-settings-member-info {
                display: flex;
                align-items: center;
                flex: 1;
            }
            
            .group-settings-remove-btn {
                background: #ff4757;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 4px 8px;
                font-size: 12px;
                cursor: pointer;
                transition: background-color 0.2s;
            }
            
            .group-settings-remove-btn:hover {
                background: #ff3742;
            }
            
            /* 添加成员按钮样式 */
            .group-settings-add-member-item {
                margin-top: 10px;
            }
            
            .group-settings-add-member-btn {
                width: 100%;
                padding: 12px;
                border: 2px dashed #ddd;
                border-radius: 8px;
                background: transparent;
                color: #666;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 8px;
                font-size: 14px;
                transition: all 0.3s ease;
            }
            
            .group-settings-add-member-btn:hover {
                border-color: #199AFF;
                color: #199AFF;
                background: rgba(25, 154, 255, 0.05);
            }
            
            .add-member-icon {
                font-size: 18px;
                font-weight: bold;
            }
            
            /* 添加成员模态窗口样式 */
            .add-member-modal {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.5);
                display: none;
                justify-content: center;
                align-items: center;
                z-index: 25000;
            }
            
            .add-member-dialog {
                background: white;
                border-radius: 12px;
                width: 90%;
                max-width: 400px;
                max-height: 80vh;
                overflow: hidden;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            }
            
            .add-member-header {
                padding: 20px;
                border-bottom: 1px solid #eee;
                display: flex;
                justify-content: space-between;
                align-items: center;
                background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            }
            
            .add-member-title {
                font-size: 18px;
                font-weight: bold;
                color: #333;
                margin: 0;
            }
            
            .add-member-close {
                font-size: 24px;
                color: #999;
                cursor: pointer;
                line-height: 1;
            }
            
            .add-member-close:hover {
                color: #666;
            }
            
            .add-member-content {
                padding: 20px;
                max-height: 400px;
                overflow-y: auto;
            }
            
            .add-member-search {
                position: relative;
                margin-bottom: 15px;
            }
            
            .add-member-search-input {
                width: 100%;
                padding: 10px 40px 10px 15px;
                border: 1px solid #ddd;
                border-radius: 8px;
                font-size: 14px;
                box-sizing: border-box;
            }
            
            .add-member-search-input:focus {
                outline: none;
                border-color: #199AFF;
            }
            
            .add-member-search-icon {
                position: absolute;
                right: 12px;
                top: 50%;
                transform: translateY(-50%);
                color: #999;
            }
            
            .add-member-contact-list {
                max-height: 300px;
                overflow-y: auto;
            }
            
            .add-member-contact-item {
                display: flex;
                align-items: center;
                padding: 12px;
                border-radius: 8px;
                cursor: pointer;
                transition: all 0.2s ease;
                border: 2px solid transparent;
                margin-bottom: 8px;
            }
            
            .add-member-contact-item:hover {
                background: #f8f9fa;
                border-color: #e9ecef;
            }
            
            .add-member-contact-item.selected {
                background: #e3f2fd;
                border-color: #199AFF;
            }
            
            .add-member-contact-item.disabled {
                /* 移除 opacity: 0.5; 避免分组中角色变灰 */
                cursor: not-allowed;
            }
            
            .add-member-contact-item.disabled:hover {
                background: transparent;
                border-color: transparent;
            }
            
            .add-member-contact-avatar {
                width: 40px;
                height: 40px;
                border-radius: 50%;
                margin-right: 12px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-weight: bold;
                font-size: 14px;
                color: white;
                background-size: cover;
                background-position: center;
                flex-shrink: 0;
            }
            
            .add-member-contact-name {
                flex: 1;
                font-size: 14px;
                color: #333;
                font-weight: 500;
            }
            
            .add-member-contact-status {
                font-size: 12px;
                color: #666;
                padding: 4px 8px;
                border-radius: 12px;
                background: #f0f0f0;
                transition: all 0.2s ease;
            }
            
            .add-member-contact-item.selected .add-member-contact-status {
                background: #199AFF;
                color: white;
            }
            
            .add-member-actions {
                padding: 20px;
                border-top: 1px solid #eee;
                display: flex;
                gap: 12px;
                justify-content: flex-end;
                background: #fafafa;
            }
            
            .add-member-btn {
                padding: 12px 24px;
                border: none;
                border-radius: 8px;
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.3s ease;
                min-width: 80px;
            }
            
            .add-member-cancel-btn {
                background: #f8f9fa;
                color: #666;
                border: 1px solid #dee2e6;
            }
            
            .add-member-cancel-btn:hover {
                background: #e9ecef;
                border-color: #adb5bd;
            }
            
            .add-member-confirm-btn {
                background: linear-gradient(135deg, #199AFF, #0066CC);
                color: white;
                box-shadow: 0 2px 8px rgba(25, 154, 255, 0.3);
            }
            
            .add-member-confirm-btn:hover {
                background: linear-gradient(135deg, #0066CC, #004499);
                box-shadow: 0 4px 12px rgba(25, 154, 255, 0.4);
                transform: translateY(-1px);
            }
            
            .add-member-confirm-btn:disabled {
                background: #ccc;
                cursor: not-allowed;
                box-shadow: none;
                transform: none;
            }
            
            .group-settings-actions {
                display: flex;
                gap: 10px;
                padding: 20px;
                border-top: 1px solid #f0f0f0;
            }
            
            .group-settings-btn {
                flex: 1;
                padding: 12px;
                border: none;
                border-radius: 6px;
                font-size: 14px;
                font-weight: bold;
                cursor: pointer;
                transition: all 0.2s;
            }
            
            .group-settings-save-btn {
                background: #199AFF;
                color: white;
            }
            
            .group-settings-save-btn:hover {
                background: #0066CC;
            }
            
            .group-settings-delete-btn {
                background: #ff4757;
                color: white;
            }
            
            .group-settings-delete-btn:hover {
                background: #ff3742;
            }
            
            .group-settings-cancel-btn {
                background: #f1f2f6;
                color: #333;
            }
            
            .group-settings-cancel-btn:hover {
                background: #ddd;
            }
            
            /* 群聊设置头像相关样式 */
            .group-settings-avatar-container {
                display: flex;
                align-items: center;
                gap: 15px;
                padding: 10px 0;
            }
            
            .group-settings-avatar-preview {
                width: 60px;
                height: 60px;
                border-radius: 50%;
                background: #4CAF50;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                transition: all 0.2s ease;
                overflow: hidden;
            }
            
            .group-settings-avatar-preview:hover {
                transform: scale(1.05);
                box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            }
            
            .group-settings-default-avatar {
                color: white;
                font-size: 20px;
                font-weight: bold;
            }
            
            .group-settings-avatar-preview img {
                width: 100%;
                height: 100%;
                object-fit: cover;
                border-radius: 50%;
            }
            
            .group-settings-avatar-text {
                color: #199AFF;
                cursor: pointer;
                font-size: 14px;
                user-select: none;
            }
            
            .group-settings-avatar-text:hover {
                text-decoration: underline;
            }

            /* 群聊创建弹窗样式 */
            .group-chat-modal {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.5);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 1000;
                backdrop-filter: blur(3px);
            }
            
            .group-chat-dialog {
                background-color: #ffffff;
                border-radius: 15px;
                width: 280px;
                max-height: 400px;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
                overflow: hidden;
                animation: modalSlideIn 0.3s ease-out;
            }
            
            @keyframes modalSlideIn {
                from {
                    opacity: 0;
                    transform: scale(0.8) translateY(-20px);
                }
                to {
                    opacity: 1;
                    transform: scale(1) translateY(0);
                }
            }
            
            .group-chat-header {
                background: linear-gradient(135deg, #199AFF, #0066CC);
                color: white;
                padding: 15px 20px;
                text-align: center;
                font-size: 16px;
                font-weight: bold;
            }
            
            .group-chat-content {
                padding: 20px;
            }
            
            .group-chat-option {
                display: flex;
                align-items: center;
                padding: 12px 15px;
                margin-bottom: 10px;
                border-radius: 8px;
                background-color: #f8f9fa;
                cursor: pointer;
                transition: all 0.2s ease;
                border: 1px solid #e9ecef;
            }
            
            .group-chat-option:hover {
                background-color: #e3f2fd;
                border-color: #199AFF;
                transform: translateY(-1px);
            }
            
            .group-chat-option-icon {
                width: 24px;
                height: 24px;
                margin-right: 12px;
                fill: #199AFF;
            }
            
            .group-chat-option-text {
                font-size: 14px;
                color: #333;
                font-weight: 500;
            }
            
            .group-create-modal {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.5);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 1001;
                backdrop-filter: blur(3px);
            }
            
            .group-create-dialog {
                background-color: #ffffff;
                border-radius: 15px;
                width: 320px;
                max-height: 85vh;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
                overflow: hidden;
                animation: modalSlideIn 0.3s ease-out;
                display: flex;
                flex-direction: column;
            }
            
            .group-create-header {
                background: linear-gradient(135deg, #199AFF, #0066CC);
                color: white;
                padding: 15px 20px;
                display: flex;
                align-items: center;
                justify-content: space-between;
            }
            
            .group-create-title {
                font-size: 16px;
                font-weight: bold;
            }
            
            .group-create-close {
                color: white;
                font-size: 20px;
                cursor: pointer;
                padding: 2px 6px;
                border-radius: 50%;
                transition: background-color 0.2s;
            }
            
            .group-create-close:hover {
                background-color: rgba(255, 255, 255, 0.2);
            }
            
            .group-create-content {
                padding: 20px;
                flex: 1;
                overflow-y: auto;
                min-height: 0;
            }
            
            .group-name-section {
                margin-bottom: 20px;
            }
            
            .group-name-label {
                display: block;
                font-size: 14px;
                color: #333;
                margin-bottom: 8px;
                font-weight: 500;
            }
            
            .group-name-input {
                width: 100%;
                padding: 10px 12px;
                border: 2px solid #e9ecef;
                border-radius: 8px;
                font-size: 14px;
                outline: none;
                transition: border-color 0.2s;
                box-sizing: border-box;
            }
            
            .group-name-input:focus {
                border-color: #199AFF;
            }
            
            .group-members-section {
                margin-bottom: 20px;
            }
            
            .group-members-label {
                font-size: 14px;
                color: #333;
                margin-bottom: 10px;
                font-weight: 500;
            }
            
            .contact-item {
                display: flex;
                align-items: center;
                padding: 12px 8px;
                border-radius: 8px;
                margin-bottom: 6px;
                cursor: pointer;
                transition: all 0.3s ease;
                border: 2px solid transparent;
                position: relative; /* 为选择标记提供定位基准 */
            }
            
            .contact-item:last-child {
                margin-bottom: 0;
            }
            
            .contact-item:hover {
                background-color: #f8f9fa;
                transform: translateX(2px);
            }
            
            .contact-item.selected {
                background: linear-gradient(135deg, #199AFF 0%, #0066CC 100%) !important;
                color: white !important;
                border-color: #0066CC !important;
                box-shadow: 0 4px 12px rgba(25, 154, 255, 0.3) !important;
                transform: scale(1.02) !important;
                transition: all 0.2s ease !important;
            }
            
            .contact-item.selected .contact-name {
                color: white !important;
                font-weight: 500 !important;
            }
            
            /* 选中状态下的搜索高亮样式 */
            .contact-item.selected .contact-name span {
                background-color: rgba(255, 255, 255, 0.3) !important;
                color: white !important;
            }
            
            .contact-item.selected .contact-avatar {
                border: 2px solid rgba(255, 255, 255, 0.5) !important;
                box-shadow: 0 0 8px rgba(255, 255, 255, 0.3) !important;
            }
            
            /* 增强选择状态的视觉反馈 */
            .contact-item.selected::before {
                content: '✓';
                position: absolute;
                right: 8px;
                top: 50%;
                transform: translateY(-50%);
                color: white;
                font-weight: bold;
                font-size: 16px;
                z-index: 10;
            }
            
            .contact-checkbox {
                display: none; /* 隐藏原始复选框 */
            }
            
            /* 群聊成员搜索框样式 */
            .group-member-search {
                position: relative;
                margin-bottom: 15px;
            }
            
            .group-search-input {
                width: 100%;
                padding: 10px 12px 10px 35px;
                border: 2px solid #e9ecef;
                border-radius: 8px;
                font-size: 14px;
                outline: none;
                transition: border-color 0.2s;
                box-sizing: border-box;
                background-color: #f8f9fa;
            }
            
            .group-search-input:focus {
                border-color: #199AFF;
                background-color: white;
            }
            
            .group-search-icon {
                position: absolute;
                left: 10px;
                top: 50%;
                transform: translateY(-50%);
                color: #666;
                font-size: 14px;
            }
            
            .group-search-clear {
                position: absolute;
                right: 10px;
                top: 50%;
                transform: translateY(-50%);
                color: #999;
                cursor: pointer;
                font-size: 16px;
                padding: 2px;
                border-radius: 50%;
                transition: all 0.2s;
                display: none;
            }
            
            .group-search-clear:hover {
                background-color: #e9ecef;
                color: #666;
            }
            
            .group-search-clear.show {
                display: block;
            }
            
            /* 联系人列表容器 */
            .contact-list-container {
                max-height: 250px;
                overflow-y: auto;
                padding-right: 5px;
            }
            
            .contact-list-container::-webkit-scrollbar {
                width: 4px;
            }
            
            .contact-list-container::-webkit-scrollbar-track {
                background: #f1f1f1;
                border-radius: 4px;
            }
            
            .contact-list-container::-webkit-scrollbar-thumb {
                background: #c1c1c1;
                border-radius: 4px;
            }
            
            .contact-list-container::-webkit-scrollbar-thumb:hover {
                background: #a8a8a8;
            }
            
            /* 无搜索结果提示 */
            .no-results {
                text-align: center;
                color: #999;
                padding: 20px;
                font-size: 14px;
            }
            
            .contact-avatar {
                width: 32px;
                height: 32px;
                border-radius: 50%;
                margin-right: 10px;
                background-color: #f0f0f0;
                background-size: cover;
                background-position: center;
                flex-shrink: 0;
            }
            
            .contact-name {
                font-size: 14px;
                color: #333;
                flex: 1;
            }
            
            .group-create-actions {
                padding: 15px 20px;
                background-color: #f8f9fa;
                display: flex;
                gap: 10px;
            }
            
            .group-action-btn {
                flex: 1;
                padding: 10px 16px;
                border: none;
                border-radius: 8px;
                font-size: 14px;
                font-weight: 500;
                cursor: pointer;
                transition: all 0.2s ease;
            }
            
            .group-cancel-btn {
                background-color: #f8f9fa;
                color: #666;
                border: 1px solid #e9ecef;
            }
            
            .group-cancel-btn:hover {
                background-color: #e9ecef;
            }
            
            .group-confirm-btn {
                background: linear-gradient(135deg, #199AFF, #0066CC);
                color: white;
            }
            
            .group-confirm-btn:hover {
                transform: translateY(-1px);
                box-shadow: 0 4px 12px rgba(25, 154, 255, 0.3);
            }
            
            .group-confirm-btn:disabled {
                opacity: 0.5;
                cursor: not-allowed;
                transform: none;
                box-shadow: none;
            }
            
            /* ==================== 群聊头像设置样式 ==================== */
            
            .group-avatar-section {
                margin-bottom: 20px;
            }
            
            .group-avatar-label {
                display: block;
                margin-bottom: 8px;
                font-size: 14px;
                font-weight: 500;
                color: #333;
            }
            
            .group-avatar-selector {
                display: flex;
                align-items: center;
                gap: 12px;
                cursor: pointer;
                transition: all 0.2s ease;
            }
            
            .group-avatar-selector:hover {
                opacity: 0.8;
            }
            
            .group-avatar-preview {
                width: 60px;
                height: 60px;
                border-radius: 12px;
                display: flex;
                align-items: center;
                justify-content: center;
                background: linear-gradient(135deg, #199AFF, #0066CC);
                cursor: pointer;
                transition: all 0.2s ease;
                position: relative;
                overflow: hidden;
            }
            
            .group-avatar-preview:hover {
                transform: scale(1.05);
                box-shadow: 0 4px 15px rgba(25, 154, 255, 0.3);
            }
            
            .default-group-avatar {
                color: white;
                font-size: 24px;
                font-weight: bold;
            }
            
            .group-avatar-preview img {
                width: 100%;
                height: 100%;
                object-fit: cover;
                border-radius: 12px;
            }
            
            .group-avatar-text {
                color: #666;
                font-size: 14px;
                cursor: pointer;
            }
            
            /* ==================== 头像选择器弹窗样式 ==================== */
            
            .avatar-selector-modal {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.5);
                backdrop-filter: blur(5px);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 30000; /* 确保在群聊设置模态窗口(z-index: 20000)之上 */
                animation: modalFadeIn 0.3s ease;
            }
            
            .avatar-selector-dialog {
                background: white;
                border-radius: 16px;
                width: 90%;
                max-width: 450px;
                max-height: 80vh;
                overflow: hidden;
                box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
                animation: modalSlideIn 0.3s ease;
            }
            
            .avatar-selector-header {
                display: flex;
                align-items: center;
                justify-content: space-between;
                padding: 20px 20px 15px;
                border-bottom: 1px solid #e9ecef;
                background: linear-gradient(135deg, #199AFF, #0066CC);
                color: white;
            }
            
            .avatar-selector-title {
                font-size: 16px;
                font-weight: 600;
            }
            
            .avatar-selector-close {
                font-size: 24px;
                cursor: pointer;
                padding: 0 5px;
                border-radius: 50%;
                transition: all 0.2s ease;
                color: white;
            }
            
            .avatar-selector-close:hover {
                background-color: rgba(255, 255, 255, 0.2);
            }
            
            .avatar-selector-content {
                display: flex;
                flex-direction: column;
                max-height: 500px;
            }
            
            .avatar-selector-tabs {
                display: flex;
                background-color: #f8f9fa;
                border-bottom: 1px solid #e9ecef;
            }
            
            .avatar-tab {
                flex: 1;
                padding: 12px 16px;
                text-align: center;
                cursor: pointer;
                font-size: 14px;
                color: #666;
                border-bottom: 3px solid transparent;
                transition: all 0.2s ease;
            }
            
            .avatar-tab.active {
                color: #199AFF;
                border-bottom-color: #199AFF;
                background-color: white;
                font-weight: 500;
            }
            
            .avatar-tab:hover:not(.active) {
                background-color: #e9ecef;
            }
            
            .avatar-selector-body {
                flex: 1;
                padding: 20px;
                overflow-y: auto;
            }
            
            .avatar-options {
                display: none;
            }
            
            .avatar-options.active {
                display: block;
            }
            
            /* 预设头像网格 */
            .preset-avatar-grid {
                display: grid;
                grid-template-columns: repeat(4, 1fr);
                gap: 12px;
            }
            
            .preset-avatar-item {
                aspect-ratio: 1;
                border-radius: 12px;
                cursor: pointer;
                border: 3px solid transparent;
                transition: all 0.2s ease;
                background: linear-gradient(135deg, var(--gradient-start), var(--gradient-end));
                display: flex;
                align-items: center;
                justify-content: center;
                color: white;
                font-size: 18px;
                font-weight: bold;
                position: relative;
                overflow: hidden;
            }
            
            .preset-avatar-item:hover {
                transform: scale(1.05);
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            }
            
            .preset-avatar-item.selected {
                border-color: #199AFF;
                transform: scale(1.1);
                box-shadow: 0 6px 20px rgba(25, 154, 255, 0.4);
            }
            
            .preset-avatar-item img {
                width: 100%;
                height: 100%;
                object-fit: cover;
                border-radius: 8px;
            }
            
            /* 上传区域 */
            .upload-zone {
                border: 2px dashed #ddd;
                border-radius: 12px;
                padding: 40px 20px;
                text-align: center;
                cursor: pointer;
                transition: all 0.2s ease;
                background-color: #f8f9fa;
            }
            
            .upload-zone:hover {
                border-color: #199AFF;
                background-color: rgba(25, 154, 255, 0.05);
            }
            
            .upload-icon {
                font-size: 48px;
                margin-bottom: 12px;
                color: #666;
            }
            
            .upload-text {
                font-size: 16px;
                color: #333;
                margin-bottom: 8px;
                font-weight: 500;
            }
            
            .upload-hint {
                font-size: 12px;
                color: #666;
            }
            
            /* URL输入区域 */
            .url-input-zone {
                padding: 20px;
                text-align: center;
            }
            
            .url-input-title {
                font-size: 16px;
                color: #333;
                margin-bottom: 15px;
                font-weight: 500;
            }
            
            .url-input {
                width: 100%;
                padding: 12px 16px;
                border: 2px solid #e9ecef;
                border-radius: 8px;
                font-size: 14px;
                transition: all 0.2s ease;
                box-sizing: border-box;
            }
            
            .url-input:focus {
                outline: none;
                border-color: #199AFF;
                box-shadow: 0 0 0 3px rgba(25, 154, 255, 0.1);
            }
            
            .url-input-hint {
                font-size: 12px;
                color: #666;
                margin-top: 8px;
            }
            
            .url-preview-container {
                margin-top: 20px;
                padding: 15px;
                border: 1px solid #e9ecef;
                border-radius: 8px;
                background-color: #f8f9fa;
            }
            
            .url-preview-title {
                font-size: 14px;
                color: #333;
                margin-bottom: 10px;
                font-weight: 500;
            }
            
            .url-preview-image {
                max-width: 120px;
                max-height: 120px;
                border-radius: 8px;
                object-fit: cover;
                border: 2px solid #e9ecef;
            }
            
            .avatar-selector-actions {
                padding: 15px 20px;
                background-color: #f8f9fa;
                display: flex;
                gap: 10px;
                border-top: 1px solid #e9ecef;
            }
            
            .avatar-action-btn {
                flex: 1;
                padding: 10px 16px;
                border: none;
                border-radius: 8px;
                font-size: 14px;
                font-weight: 500;
                cursor: pointer;
                transition: all 0.2s ease;
            }
            
            .avatar-cancel-btn {
                background-color: #f8f9fa;
                color: #666;
                border: 1px solid #e9ecef;
            }
            
            .avatar-cancel-btn:hover {
                background-color: #e9ecef;
            }
            
            .avatar-confirm-btn {
                background: linear-gradient(135deg, #199AFF, #0066CC);
                color: white;
            }
            
            .avatar-confirm-btn:hover {
                transform: translateY(-1px);
                box-shadow: 0 4px 12px rgba(25, 154, 255, 0.3);
            }
            
            .avatar-confirm-btn:disabled {
                opacity: 0.5;
                cursor: not-allowed;
                transform: none;
                box-shadow: none;
            }
            
            /* 添加按钮hover效果 */
            .add-button {
                cursor: pointer;
                transition: all 0.2s ease;
                border-radius: 50%;
                padding: 4px;
            }
            
            .add-button:hover {
                background-color: rgba(25, 154, 255, 0.1);
                transform: scale(1.1);
            }
            
            /* ==================== 联系人分组功能样式 ==================== */
            
            /* 分组管理按钮 */
            .group-manage-btn {
                position: absolute;
                top: 15px;
                right: 70px;
                background: linear-gradient(135deg, #199AFF, #0066CC);
                color: white;
                border: none;
                border-radius: 6px;
                padding: 6px 12px;
                font-size: 12px;
                cursor: pointer;
                transition: all 0.2s ease;
                z-index: 100;
            }
            
            .group-manage-btn:hover {
                transform: translateY(-1px);
                box-shadow: 0 4px 12px rgba(25, 154, 255, 0.3);
            }
            
            /* 分组容器 */
            .contact-group {
                margin-bottom: 8px;
                border-radius: 8px;
                overflow: hidden;
                background-color: #f8f9fa;
                border: 1px solid #e9ecef;
                transition: all 0.3s ease;
            }
            
            .contact-group.dragging {
                opacity: 0.7;
                transform: scale(0.98);
                box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
            }
            
            /* 未分组区域样式 */
            .ungrouped-contacts {
                margin-top: 15px;
                padding: 10px;
                border: 1px dashed #ddd;
                border-radius: 8px;
                background-color: #fafafa;
                position: relative;
            }
            
            .ungrouped-header {
                font-size: 12px;
                color: #666;
                margin-bottom: 10px;
                font-weight: 500;
            }
            
            .ungrouped-drop-zone {
                position: absolute;
                top: 30px;
                left: 0;
                right: 0;
                bottom: 0;
                border-radius: 6px;
                z-index: 1;
            }
            
            /* 拖拽时的视觉反馈 */
            .QQ_home_usermsg.dragging {
                opacity: 0.5;
                transform: rotate(5deg);
            }
            
            .drop-zone.active {
                border: 2px dashed #199AFF;
                background-color: rgba(25, 154, 255, 0.1);
                animation: pulse 2s infinite;
            }
            
            @keyframes pulse {
                0% { opacity: 0.1; }
                50% { opacity: 0.3; }
                100% { opacity: 0.1; }
            }
            
            /* 群聊成员数显示 */
            .group-member-count {
                position: absolute;
                right: 15px;
                top: 50%;
                transform: translateY(-50%);
                font-size: 12px;
                color: #999;
                background-color: #f0f0f0;
                padding: 2px 6px;
                border-radius: 10px;
                min-width: 20px;
                text-align: center;
            }
            
            /* 分组标题栏 */
            .group-header {
                display: flex;
                align-items: center;
                padding: 12px 15px;
                background: linear-gradient(135deg, #f8f9fa, #e9ecef);
                cursor: pointer;
                border-bottom: 1px solid #dee2e6;
                position: relative;
            }
            
            .group-header:hover {
                background: linear-gradient(135deg, #e9ecef, #dee2e6);
            }
            
            /* 分组拖拽手柄 */
            .group-drag-handle {
                margin-right: 8px;
                color: #999;
                cursor: grab;
                font-size: 14px;
                transition: color 0.2s;
            }
            
            .group-drag-handle:hover {
                color: #666;
            }
            
            .group-drag-handle:active {
                cursor: grabbing;
            }
            
            /* 分组折叠图标 */
            .group-toggle {
                margin-right: 8px;
                color: #666;
                font-size: 12px;
                transition: transform 0.3s ease;
                cursor: pointer;
            }
            
            .group-toggle.collapsed {
                transform: rotate(-90deg);
            }
            
            /* 分组名称 */
            .group-name {
                flex: 1;
                font-size: 14px;
                font-weight: 500;
                color: #333;
                cursor: pointer;
                padding: 2px 4px;
                border-radius: 4px;
                transition: background-color 0.2s;
            }
            
            .group-name:hover {
                background-color: rgba(25, 154, 255, 0.1);
            }
            
            .group-name.editing {
                background-color: white;
                border: 2px solid #199AFF;
                outline: none;
            }
            
            /* 分组成员数量 */
            .group-count {
                background-color: #199AFF;
                color: white;
                border-radius: 10px;
                padding: 2px 6px;
                font-size: 11px;
                font-weight: 500;
                margin-left: 8px;
            }
            
            /* 分组删除按钮 */
            .group-delete-btn {
                margin-left: 8px;
                color: #dc3545;
                cursor: pointer;
                padding: 2px 4px;
                border-radius: 4px;
                font-size: 12px;
                opacity: 0;
                transition: all 0.2s;
            }
            
            .group-header:hover .group-delete-btn {
                opacity: 1;
            }
            
            .group-delete-btn:hover {
                background-color: #dc3545;
                color: white;
            }
            
            /* 分组内容区域 */
            .group-content {
                padding: 0;
                background-color: white;
                transition: all 0.3s ease;
                overflow: hidden;
            }
            
            .group-content.collapsed {
                max-height: 0;
                padding: 0;
                border-top: none;
            }
            
            .group-content.expanded {
                max-height: 1000px;
            }
            
            /* 分组内的联系人项 */
            .group-content .QQ_home_usermsg {
                margin: 0;
                padding: 12px 20px;
                border-bottom: 1px solid #f0f0f0;
                position: relative;
                transition: all 0.2s ease;
            }
            
            .group-content .QQ_home_usermsg:last-child {
                border-bottom: none;
            }
            
            .group-content .QQ_home_usermsg:hover {
                background-color: #f8f9fa;
                transform: translateX(4px);
            }
            
            .group-content .QQ_home_usermsg.dragging {
                opacity: 0.5;
                transform: scale(0.95);
            }
            
            /* 未分组联系人区域 */
            .ungrouped-contacts {
                margin-top: 10px;
            }
            
            .ungrouped-header {
                padding: 10px 15px;
                font-size: 12px;
                color: #999;
                background-color: #f8f9fa;
                border-top: 1px solid #e9ecef;
                border-bottom: 1px solid #e9ecef;
            }
            
            /* 拖拽提示区域 */
            .drop-zone {
                min-height: 40px;
                border: 2px dashed #ddd;
                border-radius: 8px;
                margin: 5px 0;
                display: flex;
                align-items: center;
                justify-content: center;
                color: #999;
                font-size: 12px;
                transition: all 0.2s;
                opacity: 0;
                transform: scaleY(0);
            }
            
            .drop-zone.active {
                opacity: 1;
                transform: scaleY(1);
                border-color: #199AFF;
                background-color: rgba(25, 154, 255, 0.1);
                color: #199AFF;
            }
            
            /* 新建分组弹窗 */
            .new-group-modal {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.5);
                display: none;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                backdrop-filter: blur(4px);
            }
            
            .new-group-dialog {
                background-color: white;
                border-radius: 12px;
                padding: 24px;
                width: 280px;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
                animation: modalSlideIn 0.3s ease-out;
            }
            
            .new-group-title {
                font-size: 16px;
                font-weight: bold;
                margin-bottom: 16px;
                color: #333;
            }
            
            .new-group-input {
                width: 100%;
                padding: 10px 12px;
                border: 2px solid #e9ecef;
                border-radius: 8px;
                font-size: 14px;
                outline: none;
                transition: border-color 0.2s;
                box-sizing: border-box;
                margin-bottom: 16px;
            }
            
            .new-group-input:focus {
                border-color: #199AFF;
            }
            
            .new-group-actions {
                display: flex;
                gap: 10px;
            }
            
            .new-group-btn {
                flex: 1;
                padding: 10px 16px;
                border: none;
                border-radius: 8px;
                font-size: 14px;
                font-weight: 500;
                cursor: pointer;
                transition: all 0.2s ease;
            }
            
            .new-group-cancel {
                background-color: #f8f9fa;
                color: #666;
                border: 1px solid #e9ecef;
            }
            
            .new-group-cancel:hover {
                background-color: #e9ecef;
            }
            
            .new-group-confirm {
                background: linear-gradient(135deg, #199AFF, #0066CC);
                color: white;
            }
            
            .new-group-confirm:hover {
                transform: translateY(-1px);
                box-shadow: 0 4px 12px rgba(25, 154, 255, 0.3);
            }

            /* 群组成员下拉菜单样式 */
            .group-member-dropdown {
                position: absolute;
                top: 100%;
                left: 0;
                width: 250px;
                max-height: 300px;
                background: white;
                border: 1px solid #ddd;
                border-radius: 8px;
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
                z-index: 1000;
                overflow-y: auto;
                padding: 8px 0;
                margin-top: 4px;
            }

            .group-member-dropdown .member-item {
                display: flex;
                align-items: center;
                padding: 8px 12px;
                cursor: pointer;
                transition: background-color 0.2s;
            }

            .group-member-dropdown .member-item:hover {
                background-color: #f5f5f5;
            }

            .group-member-dropdown .member-avatar {
                width: 32px;
                height: 32px;
                border-radius: 50%;
                margin-right: 10px;
                object-fit: cover;
                border: 1px solid #eee;
            }

            .group-member-dropdown .member-name {
                font-size: 14px;
                color: #333;
                font-weight: 500;
            }

            .group-member-dropdown .dropdown-header {
                padding: 8px 12px;
                font-size: 12px;
                color: #666;
                font-weight: bold;
                border-bottom: 1px solid #eee;
                margin-bottom: 4px;
            }

            /* 确保群组标题可点击的样式 */
            .chat-title.clickable {
                cursor: pointer;
                user-select: none;
                position: relative;
            }

            .chat-title.clickable:hover {
                text-decoration: underline;
            }
            /* 系统消息样式 */
            .system-message {
                text-align: center;
                font-size: 12px;
                color: #999;
                padding: 8px 0;
                width: 100%;
                box-sizing: border-box;
            }
        </style>
    </head>
    <body>
        <div class="card">
            <div class="btn1"></div>
            <div class="btn2"></div>
            <div class="btn3"></div>
            <div class="btn4"></div>
            <div class="dinbu">
                <span id="time">18:58</span>
                <div
                    style="
                        display: flex;
                        align-items: center;
                        justify-self: end;
                        gap: 2px;
                    "
                >
                    <svg viewBox="0 0 1024 1024" width="16" height="15">
                        <path
                            d="M926.634667 294.912a32 32 0 1 1-39.936 50.005333C780.512 260.128 649.824 213.333333 512.053333 213.333333c-137.813333 0-268.544 46.826667-374.752 131.669334a32 32 0 1 1-39.936-50.005334C214.784 201.194667 359.562667 149.333333 512.053333 149.333333c152.437333 0 297.173333 51.818667 414.581334 145.578667z m-235.413334 298.133333a32 32 0 0 1-38.442666 51.178667A233.418667 233.418667 0 0 0 512.021333 597.333333c-51.541333 0-100.48 16.629333-140.8 46.912a32 32 0 1 1-38.442666-51.157333A297.408 297.408 0 0 1 512.021333 533.333333c65.504 0 127.893333 21.184 179.2 59.722667z m128-149.344a32 32 0 0 1-38.442666 51.168C703.829333 437.066667 610.378667 405.333333 512.032 405.333333c-98.368 0-191.850667 31.754667-268.8 89.578667a32 32 0 1 1-38.453333-51.157333C292.736 377.664 399.669333 341.333333 512.032 341.333333c112.32 0 219.242667 36.309333 307.189333 102.368zM512 853.333333a64 64 0 1 1 0-128 64 64 0 0 1 0 128z"
                            fill="currentColor"
                        ></path>
                    </svg>
                    <span>78%</span>
                    <svg
                        viewBox="0 0 1024 1024"
                        width="20"
                        height="20"
                        style="justify-self: end; margin-right: 13px"
                    >
                        <path
                            d="M984.2 434.8c-5-2.9-8.2-8.2-8.2-13.9v-99.3c0-53.6-43.9-97.5-97.5-97.5h-781C43.9 224 0 267.9 0 321.5v380.9C0 756.1 43.9 800 97.5 800h780.9c53.6 0 97.5-43.9 97.5-97.5v-99.3c0-5.8 3.2-11 8.2-13.9 23.8-13.9 39.8-39.7 39.8-69.2v-16c0.1-29.6-15.9-55.5-39.7-69.3zM912 702.5c0 12-6.2 19.9-9.9 23.6-3.7 3.7-11.7 9.9-23.6 9.9h-781c-11.9 0-19.9-6.2-23.6-9.9-3.7-3.7-9.9-11.7-9.9-23.6v-381c0-11.9 6.2-19.9 9.9-23.6 3.7-3.7 11.7-9.9 23.6-9.9h780.9c11.9 0 19.9 6.2 23.6 9.9 3.7 3.7 9.9 11.7 9.9 23.6v381z"
                            p-id="4287"
                            fill="currentColor"
                        ></path>
                        <path
                            d="M736 344v336c0 8.8-7.2 16-16 16H112c-8.8 0-16-7.2-16-16V344c0-8.8 7.2-16 16-16h608c8.8 0 16 7.2 16 16z"
                            p-id="4288"
                            fill="currentColor"
                        ></path>
                    </svg>
                </div>
            </div>
            <div class="card-int">
                <div
                    class="page_button"
                    style="background-color: none; display: none"
                    id="page_button"
                >
                    <div
                        style="
                            width: 45px;
                            display: flex;
                            justify-content: center;
                            height: 20px;
                        "
                        onclick="gotopage(1)"
                    >
                        <svg viewBox="0 0 1024 1024" width="20" height="20">
                            <path
                                d="M810.666667 213.333333a42.666667 42.666667 0 0 1 42.368 37.674667L853.333333 256v274.304c0 79.274667-50.944 147.498667-120.490666 152.106667L725.333333 682.666667H273.706667l97.792 97.834666a42.666667 42.666667 0 0 1-56.32 63.872l-4.010667-3.541333-170.666667-170.666667a42.666667 42.666667 0 0 1 0-60.330666l170.666667-170.666667a42.666667 42.666667 0 0 1 63.872 56.32l-3.541333 4.010667L273.706667 597.333333H725.333333c19.584 0 39.936-24.618667 42.410667-59.861333l0.256-7.168V256a42.666667 42.666667 0 0 1 42.666667-42.666667z"
                                fill="#000000"
                                p-id="13502"
                            ></path>
                        </svg>
                    </div>
                    <div
                        style="
                            width: 45px;
                            display: flex;
                            justify-content: center;
                        "
                        onclick="gotopage(0)"
                    >
                        <svg
                            t="1736242335450"
                            class="icon"
                            viewBox="0 0 1024 1024"
                            version="1.1"
                            xmlns="http://www.w3.org/2000/svg"
                            p-id="8709"
                            width="20"
                            height="20"
                        >
                            <path
                                d="M762.3 565.3c0-19 15.7-34.1 34.7-34.1 19 0 34.2 15.1 34.2 34.1v336.3c0 19-15.2 34.4-34.2 34.4H229.6c-19.1 0-34.7-15.4-34.7-34.4V565.3c0-19 15.7-34.1 34.7-34.1 18.6 0 34.2 15.1 34.2 34.1v301.9h498.5V565.3z m-638.2 9.3l388.8-387.8 389.3 387.8c13.2 13.2 35.2 13.2 48.4 0 13.4-13.2 13.4-35.1 0-48.3L538 114.1l-0.7-0.5c-13.4-13.2-35.2-13.2-48.6 0l-413 412.6c-13.6 13.2-13.6 35.1 0 48.3 13.2 13.2 35.2 13.2 48.4 0.1z"
                                fill="#231815"
                                p-id="8710"
                            ></path>
                        </svg>
                    </div>
                    <div
                        style="
                            width: 45px;
                            display: flex;
                            justify-content: center;
                        "
                        onclick="gotopage(-1)"
                    >
                        <svg
                            t="1736242697753"
                            class="icon"
                            viewBox="0 0 1024 1024"
                            version="1.1"
                            xmlns="http://www.w3.org/2000/svg"
                            p-id="9742"
                            width="20"
                            height="20"
                        >
                            <path
                                d="M622.650611 284.901749 447.745069 284.901749 447.745069 142.823869 63.980685 334.705038l383.76336 191.882192L447.744046 384.834762l189.391465 0c149.914358 0 224.855164 62.789045 224.855164 188.368158 0 129.928165-77.435627 194.876386-232.338602 194.876386L187.952184 768.079306l0 99.93199L634.146433 868.011296c211.184817 0 316.777737-95.104031 316.777737-285.311071C950.924169 384.178823 841.510224 284.901749 622.650611 284.901749z"
                                fill="#272636"
                                p-id="9743"
                            ></path>
                        </svg>
                    </div>
                </div>
                <div id="Home_page" style="display: none">
                    <div class="dibu">
                        <svg
                            viewBox="0 0 1024 1024"
                            style="width: 4.1rem; height: 4.1rem"
                        >
                            <path
                                d="M510.798639 124.660184c-213.447347 0-386.480238 173.029822-386.480238 386.480238 0 213.446323 173.029822 386.475122 386.480238 386.475122 213.446323 0 386.475122-173.029822 386.475122-386.475122C897.274784 297.690006 724.244962 124.660184 510.798639 124.660184L510.798639 124.660184 510.798639 124.660184zM510.798639 864.019379c-194.883549 0-352.884073-158.001547-352.884073-352.879979 0-194.883549 158.000524-352.884073 352.884073-352.884073 194.878432 0 352.883049 158.000524 352.883049 352.884073C863.678618 706.017832 705.677071 864.019379 510.798639 864.019379L510.798639 864.019379 510.798639 864.019379zM588.978209 546.374902c-17.681708 0-31.070646 15.915481-47.113017 15.915481-15.910365 0-85.756129-68.836785-85.756129-85.761246 0-16.920368 15.914458-25.258267 15.914458-42.813085 0-12.632715-47.107901-89.925079-66.432015-89.925079-19.328207 0-66.436108 34.479279-66.436108 66.433038 0 92.455715 170.506349 269.653463 277.230022 269.653463 29.427216 0 66.437132-31.070646 66.437132-66.437132C683.071214 600.178295 606.532003 546.374902 588.978209 546.374902"
                                fill="#09B245"
                                p-id="6003"
                            ></path>
                        </svg>
                        <svg
                            viewBox="0 0 1066 1024"
                            style="width: 3.3rem; height: 3.3rem"
                        >
                            <path
                                d="M548.48 0c282.752 0 512 229.248 512 512s-229.248 512-512 512c-282.794667 0-512-229.248-512-512s229.205333-512 512-512z m0 42.666667c-259.242667 0-469.333333 210.133333-469.333333 469.333333s210.090667 469.333333 469.333333 469.333333c259.2 0 469.333333-210.133333 469.333333-469.333333s-210.133333-469.333333-469.333333-469.333333z m0 173.952c168.234667 0 304.597333 118.186667 304.597333 263.936 0 145.792-136.362667 263.978667-304.64 263.978666a348.757333 348.757333 0 0 1-73.130666-7.68c-36.010667 22.357333-109.866667 70.528-109.866667 70.528s-0.341333-76.672 0-115.797333c-73.813333-48.128-121.6-124.757333-121.6-211.029333 0-145.749333 136.362667-263.936 304.64-263.936z m-129.706667 223.658666a40.448 40.448 0 0 0-40.533333 40.32 40.448 40.448 0 0 0 40.533333 40.32c22.4 0 40.533333-18.005333 40.533334-40.32a40.448 40.448 0 0 0-40.533334-40.32z m135.850667 0a40.448 40.448 0 0 0-40.576 40.32 40.448 40.448 0 0 0 40.533333 40.32 40.448 40.448 0 0 0 40.618667-40.32 40.490667 40.490667 0 0 0-40.576-40.32z m135.850667 0a40.490667 40.490667 0 0 0-40.576 40.32 40.448 40.448 0 0 0 40.576 40.32 40.448 40.448 0 0 0 40.533333-40.32 40.448 40.448 0 0 0-40.533333-40.32z"
                                fill="#2397FF"
                                p-id="9807"
                            ></path>
                        </svg>
                        <svg
                            viewBox="0 0 1024 1024"
                            style="width: 4rem; height: 4rem"
                        >
                            <path
                                d="M441.05 164.53c49.52-9.62 101.09-8.57 150.18 3.06 43.01 10.18 84.04 28.57 120.29 53.84 65.19 45.14 114.56 112.69 137.32 188.68 20.42 67.17 20.07 140.33-0.41 207.44l-0.13 0.46c-23.01-53.51-74.79-93.34-132.27-102.5l-0.01-0.11c0.47-40.52-11.14-81.12-33.35-115.06-22.75-35.1-56.37-63.06-95.1-78.89-39.94-16.49-85.1-19.84-127.09-9.72-39.19 9.32-75.35 30.59-102.8 60.04-28.81 30.73-47.9 70.45-53.65 112.2-6.29 44.14 2.08 90.27 23.8 129.23 19.43 35.16 49.34 64.4 84.89 83.08 30.24 16.01 64.53 24.1 98.72 23.74h0.11c7.41 46.72 35.01 89.65 73.93 116.41 9 6.11 18.38 11.95 28.55 15.85l-0.56 0.16c-69.43 21.22-145.37 20.78-214.4-1.82-75.89-24.48-142.72-75.63-186.49-142.25-23.43-35.39-40.37-75.04-49.76-116.43-11.55-50.94-11.75-104.42-0.53-155.44 14.59-67.14 49.51-129.62 98.75-177.51 49.09-48.12 112.46-81.52 180.01-94.46z"
                                fill="#5C5CEF"
                                p-id="22508"
                            ></path>
                            <path
                                d="M596.41 537.54c35.61-21.21 78.78-28.95 119.61-22.14l0.01 0.11c-0.55 37.38-11.1 74.74-31.06 106.43-16.48 26.73-39.2 49.58-65.79 66.26-31.95 20.42-69.77 31.29-107.63 31.82h-0.11c-5.28-31.73-1.94-64.9 9.96-94.81 14.36-36.47 41.23-67.8 75.01-87.67zM848.3 618.01l0.13-0.46c12.06 27.01 17.34 56.99 15.05 86.49-3.04 42.37-22.11 83.28-52.48 112.96-17.34 17.04-38.17 30.6-60.92 39.23-43.64 17.04-93.93 15.35-136.61-3.79l0.56-0.16c37.37-11.79 72.97-29.37 104.52-52.68 11.87-9.03 23.82-18.11 34.23-28.85 2.98-3 6.62-5.3 9.3-8.61 4.52-5.81 10.34-10.43 14.84-16.26 32.42-37 56.69-80.95 71.38-127.87z"
                                fill="#19FFDC"
                                p-id="22509"
                            ></path>
                            <path
                                d="M716.03 515.51c57.48 9.16 109.26 48.99 132.27 102.5-14.69 46.92-38.96 90.87-71.38 127.87-4.5 5.83-10.32 10.45-14.84 16.26-2.68 3.31-6.32 5.61-9.3 8.61-10.41 10.74-22.36 19.82-34.23 28.85-31.55 23.31-67.15 40.89-104.52 52.68-10.17-3.9-19.55-9.74-28.55-15.85-38.92-26.76-66.52-69.69-73.93-116.41 37.86-0.53 75.68-11.4 107.63-31.82 26.59-16.68 49.31-39.53 65.79-66.26 19.96-31.69 30.51-69.05 31.06-106.43z"
                                fill="#09EFDA"
                                p-id="22510"
                            ></path>
                        </svg>
                        <svg
                            viewBox="0 0 1024 1024"
                            style="width: 3.7rem; height: 3.7rem"
                        >
                            <path
                                d="M517.116019 967.737602c-120.532167 0-233.850026-46.937009-319.079152-132.165112C112.80774 750.341317 65.870732 637.025505 65.870732 516.492314c0-120.532167 46.938032-233.850026 132.166135-319.079152C283.26497 112.184035 396.583852 65.246003 517.116019 65.246003c120.53319 0 233.850026 46.938032 319.079152 132.166135s132.166135 198.546985 132.166135 319.079152c0 120.53319-46.937009 233.849002-132.166135 319.079152C750.966045 920.79957 637.64921 967.737602 517.116019 967.737602zM517.116019 108.790752c-108.901269 0-211.284077 42.407855-288.287869 119.41267S109.41548 407.591045 109.41548 516.492314s42.407855 211.283054 119.41267 288.286846c77.003791 77.005838 179.3866 119.413694 288.287869 119.413694s211.284077-42.407855 288.287869-119.413694c77.005838-77.003791 119.41267-179.385577 119.41267-288.286846s-42.406832-211.284077-119.41267-288.288892C728.400097 151.198607 626.017288 108.790752 517.116019 108.790752z"
                                fill="#2c2c2c"
                                p-id="39954"
                            ></path>
                            <path
                                d="M693.052031 355.056552l-58.175981 0c0-32.129768-26.049283-58.177004-58.179051-58.177004L460.345038 296.879548c-32.127721 0-58.177004 26.047236-58.177004 58.177004l-58.179051 0c-32.127721 0-58.175981 26.046213-58.175981 58.173934l0 232.69983c0 32.127721 26.048259 58.172911 58.175981 58.172911l349.063047 0c32.129768 0 58.178027-26.045189 58.178027-58.172911l0-232.69983c0-32.127721-26.047236-58.177004-58.178027-58.177004L693.052031 355.056552zM519.453251 614.775758c-49.109488 0-88.929402-39.814798-88.929402-88.922239 0-49.110511 39.819914-88.927355 88.929402-88.927355 49.111534 0 88.930425 39.816844 88.930425 88.927355C608.383676 574.959937 568.564785 614.775758 519.453251 614.775758L519.453251 614.775758zM519.453251 614.775758"
                                fill="#2c2c2c"
                                p-id="39955"
                            ></path>
                        </svg>
                    </div>
                    <div class="zhong">
                        <div
                            style="
                                display: flex;
                                align-items: center;
                                gap: 10px;
                            "
                        >
                            <svg
                                viewBox="0 0 1024 1024"
                                style="width: 3rem; height: 3rem"
                            >
                                <path
                                    d="M509.014999 512.046737m-262.543634 0a262.543634 262.543634 0 1 0 525.087268 0 262.543634 262.543634 0 1 0-525.087268 0Z"
                                    fill="#FFD54F"
                                    p-id="51646"
                                ></path>
                                <path
                                    d="M510.601314 0.11053c0 1.705715 67.222223 48.391131 67.222223 91.886861a62.224479 62.224479 0 0 1-67.222223 65.618851 62.224479 62.224479 0 0 1-67.222224-65.635908c0-43.495729 67.222223-93.575518 67.222224-91.869804z"
                                    fill="#FFD54F"
                                    p-id="51647"
                                ></path>
                                <path
                                    d="M869.21081 155.364698c-1.228115 1.194 11.940004 81.9596-19.342807 112.184868a62.224479 62.224479 0 0 1-93.933718-2.695029 62.224479 62.224479 0 0 1 0.460543-93.950776c31.282811-30.225268 114.044097-16.716006 112.815982-15.539063z"
                                    fill="#FFD54F"
                                    p-id="51648"
                                ></path>
                                <path
                                    d="M1022.571634 513.411308c-1.705715-0.034114-49.53396 66.40348-93.029689 65.670023a62.241536 62.241536 0 0 1-64.527194-68.347995 62.241536 62.241536 0 0 1 66.778738-66.113509c43.495729 0.750515 92.483861 68.825595 90.778145 68.791481z"
                                    fill="#FFD54F"
                                    p-id="51649"
                                ></path>
                                <path
                                    d="M869.176695 868.660546c-1.228115-1.176943-81.499057 14.754434-112.781867-15.453777a62.224479 62.224479 0 0 1-0.545829-93.984889 62.224479 62.224479 0 0 1 93.899604-2.763259c31.299868 30.225268 20.656207 113.395925 19.44515 112.218982z"
                                    fill="#FFD54F"
                                    p-id="51650"
                                ></path>
                                <path
                                    d="M510.601314 1023.948829c0-1.705715 67.222223-48.391131 67.222223-91.886861a62.224479 62.224479 0 0 0-67.222223-65.584737 62.224479 62.224479 0 0 0-67.222224 65.584737c0 43.495729 67.222223 93.558461 67.222224 91.886861z"
                                    fill="#FFD54F"
                                    p-id="51651"
                                ></path>
                                <path
                                    d="M154.891533 155.330584c1.228115 1.194-11.940004 81.976657 19.342807 112.201925a62.224479 62.224479 0 0 0 93.916661-2.729144 62.224479 62.224479 0 0 0-0.4776-93.933718c-31.299868-30.259382-113.975868-16.698949-112.781868-15.522006z"
                                    fill="#FFD54F"
                                    p-id="51652"
                                ></path>
                                <path
                                    d="M1.445423 513.34308c1.705715-0.034114 49.53396 66.40348 93.029689 65.670023a62.241536 62.241536 0 0 0 64.49308-68.347995 62.241536 62.241536 0 0 0-66.778738-66.113509c-43.529844 0.750515-92.415632 68.825595-90.744031 68.791481z"
                                    fill="#FFD54F"
                                    p-id="51653"
                                ></path>
                                <path
                                    d="M154.942705 868.660546c1.228115-1.176943 81.516114 14.720319 112.781867-15.522005a62.224479 62.224479 0 0 0 0.477601-93.933719 62.224479 62.224479 0 0 0-93.916662-2.729143c-31.299868 30.259382-20.536807 113.361811-19.342806 112.201924z"
                                    fill="#FFD54F"
                                    p-id="51654"
                                ></path>
                            </svg>
                            <span>22°</span>
                        </div>
                        <div
                            style="
                                display: flex;
                                flex-direction: column;
                                justify-self: end;
                                align-items: end;
                                font-size: inherit;
                                gap: 7px;
                            "
                        >
                            <span>日本市</span> <span id="day">1月4日</span>
                        </div>
                    </div>
                    <div class="app">
                        <div
                            style="
                                display: flex;
                                flex-direction: column;
                                align-items: center;
                            "
                            class="app-svg-div"
                        >
                            <svg viewBox="0 0 1024 1024" width="64" height="64">
                                <path
                                    d="M763.776 968.576H261.504C147.456 968.576 55.04 876.16 55.04 762.112V259.84c0-114.048 92.416-206.464 206.464-206.464h502.272C877.824 53.376 970.24 145.792 970.24 259.84v502.272c0 114.048-92.416 206.464-206.464 206.464z"
                                    fill="#009CF5"
                                    p-id="52731"
                                ></path>
                                <path
                                    d="M529.792 586.496h-100.48l75.648-130.56 7.68-13.312 51.84-89.088 9.984-17.408 21.504-36.864c9.472-16.128 9.728-36.864-1.024-52.096-9.216-13.056-22.4-18.304-35.456-18.304-15.36 0-30.336 7.936-38.784 22.272l-7.68 13.568-7.936-13.568c-8.448-14.336-23.552-22.272-38.784-22.272-7.68 0-15.36 1.792-22.528 5.888-21.248 12.288-28.544 39.808-16.128 61.056l33.408 57.728-135.168 233.216H238.08c-26.88 0.256-48.384 24.064-44.16 52.096 3.328 22.016 23.936 37.376 46.208 37.376h33.92l103.424-0.256H583.936c3.84 0 7.68-1.664 9.984-4.736 11.776-15.744 20.48-40.192-8.32-65.408-15.232-13.44-35.584-19.328-55.808-19.328z"
                                    fill="#FFFFFF"
                                    p-id="52732"
                                ></path>
                                <path
                                    d="M785.28 586.24h-86.016l-115.072-198.528c-2.048-3.456-6.656-4.608-9.856-2.304-16.128 11.648-25.6 27.904-30.464 45.824-8.192 30.208-1.408 62.592 14.208 89.728l24.704 42.88 13.056 22.784 51.84 89.344 5.376 8.96 49.792 86.016c8.448 14.336 23.296 22.272 38.528 22.272 7.68 0 15.616-2.048 22.784-6.144 21.248-12.288 28.544-39.552 16.128-61.056l-29.056-50.304h36.224c26.88 0 48.256-24.32 43.904-52.352-3.584-21.888-23.936-37.12-46.08-37.12zM319.616 687.616c-15.744-6.4-30.592-5.632-42.496-2.304-6.528 1.792-11.904 6.272-15.232 12.032l-16.64 28.416c-12.544 21.504-5.12 48.768 16.128 61.056 7.168 4.096 15.104 6.144 22.784 6.144 15.36 0 30.08-7.936 38.272-22.272l18.944-32.64c4.608-8.064 5.504-17.792 2.048-26.368-3.84-9.6-11.008-18.816-23.808-24.064z"
                                    fill="#FFFFFF"
                                    p-id="52733"
                                ></path>
                            </svg>
                            <span>Store</span>
                        </div>
                        <div
                            style="
                                display: flex;
                                flex-direction: column;
                                align-items: center;
                            "
                            class="app-svg-div"
                            data-app="twitter"
                        >
                            <svg viewBox="0 0 1024 1024" width="64" height="64">
                                <path
                                    d="M849.92 51.2H174.08c-67.8656 0-122.88 55.0144-122.88 122.88v675.84c0 67.8656 55.0144 122.88 122.88 122.88h675.84c67.8656 0 122.88-55.0144 122.88-122.88V174.08c0-67.8656-55.0144-122.88-122.88-122.88z m-93.65504 336.5888a317.0816 317.0816 0 0 1 0.4352 16.11776c0 165.16096-126.8224 355.53792-358.656 355.53792-71.14752 0-137.4208-20.72064-193.24416-56.05888a248.6272 248.6272 0 0 0 30.04928 1.7664 254.80704 254.80704 0 0 0 156.56448-53.45792c-55.13728-1.08544-101.67808-37.28384-117.71392-86.79424 7.67488 1.37216 15.616 2.29888 23.74656 2.29888a124.6208 124.6208 0 0 0 33.13152-4.50048c-57.61024-11.47904-101.08416-61.94176-101.08416-122.54208v-1.46432c17.02912 9.216 36.48512 14.96064 57.15456 15.59552-33.85856-22.49728-56.064-60.66688-56.064-104.03328 0-22.81472 6.14912-44.43648 17.06496-62.90432a359.2192 359.2192 0 0 0 259.80416 130.62144 125.37344 125.37344 0 0 1-3.29216-28.50816c0-68.97664 56.42752-124.91264 126.05952-124.91264 36.24448 0 68.96128 15.0784 91.88864 39.40352 28.73344-5.5296 55.7312-16.0256 80.09728-30.30528-9.40032 29.12768-29.42464 53.7856-55.48032 69.24288 25.62048-3.1488 49.8944-9.82016 72.47872-19.82464a247.84384 247.84384 0 0 1-62.94016 64.72192z"
                                    fill="#03A9F4"
                                    p-id="54801"
                                ></path>
                            </svg>
                            <span>推特</span>
                        </div>
                        <div
                            style="
                                display: flex;
                                flex-direction: column;
                                align-items: center;
                                position: relative;
                            "
                            data-app="QQ"
                            class="app-svg-div"
                        >
                            <svg viewBox="0 0 1024 1024" width="64" height="64">
                                <path
                                    d="M887.85832 64.549132 136.14168 64.549132c-39.540552 0-71.591525 32.051997-71.591525 71.590502l0 751.718687c0 39.538505 32.051997 71.591525 71.591525 71.591525l751.71664 0c39.538505 0 71.592548-32.05302 71.592548-71.591525L959.450868 136.139633C959.449845 96.601128 927.396825 64.549132 887.85832 64.549132zM862.687034 644.674719l0 5.110391 0 4.786003-0.860601 5.754051-1.236154 9.869788-1.720178 8.9263-2.636037 8.067746-0.967024 3.307326-1.828648 3.925403-1.560542 2.77009-2.043542 3.413749-1.829671 2.125407-2.311649 2.769067-2.043542 2.204202-2.204202 1.936095-2.636037 1.157359-2.367931 1.155313-1.934049 0.644683-1.694595 0-1.264806 0-1.908466-0.644683-3.631714-1.775436-1.664919-1.182942-1.722224-1.290389-1.910513-1.694595-1.908466-1.908466-3.173273-3.496637-3.765767-5.000897-2.957355-5.109368-2.957355-4.14132-2.877537-4.787026-4.060479-8.496511-4.570085-8.846482-0.537236-0.297782-0.754177 0-1.88186 1.37123-1.075495 2.339278-1.774413 2.851954-3.120061 8.631588-4.679579 12.235672-6.02318 14.653745-4.516874 7.341199-4.76042 7.635911-5.621021 8.606005-5.969968 8.443299-3.064802 3.818979-3.710508 4.142343-8.525164 8.389064 0.754177 0.75213 1.154289 1.182942 4.249791 2.52859 17.748223 8.497535 7.745405 4.356214 7.366781 4.247744 7.313569 5.324262 6.508227 5.539156 3.174296 2.446725 2.366907 2.877537 2.418073 3.279696 2.044566 3.63069 1.077541 2.984984 1.342578 3.603061 0.539282 3.065825 0.64366 3.629667-0.64366 2.447748 0 2.419096-0.539282 2.581802-1.342578 2.312672-0.539282 1.827625-1.182942 2.205225-3.226484 4.383844-2.956332 3.523243-2.312672 2.63399-1.936095 1.936095-4.89345 3.603061-5.54018 3.092431-5.915733 2.984984-6.293333 2.849908-7.098675 2.743484-3.764744 1.181919-3.38919 0.969071-8.175193 1.908466-8.498558 1.801019-8.496511 1.829671-9.250688 1.479701-9.573029 0.402159-9.78997 1.182942-9.680477 0-10.218736 0-10.487865 0-10.970866-0.644683-10.219759-0.940418-10.970866-1.479701-10.917654-1.183965-11.509125-1.612731-11.134595-2.743484L592.539314 853.880461l-10.81123-3.065825-11.078313-3.926426-10.862395-3.307326-5.702885-1.909489-5.109368-1.828648-3.225461-1.237177-3.174296-0.644683-4.142343 0-4.89345 0-10.431583-0.75213-5.298679-0.538259-6.80294-0.751107-4.357238 3.924379-5.969968 3.738138-8.066723 3.952009-8.928347 4.894474-5.431709 2.63399-5.647627 2.125407-12.531408 5.109368-6.80294 1.693572-7.125281 1.936095-9.895371 1.882883-6.185886 0.537236-6.562463 0.537236-6.830569 0.754177-7.959276 0.322341-7.637957 0-7.959276 0-16.914228 0-18.3663-0.322341-17.801435-1.828648-9.035794-1.238201-8.712429-1.290389-8.497535-1.291412-8.497535-1.693572-7.879458-2.555196-7.878434-1.801019-7.099698-2.877537-6.722098-2.63399-6.239098-3.012613-5.431709-3.28072-5.432733-3.926426-1.828648-1.935072-2.420119-2.312672-1.829671-2.042519-1.666966-2.312672-1.50733-2.365884-1.182942-2.312672-1.694595-5.001921-0.618077-2.555196-0.754177-2.876514 0-2.636037 0.754177-2.983961 0-2.986007 0.618077-2.983961 0-1.802042 0-4.140297 0.295735-3.201925 1.39886-3.629667 1.182942-3.603061 2.153036-4.355191 1.558495-1.694595 1.291412-1.908466 3.387144-4.14132 2.689249-2.152013 2.52859-1.478677 2.341325-1.908466 3.736091-1.183965 2.958378-1.77646 3.710508-1.935072 4.248767-1.264806 4.247744-1.290389 4.894474-1.048889 4.678556-0.645706 5.541203-0.751107 5.968945-0.431835 1.586125-0.536212 0.322341 0 0.754177-0.644683 0-0.699941-1.076518-1.506307-3.199878-1.505283-7.958252-6.883781-5.324262-4.248767-6.185886-5.431709-6.239098-6.05081-6.508227-7.770987-7.421017-8.712429-2.796696-4.679579-3.711532-4.894474-3.173273-5.64558-2.850931-6.157233-3.873214-5.834892-2.52859-6.724145-2.984984-6.66684-2.984984-7.476275-2.205225-7.098675-2.043542-8.819876-0.644683-0.323365-0.6191 0-0.322341-0.645706-0.754177 0-1.263783 0.645706-0.645706 0.323365-0.858554 1.478677-0.323365 1.802042-0.644683 1.613754-1.12973 2.63399-3.657296 6.507204-1.882883 3.926426-2.984984 3.388167-3.199878 4.140297-3.496637 4.571109-3.710508 4.061502-4.357238 3.925403-4.059456 3.710508-4.437056 2.877537-4.894474 3.091408-4.678556 1.802042-5.539156 1.39886-5.431709 0.509606-0.537236 0-0.753153 0-1.237177-0.509606-0.969071-2.152013-1.612731-1.048889-2.097778-5.108345-1.290389-2.77009-1.39886-3.925403-1.156336-4.14132-0.6191-4.033873-1.721201-9.249665-0.644683-5.433756 0-5.538133 0-12.31549 0.644683-13.283538 1.076518-6.831592 1.263783-6.990205 1.156336-7.556093 2.043542-7.018857 2.312672-8.094352 2.366907-7.852852 3.174296-8.093329 2.984984-7.745405 4.113691-7.877411 3.873214-8.497535 4.678556-7.985882 5.51255-8.606005 5.621021-7.745405 5.862521-8.603959 4.894474-5.968945 6.265704-6.91141 6.589069-6.910387 3.065825-3.279696 3.736091-3.738138 5.406127-4.705162 5.54018-4.759397 9.03477-8.094352 6.830569-4.975315 2.420119-1.802042-1.344624-4.140297-1.075495-5.431709-0.753153-2.984984 0-3.738138 0-4.463662 0-4.03285 1.290389-4.787026 1.345648-5.109368 1.720178-5.297656 2.341325-5.942339 3.091408-6.184863 4.356214-6.184863 0-4.330632 0.429789-4.060479 0.645706-5.51255 1.88186-6.15621 1.721201-6.696516 1.37123-3.093455 1.586125-2.848884 2.043542-3.200902 2.205225-2.339278 0-4.356214 0-4.894474 0-6.076392 1.290389-7.852852 1.290389-9.143241 2.312672-10.970866 3.173273-11.348466 2.366907-6.290263 2.339278-6.803963 2.555196-6.372128 3.065825-6.80294 3.119037-7.448646 3.604084-6.990205 4.03285-7.476275 5.109368-7.42204 2.340301-4.247744 2.52859-3.523243 5.458315-7.878434 5.592368-7.851828 6.399757-8.067746 6.830569-7.906064 7.42204-7.743358 7.744381-7.959276 9.358135-8.604982 5.969968-5.216815 7.232728-5.646604 7.342222-5.001921 7.959276-4.786003 7.637957-4.248767 8.604982-3.495614 9.143241-4.356214 9.087982-2.984984 9.090029-3.092431 9.787924-3.065825 9.788947-2.339278 10.326183-1.909489 10.432607-1.721201 10.272971-1.370207 10.32516-1.39886 10.972912-0.6191 10.431583 0 10.812253 0 11.18576 0 10.812253 1.37123 10.862395 1.291412 11.078313 1.155313 10.273994 2.474354 10.863419 2.311649 10.19213 2.636037 11.160177 3.01159 10.219759 3.602038 9.7869 4.14132 10.434653 4.356214 9.5454 4.786003 9.250688 5.324262 9.0624 5.862521 7.851828 5.405103 3.604084 3.092431 3.820002 2.204202 7.259334 6.185886 6.132674 5.968945 6.076392 6.157233 5.969968 6.801916 4.894474 6.589069 5.808286 6.80294 4.088108 7.313569 4.113691 6.508227 4.383844 7.554046 3.603061 6.589069 6.131651 13.929244 3.010567 7.207146 2.341325 6.723122 2.339278 7.205099 2.097778 6.831592 1.506307 5.833869 1.88186 6.91141 3.334955 12.316513 2.124384 10.754948 1.370207 10.43363 1.183965 8.389064 1.883907 12.746302 0.429789 2.043542 1.505283 2.311649 4.034896 6.614651 2.579755 4.437056 2.313695 4.705162 2.957355 4.975315 2.580778 5.969968 1.666966 6.157233 1.828648 6.695492 1.39886 6.910387 0.645706 3.388167 0.537236 4.14132 0 3.629667-0.537236 3.63069 0 4.464685-1.076518 4.355191-1.934049 8.391111-2.206248 4.247744-1.611707 4.786003 0 1.182942 0.75213 1.480724 2.205225 3.521197 9.575076 14.144138 7.581676 10.595312 3.604084 7.15291 4.89345 7.743358 4.247744 8.498558 4.89652 9.141194 4.892427 10.219759 5.513574 11.588943 3.090385 7.126304 2.850931 6.883781 2.476401 7.367805 2.420119 6.560416 1.828648 6.939039 1.880837 6.480598 2.365884 12.664438 1.882883 12.961196 1.289366 11.45489L862.688057 644.674719z"
                                    fill="#1296db"
                                    p-id="63263"
                                ></path>
                            </svg>
                            <span>QQ</span>
                            <div
                                class="new_tips"
                                style="
                                    position: absolute;
                                    right: -5px;
                                    top: -5px;
                                    background-color: red;
                                    color: #fff;
                                    width: 25px;
                                    height: 25px;
                                    border-radius: 50%;
                                    display: none;
                                    justify-content: center;
                                    align-items: center;
                                    font-size: 15px;
                                "
                            >
                                1
                            </div>
                        </div>
                        <div
                            style="
                                display: flex;
                                flex-direction: column;
                                align-items: center;
                            "
                            class="app-svg-div"
                        >
                            <svg viewBox="0 0 1024 1024" width="57" height="57">
                                <path
                                    d="M860.16 0C950.272 0 1024 73.889684 1024 164.163368v531.509895s-32.768-4.122947-180.224-53.355789c-40.96-14.362947-96.256-34.896842-157.696-57.478737 36.864-63.595789 65.536-137.485474 86.016-215.444211h-202.752v-71.841684h247.808V256.512h-247.808V135.437474h-100.352c-18.432 0-18.432 18.458947-18.432 18.458947v104.663579H200.704v41.040842h249.856v69.793684H243.712v41.013895H645.12c-14.336 51.307789-34.816 98.519579-57.344 141.608421-129.024-43.115789-268.288-77.985684-356.352-55.403789-55.296 14.362947-92.16 38.992842-112.64 63.595789-96.256 116.978526-26.624 295.504842 176.128 295.504842 120.832 0 237.568-67.718737 327.68-178.526316C757.76 742.858105 1024 853.692632 1024 853.692632v6.144C1024 950.110316 950.272 1024 860.16 1024H163.84C73.728 1024 0 950.137263 0 859.836632V164.163368C0 73.889684 73.728 0 163.84 0h696.32zM268.126316 553.121684c93.049263-10.374737 180.062316 26.974316 283.270737 78.874948-74.886737 95.501474-165.941895 155.701895-256.970106 155.701894-157.830737 0-204.368842-126.652632-125.466947-197.200842 26.300632-22.851368 72.838737-35.301053 99.166316-37.376z"
                                    fill="#00A0EA"
                                    p-id="64921"
                                ></path>
                            </svg>
                            <span>支付宝</span>
                        </div>
                    </div>
                </div>
                <div id="App_Page" style="height: 100%">
                    <div class="twitter" id="App_twitter" style="display: none">
                        <div class="mimictwitter">
                            <div style="margin-right: 8px; margin-top: 10px">
                                <div
                                    style="
                                        display: grid;
                                        grid-template-columns: 1fr 1fr 1fr;
                                        align-items: center;
                                    "
                                >
                                    <div
                                        style="
                                            border-radius: 50%;
                                            width: 32px;
                                            height: 32px;
                                            margin-left: 7px;
                                        "
                                        class="twitter-close-btn user_avatar"
                                    ></div>
                                    <svg
                                        viewBox="0 0 24 24"
                                        style="
                                            width: 24.73px;
                                            height: 54px;
                                            justify-self: center;
                                        "
                                    >
                                        <g>
                                            <path
                                                d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"
                                            ></path>
                                        </g>
                                    </svg>
                                    <svg
                                        style="
                                            margin-left: auto;
                                            width: 24px;
                                            height: 24px;
                                        "
                                        viewBox="0 0 1024 1024"
                                        aria-hidden="true"
                                    >
                                        <g>
                                            <path
                                                d="M596.992 512q0 34.016-24 59.008-12 12-27.488 18.496T512.992 596q-34.016 0-59.008-24.992-4.992-4.992-8.51199999-10.016t-6.49600001-11.008-4.992-12.512-3.48799999-12.992-1.50400001-12.512q0-35.00800001 24.992-59.488t59.488-24.512 59.488 24q7.008 8 12.992 17.504t8.512 20.512T596.96 512z m0 332q0 35.00800001-24 59.008-8 8-17.504 13.504t-20.512 8.512-22.016 3.008q-34.016 0-59.008-24.992-6.016-4.992-10.496-12t-7.488-14.496-4.992-16-2.016-16.512q0-35.00800001 24.992-59.488t59.488-24.51199999 59.488 24.99199999q11.008 11.008 17.504 27.008t6.496 32z m0-664.992q0 35.00800001-24 59.008-8 8-17.504 13.504t-20.512 8.512-22.016 3.00800001q-34.016 0-59.008-24.51200001T428.96 179.04000001t24.992-59.00800001q12-12 27.488-18.496t31.488-6.496q35.00800001 0 60 24.992 11.008 11.008 17.504 27.008t6.496 32z"
                                                fill="#000000"
                                                p-id="1477"
                                            ></path>
                                        </g>
                                    </svg>
                                </div>
                                <div style="margin-top: 13px"></div>
                                <div
                                    style="
                                        display: grid;
                                        grid-template-columns: 1fr 1fr;
                                        align-items: center;
                                        justify-items: center;
                                    "
                                >
                                    <span style="color: #5f6f7b">为你推荐</span>
                                    <span><strong>正在关注</strong></span>
                                </div>
                                <div
                                    style="
                                        margin-top: 8px;
                                        display: grid;
                                        grid-template-columns: 1fr 1fr;
                                        align-items: center;
                                        justify-items: center;
                                    "
                                >
                                    <div></div>
                                    <div
                                        style="
                                            background-color: #1d9bf0;
                                            width: 100%;
                                            height: 4px;
                                            border-radius: 50px;
                                        "
                                    ></div>
                                </div>
                                <div
                                    style="
                                        width: 100%;
                                        height: 1px;
                                        background-color: #f0f4f5;
                                        margin-top: 2px;
                                    "
                                ></div>
                            </div>
                            <div class="twitter-content"><hr /></div>
                        </div>
                    </div>
                    <div
                        class="QQ"
                        id="App_QQ"
                        style="
                            background-color: #eff3ff;
                            width: 100%;
                            height: 100%;
                            box-sizing: border-box;
                            position: relative;
                        "
                    >
                                                 <div id="QQ_home_page" style="display: flex; flex-direction: column; height: calc(100% - 20px);">
                            <div style="width: 100%; height: 30px"></div>
                            <div
                                style="
                                    display: flex;
                                    align-items: center;
                                    gap: 5px;
                                    width: 100%;
                                    box-sizing: border-box;
                                "
                            >
                                <div
                                    class="user_avatar"
                                    style="
                                        width: 35px;
                                        height: 35px;
                                        border-radius: 50%;
                        margin-left: 28px;
                                    "
                                ></div>
                                <div
                                    style="
                                        display: flex;
                                        align-items: start;
                                        justify-content: center;
                                        flex-direction: column;
                                        margin-left: 3px;
                                        gap: 3px;
                                        position: relative;
                                    "
                                >
                                    <span
                                        style="font-size: 15px; cursor: pointer; position: relative;"
                                        id="QQ_home_UserName"
                                        onclick="QQ_ToggleUserMenu()"
                                        ><strong>{{user}}</strong></span
                                    >
                                    <!-- 用户下拉菜单 -->
                                    <div id="QQ_user_menu" style="
                                        position: absolute;
                                        top: 100%;
                                        left: 0;
                                        background: white;
                                        border-radius: 8px;
                                        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                                        z-index: 1000;
                                        min-width: 150px;
                                        display: none;
                                        animation: menuSlideDown 0.2s ease;
                                    ">
                                        <div class="user_menu_item" onclick="QQ_ShowSpiritButton(); QQ_HideUserMenu();" style="
                                            padding: 12px 16px;
                                            cursor: pointer;
                                            border-bottom: 1px solid #f0f0f0;
                                            display: flex;
                                            align-items: center;
                                            gap: 8px;
                                            font-size: 14px;
                                            color: #333;
                                            transition: background-color 0.2s ease;
                                        " onmouseover="this.style.backgroundColor='#f5f5f5'" 
                                           onmouseout="this.style.backgroundColor='transparent'">
                                            🧚‍✨ <span>召唤互动精灵</span>
                                        </div>
                                        <div class="user_menu_item" onclick="QQ_ShowInteractiveStats(); QQ_HideUserMenu();" style="
                                            padding: 12px 16px;
                                            cursor: pointer;
                                            border-bottom: 1px solid #f0f0f0;
                                            display: flex;
                                            align-items: center;
                                            gap: 8px;
                                            font-size: 14px;
                                            color: #333;
                                            transition: background-color 0.2s ease;
                                        " onmouseover="this.style.backgroundColor='#f5f5f5'" 
                                           onmouseout="this.style.backgroundColor='transparent'">
                                            📊 <span>互动统计</span>
                                        </div>
                                        <div class="user_menu_item" onclick="window.QQ_Show_Interactive_Stats(); QQ_HideUserMenu();" style="
                                            padding: 12px 16px;
                                            cursor: pointer;
                                            display: flex;
                                            align-items: center;
                                            gap: 8px;
                                            font-size: 14px;
                                            color: #333;
                                            transition: background-color 0.2s ease;
                                        " onmouseover="this.style.backgroundColor='#f5f5f5'" 
                                           onmouseout="this.style.backgroundColor='transparent'">
                                            🔧 <span>调试信息</span>
                                        </div>
                                    </div>
                                    <div
                                        style="
                                            display: flex;
                                            align-items: center;
                                            height: 10px;
                                        "
                                    >
                                        <svg
                                            viewBox="0 0 1024 1024"
                                            width="13"
                                            height="13"
                                            style="margin-right: 2px"
                                        >
                                            <path
                                                d="M957.539 464.339c-26.14-245.993-246.771-424.08-492.787-397.772C218.735 92.873 40.474 313.62 66.635 559.634 92.774 805.631 313.406 983.717 559.443 957.41c245.997-26.306 424.258-247.075 398.096-493.071z m-298.25-135.757c39.341 0 71.233 31.921 71.233 71.301 0 39.379-31.891 71.3-71.233 71.3-39.338 0-71.229-31.921-71.229-71.3 0-39.38 31.892-71.301 71.229-71.301z m-294.447 0c39.34 0 71.23 31.921 71.23 71.301 0 39.379-31.89 71.3-71.23 71.3s-71.228-31.921-71.228-71.3c0-39.38 31.887-71.301 71.228-71.301z m366.815 304.963c-21.735 96.663-119.97 163.563-219.591 163.563-103.222 0-200.969-68.713-220.487-167.453 0-26.686 20.351-36.26 32.887-36.26h370.156c9.115 0.017 43.978 3.176 37.035 40.15z"
                                                fill="#fbba13"
                                                p-id="5845"
                                            ></path>
                                        </svg>
                                        <span style="font-size: 11px"
                                            >Q我吧</span
                                        >
                                        <svg
                                            viewBox="0 0 1024 1024"
                                            width="10"
                                            height="10"
                                            style="margin-top: 1px"
                                        >
                                            <path
                                                d="M342.528 916.48c19.456 0 38.4-7.168 53.248-21.504l338.944-327.68c14.848-14.336 23.552-34.304 23.552-55.296s-8.192-40.96-23.552-55.296l-338.944-327.68c-30.72-29.696-79.36-28.672-108.544 2.048-29.696 30.72-28.672 79.36 2.048 108.544l281.6 272.384-281.6 272.384c-30.72 29.696-31.232 78.336-2.048 108.544 15.36 15.872 35.328 23.552 55.296 23.552z"
                                                fill="#000000"
                                                p-id="7578"
                                            ></path>
                                        </svg>
                                    </div>
                                </div>
                                <svg
                    id="contacts_add_btn"
                    class="add-button"
                                    viewBox="0 0 1024 1024"
                                    version="1.1"
                                    width="20"
                                    height="20"
                                    style="
                                        margin-left: auto;
                        margin-right: 28px;
                                    "
                                >
                                    <path
                                        d="M512 0a42.666667 42.666667 0 0 1 42.666667 42.666667v426.666666h426.666666a42.666667 42.666667 0 0 1 0 85.333334H554.666667v426.666666a42.666667 42.666667 0 0 1-85.333334 0V554.666667H42.666667a42.666667 42.666667 0 0 1 0-85.333334h426.666666V42.666667a42.666667 42.666667 0 0 1 42.666667-42.666667z"
                                        fill="#191919"
                                        p-id="4261"
                                    ></path>
                                </svg>
                            </div>
                            <div style="width: 100%; height: 10px"></div>
                            <!-- 搜索框放在联络人列表外面 -->
                <div
                                id="floating_search_box"
                    style="
                                    width: calc(100% - 40px);
                        height: 30px;
                                    background-color: rgba(239, 243, 255, 0.9);
                                    margin-left: 20px;
                                    margin-bottom: 5px;
                        border-radius: 5px;
                        display: flex;
                        align-items: center;
                                    gap: 8px;
                                    padding: 0 10px;
                                    z-index: 100;
                                    backdrop-filter: blur(5px);
                                    border: 1px solid rgba(25, 154, 255, 0.2);
                                    transition: all 0.3s ease;
                                    position: sticky;
                                    top: 0;
                    "
                >
                    <svg
                        viewBox="0 0 1024 1024"
                        width="16"
                        height="16"
                                    style="flex-shrink: 0;"
                    >
                        <path
                            d="M446.112323 177.545051c137.567677 0.219798 252.612525 104.59798 266.162424 241.493333 13.562828 136.895354-78.778182 261.818182-213.617777 289.008485-134.852525 27.203232-268.386263-52.156768-308.945455-183.608889s25.018182-272.252121 151.738182-325.779394A267.235556 267.235556 0 0 1 446.112323 177.545051m0-62.060607c-182.794343 0-330.989899 148.195556-330.989899 330.989899s148.195556 330.989899 330.989899 330.989899 330.989899-148.195556 330.989899-330.989899-148.195556-330.989899-330.989899-330.989899z m431.321212 793.341415a30.849293 30.849293 0 0 1-21.94101-9.102223l-157.220202-157.220202c-11.752727-12.179394-11.584646-31.534545 0.37495-43.50707 11.972525-11.972525 31.327677-12.140606 43.494141-0.37495l157.220202 157.220202a31.036768 31.036768 0 0 1 6.723232 33.810101 31.004444 31.004444 0 0 1-28.651313 19.174142z m0 0"
                            fill="#919095"
                        ></path>
                    </svg>
                                <input 
                                    type="text" 
                                    id="contact_search_input"
                                    placeholder="搜索联络人..."
                                    style="
                                        flex: 1;
                                        border: none;
                                        background: transparent;
                                        outline: none;
                                        color: #333;
                                        font-size: 14px;
                                    "
                                >
                                <div id="search_clear_btn" style="
                                    display: none;
                                    cursor: pointer;
                                    width: 16px;
                                    height: 16px;
                                    background-color: #ccc;
                                    border-radius: 50%;
                                    position: relative;
                                    flex-shrink: 0;
                                ">
                                    <div style="
                                        position: absolute;
                                        top: 50%;
                                        left: 50%;
                                        transform: translate(-50%, -50%);
                                        color: white;
                                        font-size: 12px;
                                        line-height: 1;
                                    ">×</div>
                </div>
            </div>
                            <div id="QQ_home_chars">
        </div>
        </div>
                                <div id="QQ_message_list_page" style="display: none; flex-direction: column; height: calc(100% - 20px);">
            <!-- 消息页面：只显示用户头像和联系人列表，不显示搜索框 -->
            <div style="width: 100%; height: 30px"></div>
            <div
                style="
                    display: flex;
                    align-items: center;
                    gap: 5px;
                    width: 100%;
                    box-sizing: border-box;
                "
            >
                <div
                    class="user_avatar"
                    style="
                        width: 35px;
                        height: 35px;
                        border-radius: 50%;
                        margin-left: 28px;
                    "
                ></div>
                <div
                    style="
                        display: flex;
                        align-items: start;
                        justify-content: center;
                        flex-direction: column;
                        margin-left: 3px;
                        gap: 3px;
                    "
                >
                    <span
                        style="font-size: 15px; cursor: pointer;"
                        id="QQ_message_list_UserName"
                        onclick="QQ_ToggleUserMenu()"
                        ><strong>{{user}}</strong></span
                    >
                    <div
                        style="
                            display: flex;
                            align-items: center;
                            height: 10px;
                        "
                    >
                        <svg
                            viewBox="0 0 1024 1024"
                            width="13"
                            height="13"
                            style="margin-right: 2px"
                        >
                            <path
                                d="M957.539 464.339c-26.14-245.993-246.771-424.08-492.787-397.772C218.735 92.873 40.474 313.62 66.635 559.634 92.774 805.631 313.406 983.717 559.443 957.41c245.997-26.306 424.258-247.075 398.096-493.071z m-298.25-135.757c39.341 0 71.233 31.921 71.233 71.301 0 39.379-31.891 71.3-71.233 71.3-39.338 0-71.229-31.921-71.229-71.3 0-39.38 31.892-71.301 71.229-71.301z m-294.447 0c39.34 0 71.23 31.921 71.23 71.301 0 39.379-31.89 71.3-71.23 71.3s-71.228-31.921-71.228-71.3c0-39.38 31.887-71.301 71.228-71.301z m366.815 304.963c-21.735 96.663-119.97 163.563-219.591 163.563-103.222 0-200.969-68.713-220.487-167.453 0-26.686 20.351-36.26 32.887-36.26h370.156c9.115 0.017 43.978 3.176 37.035 40.15z"
                                fill="#fbba13"
                                p-id="5845"
                            ></path>
                        </svg>
                        <span style="font-size: 11px"
                            >Q我吧</span
                        >
                        <svg
                            viewBox="0 0 1024 1024"
                            width="10"
                            height="10"
                            style="margin-top: 1px"
                        >
                            <path
                                d="M342.528 916.48c19.456 0 38.4-7.168 53.248-21.504l338.944-327.68c14.848-14.336 23.552-34.304 23.552-55.296s-8.192-40.96-23.552-55.296l-338.944-327.68c-30.72-29.696-79.36-28.672-108.544 2.048-29.696 30.72-28.672 79.36 2.048 108.544l281.6 272.384-281.6 272.384c-30.72 29.696-31.232 78.336-2.048 108.544 15.36 15.872 35.328 23.552 55.296 23.552z"
                                fill="#000000"
                                p-id="7578"
                            ></path>
                        </svg>
                    </div>
                </div>
                <svg
                    id="messages_add_btn"
                    class="add-button"
                    viewBox="0 0 1024 1024"
                    version="1.1"
                    width="20"
                    height="20"
                    style="
                        margin-left: auto;
                        margin-right: 28px;
                    "
                >
                    <path
                        d="M512 0a42.666667 42.666667 0 0 1 42.666667 42.666667v426.666666h426.666666a42.666667 42.666667 0 0 1 0 85.333334H554.666667v426.666666a42.666667 42.666667 0 0 1-85.333334 0V554.666667H42.666667a42.666667 42.666667 0 0 1 0-85.333334h426.666666V42.666667a42.666667 42.666667 0 0 1 42.666667-42.666667z"
                        fill="#191919"
                        p-id="4261"
                    ></path>
                </svg>
            </div>
            <div style="width: 100%; height: 20px"></div>
            <div id="QQ_message_list_chars">
                <!-- 消息联系人列表，只显示有消息记录的联系人 -->
            </div>
        </div>
        <div
            id="QQ_space_page"
            style="display: none; height: calc(100% - 20px); flex-direction: column;"
        >
                            <div style="width: 100%; height: 35px"></div>
                            <div style="display: flex">
                                <span style="font-size: 16px; margin-left: 28px"
                                    >动态</span
                                >
                                <svg
                                    viewBox="0 0 1024 1024"
                                    width="20"
                                    height="20"
                                    style="margin-left: auto"
                                >
                                    <path
                                        d="M593.420488 922.099512c24.553022 0 44.456585 19.903563 44.456585 44.456586v11.988292c0 24.553022-19.903563 44.456585-44.456585 44.456586h-159.843903c-24.553022 0-44.456585-19.903563-44.456585-44.456586v-11.988292c0-24.553022 19.903563-44.456585 44.456585-44.456586h159.843903zM515.996098 0c24.276293 0 43.957073 19.68078 43.957073 43.957073l0.002997 54.191079C735.392843 121.808047 870.649756 272.137241 870.649756 454.056585V740.277073h102.4c24.553022 0 44.456585 19.903563 44.456585 44.456586v11.988292c0 24.553022-19.903563 44.456585-44.456585 44.456586H870.649756v1.998048H152.35122v-1.998048H52.948293C28.39527 841.178537 8.491707 821.274974 8.491707 796.721951v-11.988292C8.491707 760.180636 28.39527 740.277073 52.948293 740.277073H152.35122V454.056585c0-181.229019 134.231914-331.106654 308.696538-355.632702L461.049756 43.957073c0-24.276293 19.68078-43.957073 43.957073-43.957073h10.989269z m25.620979 197.047571h-60.233178c-126.178779 0-228.706654 101.264109-230.744664 226.958361l-0.029971 3.816273-0.000999 312.454868h521.783446V427.822205c0-127.454533-103.3211-230.774634-230.774634-230.774634z"
                                        fill="#000000"
                                        p-id="3355"
                                    ></path>
                                </svg>
                                <svg
                                    viewBox="0 0 1065 1024"
                                    width="20"
                                    height="20"
                                    style="
                                        margin-right: 28px;
                                        margin-left: 15px;
                                    "
                                >
                                    <path
                                        d="M1002.234305 330.02867V693.97133c0 53.148789-28.346021 101.741967-73.902125 128.063272l-315.349481 182.224419c-46.062284 26.321305-102.248146 26.321305-148.31043 0l-315.349481-182.224419c-46.062284-26.321305-73.902126-75.420662-73.902126-128.063272V330.02867c0-53.148789 28.346021-101.741967 73.902126-128.063272l315.349481-182.224419c46.062284-26.321305 102.248146-26.321305 148.31043 0l315.349481 182.224419c45.556105 26.321305 73.902126 74.914483 73.902125 128.063272z m-76.939199 0c0-25.308947-13.666831-49.099357-35.432526-61.753831l-315.349481-182.224419c-22.271873-12.654474-49.099357-12.654474-71.37123 0l-315.349481 182.224419c-22.271873 12.654474-35.432526 36.444884-35.432526 61.753831V693.97133c0 25.308947 13.666831 49.099357 35.432526 61.753831l315.349481 182.224419c22.271873 12.654474 49.099357 12.654474 71.37123 0l315.349481-182.224419c22.271873-12.654474 35.432526-36.444884 35.432526-61.753831V330.02867zM362.424123 508.709837C362.424123 410.004943 442.400395 329.522491 541.611468 329.522491s179.187346 80.482452 179.187346 179.187346-80.482452 179.187346-179.187346 179.187345-179.187346-79.470094-179.187345-179.187345z m76.939199 0c0 56.692042 46.062284 102.248146 102.248146 102.248146s102.248146-46.062284 102.248146-102.248146-46.062284-102.248146-102.248146-102.248146-102.248146 46.568463-102.248146 102.248146z"
                                        fill="#000000"
                                        p-id="13806"
                                    ></path>
                                </svg>
                            </div>
                            <div
                                style="
                                    width: 100%;
                                    height: 1px;
                                    background-color: #e6e6e6;
                                    margin-bottom: 10px;
                                    margin-top: 10px;
                                "
                            ></div>
                            <div
                                class="space_contents"
                                id="space_contents"
                                style="
                                    overflow-y: auto;
                                    width: 100%;
                                    flex: 1;
                                    height: calc(100vh - 180px);
                                "
                            >
                                <div style="margin-bottom: 80px"></div>
                            </div>
                        </div>
                        <div class="QQ_bottom_nav">
                            <div
                                id="QQ_message_nav"
                                style="
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    flex-direction: column;
                                    gap: 1px;
                                "
                            >
                                <svg
                                    class="icon"
                                    viewBox="0 0 1024 1024"
                                    width="20"
                                    height="20"
                                    style="
                                        transform: scale(1.15);
                                        transform-origin: center;
                                        fill: #000000;
                                    "
                                    id="QQ_message_svg"
                                >
                                    <path
                                        d="M822.016 61.44H196.864A155.88352 155.88352 0 0 0 40.96 216.94976v426.2144a155.88352 155.88352 0 0 0 155.904 155.50976h9.6256a1.97632 1.97632 0 0 1 1.96608 1.9456l0.97792 84.992A72.832 72.832 0 0 0 322.72896 945.152l211.37408-141.09184a31.9744 31.9744 0 0 1 17.80736-5.39648h270.1056A155.88352 155.88352 0 0 0 977.92 643.16416V216.94976A155.88352 155.88352 0 0 0 822.016 61.44z m85.06368 581.72416a85.05344 85.05344 0 0 1-85.06368 84.84864H551.936a102.69184 102.69184 0 0 0-57.21088 17.33632l-211.39456 141.09184a1.9712 1.9712 0 0 1-3.072-1.6128l-0.97792-85.02272A72.97024 72.97024 0 0 0 206.4896 728.0128h-9.6256a85.05344 85.05344 0 0 1-85.06368-84.84864V216.94976A85.05344 85.05344 0 0 1 196.864 132.096h625.152a85.05344 85.05344 0 0 1 85.06368 84.84864v426.2144z"
                                    ></path>
                                    <path
                                        d="M311.08608 381.76768a54.17472 54.17472 0 1 0 54.31296 54.17472 54.24128 54.24128 0 0 0-54.31296-54.17472z m207.80032 0a54.17472 54.17472 0 1 0 54.31296 54.17472 54.24128 54.24128 0 0 0-54.31296-54.17472z m212.52096 0a54.17472 54.17472 0 1 0 54.31296 54.17472 54.24128 54.24128 0 0 0-54.31296-54.17472z"
                                    ></path>
                                </svg>
                                <span>消息</span>
                            </div>
                            <div
                                id="QQ_people_nav"
                                style="
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    flex-direction: column;
                                    gap: 1px;
                                "
                            >
                                <svg
                                    viewBox="0 0 1024 1024"
                                    style="fill: #019aff"
                                    width="20"
                                    height="20"
                                    id="QQ_people_svg"
                                >
                                    <path
                                        d="M620.744191 538.879184c82.736353-40.523949 140.308583-124.785028 140.308583-222.936465 0-137.367601-111.714338-249.080915-249.02668-249.080915-137.367601 0-249.080915 111.713314-249.080915 249.080915 0 98.151437 57.57223 182.412516 140.363841 222.936465C235.330238 586.429153 111.796714 740.736565 111.796714 923.694503c0 18.464537 15.032368 33.443693 33.496905 33.443693 18.464537 0 33.497928-14.979156 33.497928-33.443693 0-183.774537 149.46001-333.343017 333.234547-333.343017 183.77556 0 333.234547 149.568481 333.234547 333.343017 0 18.464537 14.978133 33.443693 33.443693 33.443693 18.519796 0 33.496905-14.979156 33.496905-33.443693C912.20124 740.736565 788.668739 586.429153 620.744191 538.879184zM329.886801 315.942719c0-100.438527 81.70179-182.194552 182.140317-182.194552 100.384291 0 182.086082 81.756025 182.086082 182.194552 0 100.384291-81.702813 182.086082-182.086082 182.086082C411.587568 498.0288 329.886801 416.32701 329.886801 315.942719z"
                                    ></path>
                                </svg>
                                <span>联系人</span>
                            </div>
                            <div
                                id="QQ_moment_nav"
                                style="
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    flex-direction: column;
                                    gap: 1px;
                                    position: relative;
                                "
                            >
                                <svg
                                    viewBox="0 0 1059 1024"
                                    width="20"
                                    height="20"
                                    id="QQ_moment_svg"
                                    style="fill: #000000"
                                >
                                    <path
                                        d="M206.566465 1008.20002c11.278404 7.517627 30.080982 15.035253 45.117545 15.035254 11.281023 0 26.324133-3.75554 37.605156-7.517627l240.646548-127.777391 240.646547 127.777391c11.278404 7.517627 22.558118 7.517627 37.602537 7.517627 15.037872 0 30.075744-3.75554 45.118854-15.035254 22.559427-15.030015 37.598609-45.097903 30.082292-71.402393l-45.124092-278.110282L1037.545084 459.503632c18.799959-18.790793 26.321514-48.85868 18.799959-75.163172-7.516317-26.311038-33.839141-45.103141-60.156726-48.85868L714.181074 290.382568 593.854527 42.338864C582.577432 16.027826 556.254609 0.99912 526.177555 0.99912c-30.080982 0-56.403806 15.028706-67.684829 41.339744l-120.32 248.043704L63.679182 331.723621c-26.316276 3.756849-52.640409 22.548951-60.161965 48.853443-7.516317 26.309729-3.758159 56.376307 18.801269 75.169719l199.285852 199.183713-45.120164 278.106353c-3.758159 30.065269 7.521555 60.133156 30.082291 75.163171zM63.679182 406.886793l274.492235-41.339744 48.878322-7.518936 22.559427-45.097903 116.568389-248.042394 120.318691 248.043703 22.562046 45.097903 48.88225 7.516317 274.485688 41.339744L789.383529 606.074435l-33.845688 33.822117 7.522865 45.103141 45.124092 278.103734-240.651785-127.777391-41.356767-26.311039-45.124093 22.555499-240.646547 131.532931 45.120164-278.103734 7.521555-45.103141-30.082292-33.823427L63.679182 406.888102z"
                                        p-id="37579"
                                    ></path>
                                    <path
                                        d="M526.176246 692.509463c-131.604951 0-176.725115-127.777391-176.725116-131.53424-3.763396-15.035253 3.758159-30.065269 18.796031-33.828665 15.044419-3.75554 30.080982 3.763396 33.845688 18.793411 0 3.762087 33.839141 93.953964 124.084706 93.953965 90.239018 0 124.078159-93.953964 124.078159-93.953965 3.763396-15.030015 18.801269-22.548951 33.845688-18.793411 15.036563 3.763396 22.558118 22.555499 18.79603 33.828665 0 3.756849-45.120164 131.53555-176.721186 131.535549z"
                                        p-id="37580"
                                    ></path>
                                </svg>
                                <span>动态</span>
                                <div
                                    class="new_tips"
                                    style="
                                        position: absolute;
                                        right: -8px;
                                        top: -8px;
                                        background-color: red;
                                        color: #fff;
                                        width: 15px;
                                        height: 15px;
                                        border-radius: 50%;
                                        display: none;
                                        justify-content: center;
                                        align-items: center;
                                        font-size: 12px;
                                    "
                                >
                                    1
                                </div>
                            </div>
                        </div>
                        <div
                            id="QQ_friend_info"
                            style="
                                display: none;
                                background-color: #fff;
                                height: 100%;
                                width: 100%;
                                padding-top: 50px;
                                padding-left: 10px;
                            "
                        >
                            <span>自定义名称:</span
                            ><input
                                name=""
                                id="setcharname"
                                placeholder="这里输入名称"
                            /><br /><br /><span>自定义头像:</span>
                            <input
                                type="file"
                                id="QQ_head_input"
                            /><br /><br /><br /><button
                                onclick="Setfriendinfo(!1)"
                            >
                                取消
                            </button>
                            <button onclick="Setfriendinfo(!0)">确定</button>
                        </div>
                    </div>
                    <div
                        class="discord"
                        id="App_discord"
                        style="display: none; width: 100%; height: 100%"
                    >
                        <div
                            class="discord-homepage"
                            style="width: 100%; height: 100%"
                        >
                            <div class="discord-top">
                                <svg
                                    t="1744127791511"
                                    class="discord-top-return"
                                    viewBox="0 0 1024 1024"
                                    version="1.1"
                                    xmlns="http://www.w3.org/2000/svg"
                                    p-id="3402"
                                    width="28"
                                    height="28"
                                >
                                    <path
                                        d="M440.070244 831.562927c11.813463 0 23.601951-4.49561 32.593171-13.486829a45.980098 45.980098 0 0 0 0-65.161366l-198.730927-198.730927 589.674146 0.499512c24.001561 0 43.507512-19.431024 43.40761-43.40761 0-24.101463-19.480976-43.63239-43.507512-43.63239l-592.221659-0.574439 201.378342-201.378341a45.980098 45.980098 0 0 0 0-65.161366 45.980098 45.980098 0 0 0-65.186342 0L131.29678 476.734439a45.955122 45.955122 0 0 0-13.53678 33.16761v0.574439c0 13.361951 5.994146 25.300293 15.409951 33.292488l274.307122 274.332097c8.99122 8.966244 20.804683 13.461854 32.593171 13.461854z"
                                        p-id="3403"
                                        fill="#505058"
                                    ></path>
                                </svg>
                                <svg
                                    aria-hidden="true"
                                    width="20"
                                    height="20"
                                    fill="none"
                                    viewBox="0 0 24 24"
                                    style="
                                        margin-left: 15px;
                                        margin-right: 10px;
                                    "
                                >
                                    <path
                                        fill="#313237"
                                        fill-rule="evenodd"
                                        d="M18.09 1.63c.4-.7 1.43-.7 1.82 0l3.96 6.9c.38.66-.12 1.47-.91 1.47h-7.92c-.79 0-1.3-.81-.91-1.48l3.96-6.9Zm.46 1.87h.9c.3 0 .52.26.5.55l-.22 2.02c-.01.16-.17.26-.33.23a1.92 1.92 0 0 0-.8 0c-.16.03-.32-.07-.33-.23l-.21-2.02a.5.5 0 0 1 .5-.55ZM19 9a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z"
                                        clip-rule="evenodd"
                                        class=""
                                    ></path>
                                    <path
                                        fill="#313237"
                                        d="M14.8 3.34a.48.48 0 0 0-.24-.69A9.94 9.94 0 0 0 11 2c-4.97 0-9 3.58-9 8 0 1.5.47 2.91 1.28 4.11.14.21.12.49-.06.67l-1.51 1.51A1 1 0 0 0 2.4 18h5.1a.5.5 0 0 0 .49-.5c0-2.86 1.62-5.3 3.97-6.56.28-.15.38-.51.25-.8a2.86 2.86 0 0 1 .18-2.61l2.4-4.19ZM18.91 12.98a5.45 5.45 0 0 1 2.18 6.2c-.1.33-.09.68.1.96l.83 1.32a1 1 0 0 1-.84 1.54h-5.5A5.6 5.6 0 0 1 10 17.5a5.6 5.6 0 0 1 5.68-5.5c1.2 0 2.32.36 3.23.98Z"
                                        class=""
                                    ></path>
                                </svg>
                                <div class="discord-top-title">
                                    <strong>类脑ΟΔΥΣΣΕΙΑ</strong>
                                </div>
                                <div
                                    style="
                                        display: flex;
                                        align-items: center;
                                        justify-content: center;
                                        background-color: #ebebeb;
                                        border-radius: 50%;
                                        height: 32px;
                                        width: 32px;
                                        margin-left: auto;
                                        margin-right: 10px;
                                    "
                                >
                                    <svg
                                        viewBox="0 0 1024 1024"
                                        width="16"
                                        height="16"
                                    >
                                        <path
                                            d="M991.418182 972.8L791.272727 772.654545c79.127273-83.781818 130.327273-195.490909 130.327273-316.50909 0-251.345455-200.145455-451.490909-446.836364-451.49091C232.727273 0 32.581818 204.8 32.581818 451.490909s200.145455 451.490909 446.836364 451.490909c97.745455 0 190.836364-32.581818 265.309091-88.436363l200.145454 204.8 46.545455-46.545455zM102.4 451.490909c0-209.454545 167.563636-381.672727 377.018182-381.672727s377.018182 172.218182 377.018182 381.672727-172.218182 386.327273-381.672728 386.327273c-204.8 0-372.363636-172.218182-372.363636-386.327273z"
                                            fill="#55565c"
                                            p-id="12001"
                                        ></path>
                                    </svg>
                                </div>
                            </div>
                            <div
                                style="
                                    width: 100%;
                                    height: 1px;
                                    background-color: #dcdcdc;
                                "
                            ></div>
                            <div
                                style="
                                    width: 100%;
                                    height: 1px;
                                    background-color: #d8d9db;
                                "
                            ></div>
                            <div class="discord-top-button">
                                <div class="sortbutton">
                                    <svg
                                        aria-hidden="true"
                                        role="img"
                                        xmlns="http://www.w3.org/2000/svg"
                                        width="16"
                                        height="16"
                                        fill="none"
                                        viewBox="0 0 24 24"
                                    >
                                        <path
                                            fill="#515256"
                                            d="M16.3 21.7a1 1 0 0 0 1.4 0l4-4a1 1 0 0 0-1.4-1.4L18 18.58V3a1 1 0 1 0-2 0v15.59l-2.3-2.3a1 1 0 0 0-1.4 1.42l4 4ZM6.3 2.3a1 1 0 0 1 1.4 0l4 4a1 1 0 0 1-1.4 1.4L8 5.42V21a1 1 0 1 1-2 0V5.41l-2.3 2.3a1 1 0 0 1-1.4-1.42l4-4Z"
                                            class=""
                                        ></path>
                                    </svg>
                                    <div
                                        style="font-size: 14px; color: #515256"
                                    >
                                        排序 & 查看
                                    </div>
                                    <svg
                                        aria-hidden="true"
                                        role="img"
                                        xmlns="http://www.w3.org/2000/svg"
                                        width="20"
                                        fill="none"
                                        viewBox="0 0 24 24"
                                    >
                                        <path
                                            fill="#515256"
                                            d="M5.3 9.3a1 1 0 0 1 1.4 0l5.3 5.29 5.3-5.3a1 1 0 1 1 1.4 1.42l-6 6a1 1 0 0 1-1.4 0l-6-6a1 1 0 0 1 0-1.42Z"
                                            class=""
                                        ></path>
                                    </svg>
                                </div>
                                <div class="tagbutton">
                                    <div
                                        style="font-size: 14px; color: #515256"
                                    >
                                        标签
                                    </div>
                                    <svg
                                        aria-hidden="true"
                                        role="img"
                                        xmlns="http://www.w3.org/2000/svg"
                                        width="20"
                                        fill="none"
                                        viewBox="0 0 24 24"
                                    >
                                        <path
                                            fill="#515256"
                                            d="M5.3 9.3a1 1 0 0 1 1.4 0l5.3 5.29 5.3-5.3a1 1 0 1 1 1.4 1.42l-6 6a1 1 0 0 1-1.4 0l-6-6a1 1 0 0 1 0-1.42Z"
                                            class=""
                                        ></path>
                                    </svg>
                                </div>
                            </div>
                            <div
                                style="
                                    width: 100%;
                                    height: 1px;
                                    background-color: #dcdcdc;
                                "
                            ></div>
                            <div
                                style="
                                    width: 100%;
                                    height: 1px;
                                    background-color: #d8d9db;
                                "
                            ></div>
                            <div class="discord-cardlist">
                                <div class="discord-cardget">
                                    <span>查看帖子</span>
                                </div>
                            </div>
                        </div>
                        <div
                            class="discord-thread-list"
                            style="width: 100%; height: 100%; display: none"
                        ></div>
                    </div>
                </div>
            </div>
            <div
                class="top"
                style="
                    display: flex;
                    align-items: center;
                    justify-content: center;
                "
            >
                <svg
                    t="1735485675807"
                    class="icon"
                    viewBox="0 0 1024 1024"
                    version="1.1"
                    xmlns="http://www.w3.org/2000/svg"
                    p-id="9713"
                    width="16"
                    height="16"
                >
                    <path
                        d="M716.8 805.823147 716.8 384.709973c0-95.68256-77.544107-173.2608-173.216427-173.2608L56.664747 211.449173c-3.754667 0-6.795947 3.024213-6.795947 6.741333L49.8688 805.819733c0 3.71712 3.04128 6.72768 6.795947 6.72768l130.061653 0c3.754667 0 6.792533-3.027627 6.792533-6.765227L193.518933 344.562347c0-3.744427 3.04128-6.782293 6.795947-6.782293l279.68512 0c52.52096 0 95.112533 42.571093 95.112533 95.09888l0 372.8896c0 3.741013 3.037867 6.761813 6.772053 6.761813l128.146773 0c3.72736 0 6.772053-3.017387 6.772053-6.72768M454.15424 805.778773c0 3.744427-3.01056 6.76864-6.76864 6.76864L317.354667 812.547413c-3.754667 0-6.795947-3.027627-6.795947-6.76864L310.55872 452.348587c0-3.741013 3.04128-6.77888 6.795947-6.77888l130.030933 0c3.75808 0 6.76864 3.037867 6.76864 6.77888l0 353.447253L454.15424 805.778773zM974.134613 805.778773c0 3.744427-3.044693 6.76864-6.79936 6.76864l-130.000213 0c-3.764907 0-6.826667-3.027627-6.826667-6.76864L830.508373 218.251947c0-3.75808 3.06176-6.792533 6.826667-6.792533l130.000213 0c3.75808 0 6.79936 3.034453 6.79936 6.792533L974.134613 805.778773z"
                        fill="#ffffff"
                        p-id="9714"
                    ></path>
                </svg>
            </div>
        </div>
        <script></script>
        <script>
            var __webpack_exports__ = {}; // ./src/界面/chat/chat_page.html
            var lastAiNewMessages = {};

            // Module
            var code =
                '<div data-name="${name}" class="QQ_chat_page" style="width:100%;height:100%;padding-top:0"> <div style="padding-top:10px;backdrop-filter:blur(1px);background-color:rgb(255,255,255,.1)"> <div style="width:100%;height:20px;display:grid;top:0;left:0;grid-template-columns:auto 1fr auto;align-items:center;margin-top:20px"> <svg class="QQ-close-btn" viewBox="0 0 1024 1024" style="height:18px;width:18px;margin-left:8px"> <path d="M769.137778 153.372444L444.984889 512l324.152889 358.684444c36.408889 35.043556 36.408889 91.989333 0 126.976a95.744 95.744 0 0 1-131.868445 0l-377.571555-417.678222c-1.536-1.365333-3.584-1.877333-5.063111-3.299555A87.438222 87.438222 0 0 1 227.555556 512c-0.341333-23.324444 8.533333-46.876444 27.079111-64.739556 1.479111-1.422222 3.527111-1.934222 5.063111-3.185777L637.269333 26.339556a95.744 95.744 0 0 1 131.868445 0c36.408889 35.043556 36.408889 91.932444 0 127.032888z" fill="#666666" p-id="1570"></path> </svg> <div style="display:flex;align-items:center;position:relative"> <div class="new_tips" style="background-color:gray;color:#fff;width:20px;height:20px;border-radius:50%;display:none;justify-content:center;align-items:center;font-size:12px"> 1 </div> <span style="margin-left:8px;color:#000;font-size:16px" id="QQ_chat_username" onclick="handleChatTitleClick(this)">${name}</span> <div class="group-member-dropdown" id="group_member_dropdown" style="display:none;position:absolute;top:25px;left:8px;background:#fff;border:1px solid #ddd;border-radius:5px;box-shadow:0 2px 10px rgba(0,0,0,0.1);z-index:1000;min-width:200px;max-height:300px;overflow-y:auto;"> <div class="group-member-list" id="group_member_list"></div> </div> </div> <svg id="QQ_chat_page_setting" viewBox="0 0 1024 1024" style="height:20px;width:20px;margin-right:20px"> <path d="M901.632 896H122.368c-30.72 0-55.808-25.088-55.808-55.808v-1.536c0-30.72 25.088-55.808 55.808-55.808h779.776c30.72 0 55.808 25.088 55.808 55.808v1.536c-0.512 30.72-25.6 55.808-56.32 55.808zM901.632 568.32H122.368c-30.72 0-55.808-25.088-55.808-55.808v-1.536c0-30.72 25.088-55.808 55.808-55.808h779.776c30.72 0 55.808 25.088 55.808 55.808v1.536c-0.512 30.72-25.6 55.808-56.32 55.808zM901.632 240.64H122.368c-30.72 0-55.808-25.088-55.808-55.808v-1.536c0-30.72 25.088-55.808 55.808-55.808h779.776c30.72 0 55.808 25.088 55.808 55.808v1.536c-0.512 30.72-25.6 55.808-56.32 55.808z" p-id="4301" fill="#666666"></path> </svg> </div> <div style="width:100%;height:.5px;background-color:#eee;margin-top:10px;border-top:1px solid #9a9a9a"></div> </div> <div class="input-container"> <div style="display:flex;align-items:center;width:100%"> <svg viewBox="0 0 1024 1024" width="25" height="25" style="margin-left:10px"> <path d="M512 62a184.09090869 184.09090869 0 0 1 184.09090869 184.09090869v204.54545478a184.09090869 184.09090869 0 1 1-368.18181738 1e-8v-204.54545479A184.09090869 184.09090869 0 0 1 512 62z m0 65.45454521a118.63636348 118.63636348 0 0 0-118.63636348 118.63636348v204.54545479a118.63636348 118.63636348 0 1 0 237.27272695 0v-204.54545479A118.63636348 118.63636348 0 0 0 512 127.45454521z" p-id="6838"></path> <path d="M192.90909131 471.09090869a319.09090869 319.09090869 0 0 0 638.18181738 0 32.72727305 32.72727305 0 1 0-65.45454521 0 253.63636348 253.63636348 0 0 1-507.27272695 0 32.72727305 32.72727305 0 1 0-65.45454522 0z" p-id="6839"></path> <path d="M479.27272695 757.45454521v131.85a32.72727305 32.72727305 0 1 0 65.4545461 0V757.45454521a32.72727305 32.72727305 0 1 0-65.4545461 0z" p-id="6840"></path> <path d="M409.72727305 953.81818174h206.87727216a32.72727305 32.72727305 0 1 0 0-65.45454522H409.72727305a32.72727305 32.72727305 0 1 0 0 65.45454522z" p-id="6841"></path> </svg> <div style="flex-grow:1;margin-left:5px;margin-right:2%"> <input class="userInput" type="text" name="" style="box-sizing:border-box;background-color:transparent"/> </div> <div style="margin-right:7px" id="QQ_chat_send-btn"> <button style="background-color:#fff;border-radius:30px;height:31px;display:block;width:3.5rem;background-color:transparent;border:1px solid rgb(0,0,0,.5)"> 发送 </button> </div> </div> </div> <div class="msgcontent" style="padding-top:15px;padding-bottom:0"></div> </div>';
            // Exports
            /* harmony default export */ var chat_page = code; // ./src/界面/chat/chat_page_setting.html
            // Module
            var chat_page_setting_code =
                '<div class="chat-setting-popup"> <div class="chat-setting-header"> <span>聊天设置</span> <svg class="close-setting-btn" viewBox="0 0 1024 1024" width="20" height="20"> <path d="M512 421.490332 331.092592 240.582924C307.952518 217.442849 270.568889 217.442849 247.428814 240.582924 224.288739 263.722999 224.288739 301.106628 247.428814 324.246702L428.336222 505.154112 247.428814 686.061521C224.288739 709.201596 224.288739 746.585225 247.428814 769.7253 270.568889 792.865374 307.952518 792.865374 331.092592 769.7253L512 588.817891 692.907408 769.7253C716.047482 792.865374 753.431111 792.865374 776.571186 769.7253 799.711261 746.585225 799.711261 709.201596 776.571186 686.061521L595.663778 505.154112 776.571186 324.246702C799.711261 301.106628 799.711261 263.722999 776.571186 240.582924 753.431111 217.442849 716.047482 217.442849 692.907408 240.582924L512 421.490332Z" fill="#666666"></path> </svg> </div> <div class="chat-setting-content"> <div class="setting-item"> <span>气泡颜色</span> <div style="flex:1"> <input style="width:100%" type="text" id="bubble-color-input" placeholder="颜色值"/> </div> <input type="color" id="bubble-color" class="color-picker"/> </div> <div class="setting-item"> <span>字体颜色</span> <div style="flex:1"> <input style="width:100%" type="text" id="text-color-input" placeholder="颜色值"/> </div> <input type="color" id="text-color" class="color-picker"/> </div> <div class="setting-item"> <span>聊天壁纸</span> <input type="text" id="chat-bg" placeholder="输入图片URL"/> </div> <div class="preview" style="margin:0 auto"> <div class="QQ_chat_msgdiv" id="chat-setting-preview" data-name="${username}" style="margin:0 auto"> <span>这是预览文本</span> </div> </div> </div> <div class="chat-setting-footer"> <button id="randomcolor-setting-btn" style="background-color:#919bec;color:#fff">随机</button> <button id="save-setting-btn">保存</button> <button id="cancel-setting-btn">取消</button> </div> </div>';
            // Exports
            /* harmony default export */ var chat_page_setting =
                chat_page_setting_code; // ./src/界面/chat/chat_list_item.html
            // Module
            var chat_list_item_code =
                '<div data-name="${name}" class="QQ_home_usermsg"> <div class="QQ_home_head" style="background-image:url(\'${head}\')"></div> <div style="width:100%;display:grid;grid-template-columns:1fr auto;grid-template-rows:1fr 1fr;row-gap:4px"> <span class="QQ_home_name"><strong>${name}</strong></span> <span class="QQ_home_lasttime" style="color:#626367;justify-self:end"></span> <span class="QQ_home_lastmsg" style="color:#626367;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">...</span> <div class="QQ_home_usermsg_new" style="display:none"></div> </div> </div>';
            // Exports
            /* harmony default export */ var chat_list_item =
                chat_list_item_code; // ./src/界面/chat/chat_user_message.html
            // Module
            var chat_user_message_code =
                '<div class="QQ_chat_mymsg"> <div style="width:auto;height:auto;margin-top:4px"> ${content} </div> <div class="user_avatar Chat_MyHead"></div> </div>';
            // Exports
            /* harmony default export */ var chat_user_message =
                chat_user_message_code; // ./src/界面/chat/chat_char_msg.html
            // Module
            var chat_char_msg_code =
                ' <% if (isgroup) { %> <div class="QQ_chat_charmsg"> <div data-name="${name}" class="QQ_chat_head head"></div> <div style="width:auto;height:auto;margin-top:4px"> <span class="name">${name}</span><br/> ${content} </div> </div> <% } else { %> <div class="QQ_chat_charmsg"> <div data-name="${name}" class="QQ_chat_head head"></div> <div style="width:auto;height:auto;margin-top:4px">${content}</div> </div> <% } %>';
            // Exports
            /* harmony default export */ var chat_char_msg = chat_char_msg_code; // ./src/界面/chat/chat_normal_message.html
            // Module
            var chat_normal_message_code =
                '<div class="QQ_chat_msgdiv" data-name="${username}" <% if (isgroup) { %> style="margin-top:6px" <% } %>> <span>${message}</span> </div>';
            // Exports
            /* harmony default export */ var chat_normal_message =
                chat_normal_message_code; // ./src/界面/chat/chat_emoji_message.html
            // Module
            var chat_emoji_message_code =
                '<div class="QQ_chat_msgdiv" data-name="${username}" <% if (isgroup) { %> style="margin-top:6px" <% } %>> <div style="width:100%;background-color:#fff"> <img class="msgimg" loading="lazy" src="<%= emojiUrl %>" alt="加载失败"/> </div> <% if (additionalText) { %> <span style="margin-top:5px;display:block"> <%= additionalText %> </span> <% } %> </div>';
            // Exports
            /* harmony default export */ var chat_emoji_message =
                chat_emoji_message_code; // ./src/界面/chat/chat_fakeimg_message.html
            // Module
            var chat_fakeimg_message_code =
                '<div class="QQ_chat_msgdiv" data-name="${username}" <% if (isgroup) { %> style="margin-top:6px" <% } %>> <div class="QQ_chat_fakeimg" style="text-align:center"> <div>${content}</div> </div> ${additionalText} </div>';
            // Exports
            /* harmony default export */ var chat_fakeimg_message =
                chat_fakeimg_message_code; // ./src/界面/chat/chat_music_message.html
            // Module
            var chat_music_message_code =
                '<div class="QQ_chat_music"> <div class="music-container" style="display:grid;grid-template-columns:1fr 64px;width:100%"> <div style="display:flex;flex-direction:column;margin-top:8px;overflow:hidden;max-width:100%"> <div class="hide-title music-name" style="font-size:1.2rem"><strong>${musicname}</strong></div> <div class="hide-title music-author" style="color:#8d8c8d;margin-left:3px;margin-top:10px;font-size:1rem">${musicauthor}</div> </div> <div style="margin-left:auto;position:relative;height:64px;width:64px"> <div class="icon-container" style="width:64px;width:64px;position:relative"> <svg style="position:absolute;left:-3px;top:-5px" class="icon" viewBox="0 0 1024 1024" width="72" height="72"><path d="M773.9392 301.8752m-200.0384 0a200.0384 200.0384 0 1 0 400.0768 0 200.0384 200.0384 0 1 0-400.0768 0Z" fill="#d81e06" p-id="51386"></path><path d="M924.4672 706.2528a24.32 24.32 0 0 1-24.2688 24.2688h-145.7664a24.3712 24.3712 0 0 0-24.2688 24.32 24.2688 24.2688 0 0 0 24.2688 24.2688h48.5888a24.32 24.32 0 0 1 24.2688 24.32 24.32 24.32 0 0 1-24.2688 24.2688h-64.512A388.7616 388.7616 0 0 1 122.88 390.4512h-48.5888a24.32 24.32 0 0 1 0-48.5888h97.28a24.2688 24.2688 0 0 0 6.8096-47.5648l0.768-0.9728H122.88a24.32 24.32 0 1 1 0-48.5888h101.632a388.7616 388.7616 0 0 1 619.52 437.248h56.32a24.32 24.32 0 0 1 24.1152 24.2688z" fill="#2c2c2c" p-id="51387"></path><path d="M565.8112 478.8736a3.84 3.84 0 0 0-4.5568 4.608c3.1744 14.7456 7.8848 40.96 9.984 60.0576 3.6352 32.2048-28.5696 62.3104-53.6064 70.7584-39.424 13.568-84.8896-18.688-95.1296-56.32-11.776-43.9808 12.6464-97.5872 53.2992-115.0464 4.5056-2.0992 9.0112-3.8912 13.568-5.9904 9.3184-4.2496 4.8128-11.1616 3.2768-17.5104-4.1984-17.4592-6.6048-34.9184 2.4064-51.2 13.568-24.4224 48.7936-43.6736 76.1856-31.9488a276.48 276.48 0 0 1 34.6624 16.5888 25.1904 25.1904 0 0 1 10.5472 28.2624c-5.7344 15.36-20.7872 18.9952-36.7616 9.6768a196.1984 196.1984 0 0 0-17.4592-9.9328 16.2304 16.2304 0 0 0-23.808 15.36 150.3744 150.3744 0 0 0 1.9456 18.0224 18.4832 18.4832 0 0 0 13.568 14.8992 200.3456 200.3456 0 0 1 29.3888 8.9088c38.8096 17.152 66.56 45.1584 79.5136 87.04 24.064 77.6704-21.0944 155.0848-87.9616 184.6272a182.016 182.016 0 0 1-116.8384 13.2096 185.6 185.6 0 0 1-126.464-104.8064c-18.0736-40.96-22.8864-82.7904-8.7552-127.0784 18.9952-59.2384 56.9344-99.6352 114.7392-121.9072a23.4496 23.4496 0 0 1 28.0064 9.728 21.1456 21.1456 0 0 1-6.0416 29.5424 259.8912 259.8912 0 0 1-25.2928 13.568c-31.8976 16.2304-51.7632 42.752-64.4096 75.8784-24.7296 64.4096 9.3184 139.1104 65.6384 168.3456 51.7632 27.0848 122.5728 16.2304 160.8192-28.3136A106.2912 106.2912 0 0 0 619.52 542.72c-5.12-25.6-34.5088-59.2896-53.7088-63.8464z m-53.4016 5.9904a6.144 6.144 0 0 0-7.9872-4.5056c-33.28 11.4688-47.5136 47.2576-31.9488 76.4416a28.0064 28.0064 0 0 0 30.1056 13.824c14.1824-4.1984 24.1152-14.4384 22.016-27.6992-2.9696-19.5072-7.936-38.8096-12.1856-58.0608z" fill="#d81e06" p-id="51388"></path></svg> <div class="music-img" style="width:64px;height:64px;position:absolute;left:0;top:0;background-size:cover;z-index:1;background-image:url(\'https://y.qq.com/music/photo_new/T002R800x800M000004Z85XP1c25b7.jpg\');display:none"> </div> </div> <div class="music-play-button"> <svg class="icon-music-play" viewBox="0 0 1024 1024" width="24" height="24"> <path d="M902.420317 544.833016l-585.142857-357.587302v715.174603l585.142857-357.587301z" p-id="42990" fill="#ffffff"></path> </svg> <svg class="icon-music-stop" t="1743245033745" class="icon" viewBox="0 0 1024 1024" width="19" height="19" style="display:none"><path d="M290.133333 128h-39.808C206.336 128 170.666667 178.944 170.666667 241.792v540.416C170.666667 845.056 206.336 896 250.325333 896H290.133333c43.946667 0 79.658667-50.944 79.658667-113.792V241.792C369.792 178.944 334.08 128 290.133333 128zM773.674667 128H733.866667c-43.989333 0-79.658667 50.944-79.658667 113.792v540.416c0 62.848 35.669333 113.792 79.658667 113.792h39.808C817.664 896 853.333333 845.056 853.333333 782.208V241.792C853.333333 178.944 817.664 128 773.674667 128z" fill="#ffffff" p-id="43402"></path></svg> </div> </div> </div> <div style="width:100%;height:2px;background-color:#efefef;margin-bottom:5px;margin-top:5px"></div> <div style="display:flex;align-items:center;gap:5px"> <svg viewBox="0 0 1024 1024" style="width:.9rem;height:.9rem"> <path d="M0 0m184.32 0l655.36 0q184.32 0 184.32 184.32l0 655.36q0 184.32-184.32 184.32l-655.36 0q-184.32 0-184.32-184.32l0-655.36q0-184.32 184.32-184.32Z" fill="#EA3E3C" p-id="1500"></path> <path d="M527.616 849.43872a373.6064 373.6064 0 0 1-162.54976-39.00416c-112.36352-55.16288-180.00896-176.29184-172.55424-308.67456 7.41376-130.34496 85.10464-237.4656 202.752-279.552a35.85024 35.85024 0 0 1 24.15616 67.51232c-107.66336 38.49216-150.81472 136.86784-155.29984 216.13568-5.86752 103.51616 46.08 197.79584 132.34176 240.13824 124.69248 60.30336 216.91392 22.35392 260.82304-5.64224 59.8016-38.16448 97.86368-100.01408 96.95232-157.55264-1.024-63.72352-24.064-120.99584-63.27296-157.14304a145.408 145.408 0 0 0-65.5872-35.28704q2.82624 9.76896 5.64224 19.32288c13.38368 45.63968 24.94464 85.05344 25.6 114.40128a134.26688 134.26688 0 0 1-37.69344 97.76128 139.1104 139.1104 0 0 1-100.6592 40.45824 140.10368 140.10368 0 0 1-100.47488-42.24 169.12384 169.12384 0 0 1-46.2848-122.76736c1.19808-85.12512 80.11776-153.28256 162.816-175.104a324.80256 324.80256 0 0 1-6.71744-67.05152 92.0576 92.0576 0 0 1 69.18144-91.81184c46.21312-12.53376 104.448 5.19168 124.66176 37.888a35.84 35.84 0 0 1-11.70432 49.31584 35.84 35.84 0 0 1-49.26464-11.65312 62.34112 62.34112 0 0 0-48.45568-5.21216c-4.32128 1.71008-12.35968 4.90496-12.76928 23.10144a270.87872 270.87872 0 0 0 6.73792 58.51136 217.4976 217.4976 0 0 1 133.56032 57.6512c53.57568 49.38752 85.0432 125.46048 86.35392 208.71168 1.29024 81.85856-49.7664 167.86432-130.048 219.136a310.14912 310.14912 0 0 1-168.2432 48.65024z m23.6544-457.55392c-56.77056 15.6672-107.4688 63.03744-108.07296 106.42432a98.304 98.304 0 0 0 25.6512 71.43424 68.0448 68.0448 0 0 0 49.36704 20.87936 67.24608 67.24608 0 0 0 49.44896-18.944 63.19104 63.19104 0 0 0 17.23392-46.08c-0.4096-19.79392-11.7248-58.368-22.67136-95.6928-3.61472-12.42112-7.35232-25.14944-10.9568-38.02112z" fill="#FFFFFF" p-id="1501"></path> </svg> <div style="font-size:.9rem;color:#8d8c8c">网易云音乐</div> </div> </div>';
            // Exports
            /* harmony default export */ var chat_music_message =
                chat_music_message_code; // ./src/界面/chat/chat_transfer_message.html
            // Module
            var chat_transfer_message_code =
                '<div class="give_money"> <div style="background-color:#4396f7;height:80px;width:100%;color:#fff;padding-top:20px;padding-left:12px;display:flex;flex-direction:column;gap:9px;position:relative"> <span><%= amount %></span> <span>已转入你的余额</span> <div style="border-radius:50%;background-color:#9fccf1;width:50px;height:50px;position:absolute;right:10px;display:flex;align-items:center;justify-content:center;top:15px"> <svg t="1738258225266" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4449" width="33" height="33"> <path d="M954.014 510.695c-31.51 0.303-185.995-88.917-190.874-93.568-11.734-11.188-7.3-25.115 4.673-27.02s79.203-9.898 79.203-9.898c-41.318-110.437-133.518-198.636-254.527-227.223-193.138-45.643-392.87 83.827-437.013 281.424-0.38 1.685-3.047 21.83-19.045 21.191-10.83-0.432-46.309-14.539-59.136-20.556-14.644-6.868-18.601-5.094-14.16-27.201C113.37 156.643 370.632-12.653 617.554 45.272c204.919 48.063 347.27 225.878 362.91 428.477 2.619 27.151-11.203 36.797-26.451 36.944z m-322.516 55.059c20.284 0 36.729 16.427 36.729 36.727 0 20.265-16.445 36.729-36.729 36.729h-73.456v45.909c0 25.359-20.551 45.911-45.911 45.911-25.358 0-45.91-20.551-45.91-45.911V639.21h-73.456c-20.284 0-36.727-16.465-36.727-36.729 0-20.302 16.444-36.727 36.727-36.727h73.456v-36.73h-73.456c-20.284 0-36.727-16.461-36.727-36.726 0-20.3 16.444-36.729 36.727-36.729h73.456v-2.512l-81.508-81.491c-14.445-14.455-14.445-37.875 0-52.313s37.858-14.437 52.304 0l74.497 74.478 74.786-74.784c14.444-14.419 37.859-14.419 52.303 0 14.446 14.454 14.446 37.877 0 52.313l-80.558 80.559v3.749h73.456c20.284 0 36.729 16.429 36.729 36.729 0 20.267-16.445 36.726-36.729 36.726h-73.456v36.73h73.456z m-368.471 51.828c16.112 10.302 12.229 30.994-5.477 32.836s-73.153 6.725-73.153 6.725C228.353 760.157 317.44 841.379 432.63 868.585c193.137 45.623 390.651-77.582 434.806-275.179 0.906-4.054 0.877-3.418 2.457-12.122s4.139-21.945 21.142-16.052 58.475 18.085 71.394 21.539 11.465 8.548 9.846 20.553c-0.493 3.651-1.238 6.994-2.017 10.509-57.81 256.921-309.451 417.196-562.049 357.924-204.677-48.01-346.947-225.429-362.865-427.724-2.159-34.762 22.4-41.857 47.505-28.577 19.75 10.447 154.064 87.822 170.176 98.124z" p-id="4450" fill="#4090ee"></path> </svg> </div> </div> <div style="background-color:#fff;width:100%;height:30px;color:#959598;font-size:13px;padding-left:10px;padding-top:8px"> QQ转账 </div> </div> ';
            // Exports
            /* harmony default export */ var chat_transfer_message =
                chat_transfer_message_code; // ./src/界面/chat/chat_char_voice_message.html
            // Module
            var chat_char_voice_message_code =
                '<div class="QQ_chat_msgdiv" data-name="${username}" <% if (isgroup) { %> style="margin-top:6px" <% } %>> <div class="QQ_chat_voice" style="width:100%;display:flex;gap:5px;align-items:center"> <span style="margin-left:2px">${time}"</span> <span style="display:block"> <svg style="transform:rotate(90deg);display:flex;align-items:center" t="1742985508017" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="38914" width="20" height="20"> <path d="M99.931429 457.782857c8.137143 8.137143 20.132571 7.716571 27.849142-0.420571 101.156571-107.574857 234.861714-164.150857 384.438858-164.150857 150.418286 0 284.562286 56.996571 385.28 164.571428 7.277714 7.296 18.870857 7.296 26.569142-0.859428l57.014858-56.996572c6.838857-7.277714 6.838857-16.713143 1.28-23.570286-96.859429-119.149714-279.003429-206.994286-470.144-206.994285S138.934857 257.206857 42.057143 376.356571c-5.997714 6.857143-5.577143 16.274286 1.28 23.588572z m171.428571 171.867429c8.576 8.996571 19.712 8.137143 27.849143-1.28 49.718857-55.296 130.285714-95.158857 213.010286-94.299429 83.565714-0.859429 163.712 40.283429 213.851428 95.579429 8.137143 8.557714 18.852571 8.557714 27.008-0.438857l63.853714-62.994286c6.857143-6.857143 7.716571-15.853714 1.28-23.149714-62.134857-76.708571-177.426286-133.284571-305.993142-133.284572-128.585143 0-243.858286 56.996571-306.011429 133.302857-6.418286 7.277714-5.558857 15.835429 1.28 23.131429z m240.859429 224.987428c8.996571 0 17.133714-4.717714 32.987428-20.132571l100.297143-96.438857c6.418286-5.997714 7.716571-15.414857 2.139429-22.710857-27.008-34.706286-77.568-64.713143-135.424-64.713143-59.154286 0-110.573714 31.286857-137.142858 67.291428-3.858286 5.997714-2.56 14.134857 3.84 20.132572l100.297143 96.438857c15.853714 15.414857 24.009143 20.132571 33.005715 20.132571z" p-id="38915" fill="currentColor"></path> </svg> </span> <span style="display:block" class="totext"> <svg style="margin-left:30px;display:flex;align-items:center" viewBox="0 0 1024 1024" width="24" height="24"> <path d="M999.611733 387.697778a37.831111 37.831111 0 0 0-48.355555 22.641778v0.512l-1.592889 5.233777c-58.88-241.208889-302.648889-388.892444-543.857778-330.012444A446.805333 446.805333 0 0 0 124.546844 295.253333a39.139556 39.139556 0 0 0 13.653334 53.077334 39.310222 39.310222 0 0 0 18.944 5.233777c13.084444 0 25.201778-6.826667 32.540444-18.375111a374.158222 374.158222 0 0 1 359.480889-183.978666 381.952 381.952 0 0 1 337.351111 334.279111 384.568889 384.568889 0 0 1-3.128889 115.086222v2.616889a38.855111 38.855111 0 0 0 21.560889 48.355555c19.456 6.826667 41.528889-3.185778 48.355556-22.641777l68.835555-192.284445a39.310222 39.310222 0 0 0-22.584889-48.924444z m-148.764444 348.956444a38.115556 38.115556 0 0 0-31.004445 16.839111 373.077333 373.077333 0 0 1-355.214222 157.639111 381.212444 381.212444 0 0 1-323.185778-306.346666 396.344889 396.344889 0 0 1 0-140.856889v-1.592889a39.139556 39.139556 0 0 0-22.072888-48.355556 38.058667 38.058667 0 0 0-48.355556 22.584889l-68.835556 191.317334a38.513778 38.513778 0 0 0 23.608889 48.867555c19.456 7.395556 40.96-3.128889 48.355556-22.584889v-3.697777c58.88 241.208889 302.705778 388.892444 543.914667 330.012444A448.739556 448.739556 0 0 0 881.851733 798.151111a38.684444 38.684444 0 0 0-8.362666-54.158222 31.857778 31.857778 0 0 0-22.641778-7.338667z" p-id="41017" fill="currentColor"></path><path d="M310.687289 693.020444a50.517333 50.517333 0 0 0-33.166222 19.456 40.96 40.96 0 0 0 0 31.573334c1.592889 4.721778 3.697778 9.443556 6.257777 14.165333a26.794667 26.794667 0 0 0 13.198223 11.036445 30.833778 30.833778 0 0 0 12.060444 2.104888h5.290667c6.826667-1.080889 13.653333-2.616889 20.48-4.721777 15.758222-5.290667 32.028444-11.605333 48.924444-18.432 16.782222-6.826667 34.133333-15.758222 49.322667-23.608889 15.246222-7.907556 32.597333-17.863111 46.250667-26.282667 14.222222-8.419556 24.177778-15.758222 35.271111-24.177778 24.632889 19.456 50.915556 36.238222 78.791111 49.891556 33.621333 17.351111 68.835556 31.004444 105.073778 42.097778a56.32 56.32 0 0 0 20.48 3.640889 33.905778 33.905778 0 0 0 34.190222-26.282667 39.025778 39.025778 0 0 0-1.592889-35.726222 49.322667 49.322667 0 0 0-26.225778-18.375111 540.842667 540.842667 0 0 1-85.162667-33.621334 603.932444 603.932444 0 0 1-63.601777-38.912c20.48-23.096889 37.831111-48.355556 52.565333-75.662222a465.294222 465.294222 0 0 0 38.343111-98.304h49.436445a38.456889 38.456889 0 0 0 26.282666-12.060444 46.762667 46.762667 0 0 0 7.850667-26.282667 44.032 44.032 0 0 0-8.931556-28.899556 37.432889 37.432889 0 0 0-26.282666-11.036444H568.6784a116.167111 116.167111 0 0 0-9.500444-17.863111c-10.467556-12.629333-22.584889-25.770667-34.702223-38.912a47.786667 47.786667 0 0 0-27.818666-18.375111h-4.209778a36.636444 36.636444 0 0 0-24.177778 8.419555 35.896889 35.896889 0 0 0-18.375111 29.923556 51.2 51.2 0 0 0 16.270222 33.109333l6.314667 6.314667H315.352178a34.133333 34.133333 0 0 0-26.282667 12.629333 45.852444 45.852444 0 0 0-6.826667 26.282667c-0.512 10.467556 2.104889 20.48 7.907556 28.899555 6.826667 6.826667 16.270222 11.036444 26.282667 11.036445h47.274666c5.233778 15.758222 10.524444 32.028444 16.839111 47.786666a419.271111 419.271111 0 0 0 50.403556 94.094223c8.419556 11.036444 17.351111 22.584889 26.282667 33.109333a389.461333 389.461333 0 0 1-64.625778 39.936c-26.282667 12.629333-54.101333 23.096889-81.976889 32.028444z m131.299555-246.954666h140.344889c-6.826667 23.096889-16.839111 45.169778-28.387555 66.730666a325.290667 325.290667 0 0 1-39.936 55.751112 319.146667 319.146667 0 0 1-39.424-52.622223l-2.616889-4.209777a388.778667 388.778667 0 0 1-29.980445-65.649778z" p-id="41018" fill="currentColor"></path></svg> </span> </div> <div class="voice2text" style="display:none"> <div style="width:100%;height:1px;background-color:#000;margin-top:10px;margin-bottom:8px"></div> <span>${content}</span> </div> </div>';
            // Exports
            /* harmony default export */ var chat_char_voice_message =
                chat_char_voice_message_code; // ./src/界面/chat/chat_my_voice_message.html
            // Module
            var chat_my_voice_message_code =
                '<div class="QQ_chat_msgdiv ${username}" <% if (isgroup) { %> style="margin-top:6px" <% } %>> <div class="QQ_chat_voice" style="width:100%;display:flex;gap:5px;align-items:center"> <span style="display:block" class="totext"> <svg style="margin-right:30px;display:flex;align-items:center" viewBox="0 0 1024 1024" width="24" height="24"> <path d="M999.611733 387.697778a37.831111 37.831111 0 0 0-48.355555 22.641778v0.512l-1.592889 5.233777c-58.88-241.208889-302.648889-388.892444-543.857778-330.012444A446.805333 446.805333 0 0 0 124.546844 295.253333a39.139556 39.139556 0 0 0 13.653334 53.077334 39.310222 39.310222 0 0 0 18.944 5.233777c13.084444 0 25.201778-6.826667 32.540444-18.375111a374.158222 374.158222 0 0 1 359.480889-183.978666 381.952 381.952 0 0 1 337.351111 334.279111 384.568889 384.568889 0 0 1-3.128889 115.086222v2.616889a38.855111 38.855111 0 0 0 21.560889 48.355555c19.456 6.826667 41.528889-3.185778 48.355556-22.641777l68.835555-192.284445a39.310222 39.310222 0 0 0-22.584889-48.924444z m-148.764444 348.956444a38.115556 38.115556 0 0 0-31.004445 16.839111 373.077333 373.077333 0 0 1-355.214222 157.639111 381.212444 381.212444 0 0 1-323.185778-306.346666 396.344889 396.344889 0 0 1 0-140.856889v-1.592889a39.139556 39.139556 0 0 0-22.072888-48.355556 38.058667 38.058667 0 0 0-48.355556 22.584889l-68.835556 191.317334a38.513778 38.513778 0 0 0 23.608889 48.867555c19.456 7.395556 40.96-3.128889 48.355556-22.584889v-3.697777c58.88 241.208889 302.705778 388.892444 543.914667 330.012444A448.739556 448.739556 0 0 0 881.851733 798.151111a38.684444 38.684444 0 0 0-8.362666-54.158222 31.857778 31.857778 0 0 0-22.641778-7.338667z" p-id="41017" fill="currentColor"></path><path d="M310.687289 693.020444a50.517333 50.517333 0 0 0-33.166222 19.456 40.96 40.96 0 0 0 0 31.573334c1.592889 4.721778 3.697778 9.443556 6.257777 14.165333a26.794667 26.794667 0 0 0 13.198223 11.036445 30.833778 30.833778 0 0 0 12.060444 2.104888h5.290667c6.826667-1.080889 13.653333-2.616889 20.48-4.721777 15.758222-5.290667 32.028444-11.605333 48.924444-18.432 16.782222-6.826667 34.133333-15.758222 49.322667-23.608889 15.246222-7.907556 32.597333-17.863111 46.250667-26.282667 14.222222-8.419556 24.177778-15.758222 35.271111-24.177778 24.632889 19.456 50.915556 36.238222 78.791111 49.891556 33.621333 17.351111 68.835556 31.004444 105.073778 42.097778a56.32 56.32 0 0 0 20.48 3.640889 33.905778 33.905778 0 0 0 34.190222-26.282667 39.025778 39.025778 0 0 0-1.592889-35.726222 49.322667 49.322667 0 0 0-26.225778-18.375111 540.842667 540.842667 0 0 1-85.162667-33.621334 603.932444 603.932444 0 0 1-63.601777-38.912c20.48-23.096889 37.831111-48.355556 52.565333-75.662222a465.294222 465.294222 0 0 0 38.343111-98.304h49.436445a38.456889 38.456889 0 0 0 26.282666-12.060444 46.762667 46.762667 0 0 0 7.850667-26.282667 44.032 44.032 0 0 0-8.931556-28.899556 37.432889 37.432889 0 0 0-26.282666-11.036444H568.6784a116.167111 116.167111 0 0 0-9.500444-17.863111c-10.467556-12.629333-22.584889-25.770667-34.702223-38.912a47.786667 47.786667 0 0 0-27.818666-18.375111h-4.209778a36.636444 36.636444 0 0 0-24.177778 8.419555 35.896889 35.896889 0 0 0-18.375111 29.923556 51.2 51.2 0 0 0 16.270222 33.109333l6.314667 6.314667H315.352178a34.133333 34.133333 0 0 0-26.282667 12.629333 45.852444 45.852444 0 0 0-6.826667 26.282667c-0.512 10.467556 2.104889 20.48 7.907556 28.899555 6.826667 6.826667 16.270222 11.036444 26.282667 11.036445h47.274666c5.233778 15.758222 10.524444 32.028444 16.839111 47.786666a419.271111 419.271111 0 0 0 50.403556 94.094223c8.419556 11.036444 17.351111 22.584889 26.282667 33.109333a389.461333 389.461333 0 0 1-64.625778 39.936c-26.282667 12.629333-54.101333 23.096889-81.976889 32.028444z m131.299555-246.954666h140.344889c-6.826667 23.096889-16.839111 45.169778-28.387555 66.730666a325.290667 325.290667 0 0 1-39.936 55.751112 319.146667 319.146667 0 0 1-39.424-52.622223l-2.616889-4.209777a388.778667 388.778667 0 0 1-29.980445-65.649778z" p-id="41018" fill="currentColor"></path></svg> </span> <div style="display:flex;align-items:center;gap:5px;margin-left:auto"> <span style="display:block"> <svg style="transform:rotate(-90deg);display:flex;align-items:center" t="1742985508017" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="38914" width="20" height="20"> <path d="M99.931429 457.782857c8.137143 8.137143 20.132571 7.716571 27.849142-0.420571 101.156571-107.574857 234.861714-164.150857 384.438858-164.150857 150.418286 0 284.562286 56.996571 385.28 164.571428 7.277714 7.296 18.870857 7.296 26.569142-0.859428l57.014858-56.996572c6.838857-7.277714 6.838857-16.713143 1.28-23.570286-96.859429-119.149714-279.003429-206.994286-470.144-206.994285S138.934857 257.206857 42.057143 376.356571c-5.997714 6.857143-5.577143 16.274286 1.28 23.588572z m171.428571 171.867429c8.576 8.996571 19.712 8.137143 27.849143-1.28 49.718857-55.296 130.285714-95.158857 213.010286-94.299429 83.565714-0.859429 163.712 40.283429 213.851428 95.579429 8.137143 8.557714 18.852571 8.557714 27.008-0.438857l63.853714-62.994286c6.857143-6.857143 7.716571-15.853714 1.28-23.149714-62.134857-76.708571-177.426286-133.284571-305.993142-133.284572-128.585143 0-243.858286 56.996571-306.011429 133.302857-6.418286 7.277714-5.558857 15.835429 1.28 23.131429z m240.859429 224.987428c8.996571 0 17.133714-4.717714 32.987428-20.132571l100.297143-96.438857c6.418286-5.997714 7.716571-15.414857 2.139429-22.710857-27.008-34.706286-77.568-64.713143-135.424-64.713143-59.154286 0-110.573714 31.286857-137.142858 67.291428-3.858286 5.997714-2.56 14.134857 3.84 20.132572l100.297143 96.438857c15.853714 15.414857 24.009143 20.132571 33.005715 20.132571z" p-id="38915" fill="currentColor"></path> </svg> </span> <span>${time}"</span> </div> </div> <div class="voice2text" style="display:none"> <div style="width:100%;height:1px;background-color:#000;margin-top:10px;margin-bottom:8px"></div> <span>${content}</span> </div> </div>';
            // Exports
            /* harmony default export */ var chat_my_voice_message =
                chat_my_voice_message_code; // ./src/界面/chat/chat_head.css?raw
            var chat_headraw_namespaceObject =
                ".head[data-name='${name}'] {\r\n  background-image: url('${head}') !important;\r\n}\r\n"; // ./src/界面/moment/moment_page.html
            // Module
            var moment_page_code =
                '<div class="user_moment_title" style="margin-bottom:7px"> <div class="QQ_home_head head" data-name="${userName}"></div> <div style="width:100%;display:grid;grid-template-rows:1fr 1fr;row-gap:4px"> <div style="display:flex;align-items:center"> <span><strong class="moment_sender">${userName}</strong></span> <svg class="moment_menu_dots" viewBox="0 0 1024 1024" width="18" height="18" style="margin-left:auto;cursor:pointer" data-moment-id="${momentId}"> <path d="M512.4 429.1c22.3 0 41.7 7.9 58.1 23.6 7.9 7.9 13.9 16.9 18.2 27.1 4.3 10.2 6.4 20.8 6.4 32 0 22.3-8.2 41.7-24.6 58.1-3.3 3.3-6.6 6.1-9.9 8.4s-6.9 4.4-10.8 6.4c-3.9 2-8 3.6-12.3 4.9-4.3 1.3-8.5 2.5-12.8 3.4-4.2 1-8.3 1.5-12.3 1.5-23 0-42.5-8.2-58.6-24.6s-24.1-35.9-24.1-58.6c0-22.6 7.9-42.2 23.6-58.6 5.3-4.6 11-8.9 17.2-12.8 6.2-3.9 13-6.7 20.2-8.4 7.2-1.6 14.4-2.4 21.7-2.4z m326.8 0c23 0 42.3 7.9 58.1 23.6 5.3 5.3 9.7 11 13.3 17.2 3.6 6.2 6.4 13 8.4 20.2 2 7.2 3 14.4 3 21.7 0 22.3-8.2 41.7-24.6 58.1-3.3 3.9-7.2 7.4-11.8 10.3-4.6 2.9-9.4 5.4-14.3 7.4s-10.2 3.6-15.8 4.9-11 2-16.3 2c-23 0-42.5-8.2-58.6-24.6-16.1-16.4-24.1-35.9-24.1-58.6 0-22.6 8.2-42.2 24.6-58.6 7.2-7.2 16.1-13 26.6-17.2 10.5-4.2 21-6.3 31.5-6.4z m-654.6 0c23 0 42.3 7.9 58.1 23.6 5.3 5.3 9.7 11 13.3 17.2 3.6 6.2 6.4 13 8.4 20.2s3 14.4 3 21.7c0 22.3-8 41.7-24.1 58.1s-35.6 24.6-58.6 24.6-42.3-8.2-58.1-24.6c-7.9-7.9-13.9-16.9-18.2-27.1-4.3-10.2-6.4-20.5-6.4-31 0-23 8.2-42.7 24.6-59.1 7.2-7.2 16.1-13 26.6-17.2 10.4-4.2 20.9-6.3 31.4-6.4z" p-id="14923" fill="#000000"></path> </svg> </div> <span style="color:#626367;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;font-size:12px">${timestamp}</span> </div> </div> <span style="font-size:15px;line-height:1.3" class="moment_message">${message}</span> ${imgcontent} <div style="display:flex;align-items:center;gap:3px;margin-top:5px"> <svg t="1736250731870" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16069" width="16" height="16"> <path d="M512 416a96 96 0 1 1-96 96 96 96 0 0 1 96-96m0-64a160 160 0 1 0 160 160 160 160 0 0 0-160-160z" fill="#a1a1a1" p-id="16070"></path> <path d="M512 298.88c188.64 0 288 113.92 366.72 213.12C800 611.36 700.64 725.12 512 725.12S224 611.36 145.28 512C224 412.64 323.36 298.88 512 298.88m0-64C264.64 234.88 147.52 406.56 64 512c83.52 105.44 200.64 277.12 448 277.12S876.48 617.44 960 512c-83.52-105.44-200.64-277.12-448-277.12z" fill="#a1a1a1" p-id="16071"></path> </svg> <span style="color:#a1a1a1;font-size:13px">浏览${additionalInfo}次</span> <div class="moment_button"> <svg viewBox="0 0 1024 1024" width="26" height="26"> <path d="M190.193225 471.411583c14.446014 0 26.139334-11.718903 26.139334-26.13831 0-14.44499-11.69332-26.164916-26.139334-26.164916-0.271176 0-0.490164 0.149403-0.73678 0.149403l-62.496379 0.146333c-1.425466-0.195451-2.90005-0.295735-4.373611-0.295735-19.677155 0-35.621289 16.141632-35.621289 36.114522L86.622358 888.550075c0 19.949354 15.96767 35.597753 35.670407 35.597753 1.916653 0 3.808746 0.292666 5.649674 0l61.022819 0.022513c0.099261 0 0.148379 0.048095 0.24764 0.048095 0.097214 0 0.146333-0.048095 0.24457-0.048095l0.73678 0 0-0.148379c13.413498-0.540306 24.174586-11.422144 24.174586-24.960485 0-13.55983-10.760065-24.441669-24.174586-24.981974l0-0.393973-50.949392 0 1.450025-402.275993L190.193225 471.409536z" fill="#000000" p-id="19734"></path> <path d="M926.52241 433.948343c-19.283182-31.445176-47.339168-44.172035-81.289398-45.546336-1.77032-0.246617-3.536546-0.39295-5.380544-0.39295l-205.447139-0.688685c13.462616-39.059598 22.698978-85.58933 22.698978-129.317251 0-28.349675-3.193739-55.962569-9.041934-82.542948l-0.490164 0.049119c-10.638291-46.578852-51.736315-81.31498-100.966553-81.31498-57.264215 0-95.466282 48.15065-95.466282 106.126063 0 3.241834-0.294712 6.387477 0 9.532097-2.996241 108.386546-91.240027 195.548698-196.23636 207.513194l0 54.881958-0.785899 222.227314 0 229.744521 10.709923 0 500.025271 0.222057 8.746198-0.243547c19.35686 0.049119 30.239721-4.817726 47.803749-16.116049 16.682961-10.761088 29.236881-25.50079 37.490869-42.156122 2.260483-3.341095 4.028757-7.075139 5.106298-11.20111l77.018118-344.324116c1.056052-4.053316 1.348718-8.181333 1.056052-12.160971C943.643346 476.446249 938.781618 453.944769 926.52241 433.948343zM893.82573 486.837924l-82.983993 367.783411-0.099261-0.049119c-2.555196 6.141884-6.879688 11.596106-12.872169 15.427364-4.177136 2.727111-8.773827 4.351098-13.414521 4.964058-1.49812-0.195451-3.046383 0-4.620227 0l-477.028511-0.540306-0.171915-407.408897c89.323375-40.266076 154.841577-79.670527 188.596356-173.661202 0.072655 0.024559 0.124843 0.049119 0.195451 0.072655 2.99931-9.137101 6.313799-20.73423 8.697079-33.164331 5.551436-29.185716 5.258771-58.123792 5.258771-58.123792-4.937452-37.98001 25.940812-52.965306 44.364417-52.965306 25.304316 0.860601 50.263777 33.656541 50.263777 52.326762 0 0 5.600555 27.563776 5.649674 57.190537 0.048095 37.366026-4.6673 56.847729-4.6673 56.847729l-0.466628 0c-5.872754 30.879288-16.214287 60.138682-30.464849 86.964654l0.36839 0.342808c-2.358721 4.815679-3.709485 10.220782-3.709485 15.943111 0 19.922748 19.088754 21.742187 38.765909 21.742187l238.761895 0.270153c0 0 14.666024 0.465604 14.690584 0.465604l0 0.100284c12.132318-0.638543 24.221658 5.207605 31.100322 16.409738 5.504364 9.016351 6.437619 19.6045 3.486404 28.988218L893.82573 486.837924z" fill="#000000" p-id="19735"></path> <path d="M264.827039 924.31872c0.319272 0.024559 0.441045 0.024559 0.295735-0.024559 0.243547-0.048095 0.367367-0.074701-0.295735-0.074701s-0.539282 0.026606-0.271176 0.074701C264.43409 924.343279 264.532327 924.343279 264.827039 924.31872z" fill="#000000" p-id="19736"></path> </svg> <svg viewBox="0 0 1024 1024" width="28" height="28"> <path d="M185.2 888.7c-16.6 0-30-13.4-30-30v-580c0-49.6 40.4-90 90-90h540c49.6 0 90 40.4 90 90v410c0 49.6-40.4 90-90 90h-429c-16.6 0-30-13.4-30-30s13.4-30 30-30h429c16.5 0 30-13.5 30-30v-410c0-16.5-13.5-30-30-30h-540c-16.5 0-30 13.5-30 30v580c0 16.5-13.5 30-30 30z m490.1-430.5H347c-16.6 0-30-13.4-30-30s13.4-30 30-30h328.3c16.6 0 30 13.4 30 30s-13.4 30-30 30zM494 598.2H345.7c-16.6 0-30-13.4-30-30s13.4-30 30-30H494c16.6 0 30 13.4 30 30s-13.4 30-30 30zM194.2 883.7c-9.8 0-19.3-4.8-25.1-13.5-9.1-13.9-5.2-32.5 8.6-41.5l160-105c13.9-9.1 32.5-5.2 41.5 8.6 9.1 13.9 5.2 32.5-8.6 41.5l-160 105c-5 3.3-10.8 4.9-16.4 4.9z" fill="#202020" p-id="31300"></path> </svg> <svg viewBox="0 0 1024 1024" width="28" height="28"> <path d="M168.021333 751.104a53.333333 53.333333 0 0 1-81.450666-55.893333c48-219.733333 177.493333-333.184 381.205333-332.458667l8.490667-0.213333V186.026667c0-8.213333 2.602667-16.213333 7.445333-22.826667 1.237333-1.621333 1.237333-1.621333 2.602667-3.136a33.92 33.92 0 0 1 47.936-1.621333l370.197333 346.005333a32 32 0 0 0 1.066667 0.938667c7.914667 6.784 12.437333 16.576 12.437333 26.901333v3.498667c0 10.325333-4.522667 20.117333-12.373333 26.837333l-0.896 0.768-0.256 0.213333-370.922667 323.968c-1.109333 0.938667-1.109333 0.938667-2.282667 1.834667-15.146667 11.093333-36.437333 7.786667-47.509333-7.36a38.656 38.656 0 0 1-7.466667-22.826667v-197.248l-7.253333-0.362666c-112.213333 1.237333-212.266667 31.04-300.970667 89.472z m301.290667-153.472l1.962667 0.021333 68.992 3.541334v195.52l301.44-263.274667-301.44-281.749333v173.12l-31.146667 0.853333-40.597333 1.066667c-165.504-0.554667-268.117333 82.773333-313.386667 256.896 93.76-56.192 198.698667-84.906667 314.176-85.994667z m384.64-65.322667v3.498667c0-0.597333 0-1.173333 0.042667-1.749333a28.714667 28.714667 0 0 1-0.042667-1.749334z" fill="#000000" p-id="33532"></path> </svg> </div> </div> <div style="display:flex;align-items:center;gap:3px;margin-top:0"> <svg t="1736250924867" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="17414" width="16" height="16"> <path d="M736.653061 929.959184H287.346939c-45.97551 0-83.591837-37.616327-83.591837-83.591837V177.632653c0-45.97551 37.616327-83.591837 83.591837-83.591837h449.306122c45.97551 0 83.591837 37.616327 83.591837 83.591837v668.734694c0 45.97551-37.616327 83.591837-83.591837 83.591837zM287.346939 135.836735c-22.987755 0-41.795918 18.808163-41.795919 41.795918v668.734694c0 22.987755 18.808163 41.795918 41.795919 41.795918h449.306122c22.987755 0 41.795918-18.808163 41.795919-41.795918V177.632653c0-22.987755-18.808163-41.795918-41.795919-41.795918H287.346939z" fill="#a1a1a1" p-id="17415"></path> <path d="M616.489796 815.020408H407.510204c-11.493878 0-20.897959-9.404082-20.897959-20.897959s9.404082-20.897959 20.897959-20.897959h208.979592c11.493878 0 20.897959 9.404082 20.897959 20.897959s-9.404082 20.897959-20.897959 20.897959z" fill="#a1a1a1" p-id="17416"></path> </svg> <span style="color:#a1a1a1;font-size:13px">${randomPhone}</span> </div> <div style="display:flex;align-items:center;gap:3px;margin-top:5px;margin-bottom:5px"> <svg class="icon" viewBox="0 0 1024 1024" width="13" height="13"> <path d="M773.6 912.7h-1.2c-37.2-0.4-74.5-0.4-111.8-0.4h-56.9c-38 0-76 0-114.1-0.5-21.1-0.6-41.9-5-61.5-13-33.3-13-52.3-42-52.2-79.7l0.1-141.4c0-78.3 0-156.7 0.7-235 0.1-21.3 13.8-41.3 25.5-51.8 45.3-41.4 94.5-93 115.1-162.6 5.7-19.4 7.9-40.8 10.2-63.4 4.6-45 33.8-74.3 72.8-74.3 15.3 0 30.6 4.6 45.6 13.5 30.1 18.1 50.2 46.5 61.3 87 17.8 64.3 8.7 126.7-1.3 180.2v0.2c-2.3 12.5 7.1 24.1 19.9 24.1h130c22.4 0 54.5 2.8 74.3 26.8 14.4 17.5 18.5 41.1 12.4 72.3-18.6 95.9-41.4 192.6-63.2 282.7-6.8 28.1-18.1 54.1-29 79.3l-4.7 10.8c-12.4 29.2-38 45.2-72 45.2zM216.1 903.3h-11.9c-43 0-78.2-35.2-78.2-78.2V476.6c0-43 35.2-78.2 78.2-78.2h11.9c43 0 78.2 35.2 78.2 78.2V825c0.1 43.1-35.1 78.3-78.2 78.3z" fill="#000000" p-id="34839"></path> </svg> <span style="color:#474545;font-size:14px">${extraContent}人已赞</span> </div> <div class="user_leave_message_list"></div> <div style="display:flex;align-items:center;gap:3px;margin-top:10px"> <div class="user_avatar" style="width:30px;min-width:30px;height:30px;border-radius:50%"></div> <div style="display:flex;align-items:center;width:100%;background-color:#f5f5f5;padding-right:5px;margin-left:5px"> <input type="text" placeholder="说点什么吧..." style="height:30px;width:100%;margin-left:5px;border-radius:4px;background-color:#f5f5f5;padding:6px;border:none"/> <svg viewBox="0 0 1024 1024" width="28" height="28" class="moment_comment"> <path d="M871.04 89.770667L120.064 380.16a51.2 51.2 0 0 0-1.792 94.762667l303.36 130.56 131.072 303.957333a51.2 51.2 0 0 0 94.805333-1.877333l289.792-751.573334a51.2 51.2 0 0 0-66.261333-66.133333z m-41.130667 107.392l-231.978666 601.642666-97.962667-227.114666-3.584-7.338667a85.333333 85.333333 0 0 0-41.045333-37.248l-226.56-97.536 601.173333-232.405333z" fill="#007aff" p-id="18561"></path> </svg> </div> </div> <div style="width:110%;height:8px;background-color:#e9e9e9;margin-left:-7px;margin-top:10px;margin-bottom:10px"> </div>';
            // Exports
            /* harmony default export */ var moment_page = moment_page_code; // ./src/界面/discord/discord_card.html
            // Module
            var discord_card_code =
                '<div class="discord-card" data-id="${id}"> <div class="discord-card-tags">${tag}</div> <span class="discord-card-author">${name}</span> <span style="color:#67686a;font-size:15px;margin-left:8px">${time}</span> <div class="discord-card-title">${cardtilte}</div> <div class="discord-card-content">${content}</div> <div class="discord-card-fakeimg">${img}</div> <div class="discord-card-interact"> <svg aria-hidden="true" role="img" xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24"> <path fill="#4d5059" d="M12 22a10 10 0 1 0-8.45-4.64c.13.19.11.44-.04.61l-2.06 2.37A1 1 0 0 0 2.2 22H12Z" class=""> </path> </svg> <div style="color:#333237;margin-left:5px">${messages}</div> <div class="discord-card-interact-icon moment-like-button" data-moment-id="${id}" data-liked="${likedByUser}"> <div class="like-emoji">👍</div> <div class="moment-like-count">${likeCount}</div> </div> </div> </div>';
            // Exports
            /* harmony default export */ var discord_discord_card =
                discord_card_code; // ./src/界面/discord/discord_thread.html
            // Module
            var discord_thread_code =
                '<div class="discord-thread" data-id="${id}"> <div class="discord-thread-top"> <svg class="discord-thread-top-return" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3402" width="28" height="28"> <path d="M440.070244 831.562927c11.813463 0 23.601951-4.49561 32.593171-13.486829a45.980098 45.980098 0 0 0 0-65.161366l-198.730927-198.730927 589.674146 0.499512c24.001561 0 43.507512-19.431024 43.40761-43.40761 0-24.101463-19.480976-43.63239-43.507512-43.63239l-592.221659-0.574439 201.378342-201.378341a45.980098 45.980098 0 0 0 0-65.161366 45.980098 45.980098 0 0 0-65.186342 0L131.29678 476.734439a45.955122 45.955122 0 0 0-13.53678 33.16761v0.574439c0 13.361951 5.994146 25.300293 15.409951 33.292488l274.307122 274.332097c8.99122 8.966244 20.804683 13.461854 32.593171 13.461854z" p-id="3403" fill="#505058"></path> </svg> <svg viewBox="0 0 18.33 18.33" style="width:20px;height:20px;margin-left:15px"> <g> <path style="fill:#323338;stroke-width:0" d="m9.17,18.33H.83c-.31,0-.59-.17-.74-.45-.14-.27-.12-.6.05-.86l1.66-2.41C.64,13.04,0,11.13,0,9.17,0,4.11,4.11,0,9.17,0s9.17,4.11,9.17,9.17-4.11,9.17-9.17,9.17Z"/> </g> </svg> <div style="display:grid;grid-template-columns:1fr 18px;align-items:center"> <div class="discord-thread-title">${threadtilte}</div> <svg width="18" height="18" fill="none" viewBox="0 0 24 24"> <path fill="currentColor" d="M9.3 5.3a1 1 0 0 0 0 1.4l5.29 5.3-5.3 5.3a1 1 0 1 0 1.42 1.4l6-6a1 1 0 0 0 0-1.4l-6-6a1 1 0 0 0-1.42 0Z" class=""></path> </svg> <div style="color:#5e5f63;margin-top:-3px">类脑ΟΔΥΣΣΕΙΑ</div> </div> </div> <div style="width:100%;height:1px;background-color:#d7d7d7"></div> <div style="width:100%;height:1px;background-color:#e3e3e3"></div> <div class="discord-scroll-container"> <div class="discord-thread-content"> <div style="background-color:#f2f3f5;display:flex;align-items:center;justify-content:center;border-radius:50%;width:64px;height:64px;margin-top:20px;margin-left:5px"> <svg viewBox="0 0 1024 1024" width="32" height="32"> <path fill="#050608" d="M524.531863 943.841235c-69.997795 0-137.060198-15.354355-199.606615-45.837266-15.354355-6.548181-91.674531-2.032194-162.575524 9.709372-11.515766 2.032194-23.483131-2.257993-31.160308-11.289967-7.677178-8.806174-10.16097-21.225138-6.548181-32.515105 15.805954-49.675854 26.192723-104.770893 22.805733-120.125248a452.434135 452.434135 0 0 1-78.35237-255.379052c0-251.088864 204.348401-455.437266 455.437265-455.437266S979.969129 237.315105 979.969129 488.403969 775.620728 943.841235 524.531863 943.841235z m-235.28291-116.512459c26.870121 0 50.804851 2.483793 65.481808 9.709372a382.955678 382.955678 0 0 0 169.801102 39.063285c213.831974 0 387.697464-173.865491 387.697464-387.697464S738.363837 100.706505 524.531863 100.706505 136.834399 274.571996 136.834399 488.403969c0 78.57817 23.483131 154.220948 67.739802 218.799559 17.16075 25.063727 11.289967 76.094377-0.903198 125.996031 27.095921-3.161191 58.03043-5.870783 85.57795-5.870783z m-140.672988-81.73936z"> </path> </svg> </div> <div class="discord-thread-content-title">${threadtilte}</div> <div class="discord-thread-content-tags"> ${tag} </div> <div class="discord-thread-content-original"> <div class="discord-thread-content-original-author-head head${isuser}" data-name="${name}"></div> <div> <div style="display:flex;align-items:center"> <div class="discord-thread-content-original-author-name discord-name-creator">${name}</div> </div> <div class="discord-thread-content-original-content">${content}</div> <div class="discord-card-fakeimg">${img}</div> </div> </div> </div> <div style="width:100%;height:1px;background-color:#d7d7d7"></div> <div style="width:100%;height:1px;background-color:#e3e3e3"></div> <div class="discord-thread-content"> <div style="width:100%;display:flex;align-items:center;margin-top:10px"> <div class="discord-thread-content-likes"> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 36 36" width="24" heigth="24"> <path fill="#FFDB5E" d="M34.956 17.916c0-.503-.12-.975-.321-1.404-1.341-4.326-7.619-4.01-16.549-4.221-1.493-.035-.639-1.798-.115-5.668.341-2.517-1.282-6.382-4.01-6.382-4.498 0-.171 3.548-4.148 12.322-2.125 4.688-6.875 2.062-6.875 6.771v10.719c0 1.833.18 3.595 2.758 3.885C8.195 34.219 7.633 36 11.238 36h18.044c1.838 0 3.333-1.496 3.333-3.334 0-.762-.267-1.456-.698-2.018 1.02-.571 1.72-1.649 1.72-2.899 0-.76-.266-1.454-.696-2.015 1.023-.57 1.725-1.649 1.725-2.901 0-.909-.368-1.733-.961-2.336.757-.611 1.251-1.535 1.251-2.581z"/> <path fill="#EE9547" d="M23.02 21.249h8.604c1.17 0 2.268-.626 2.866-1.633.246-.415.109-.952-.307-1.199-.415-.247-.952-.108-1.199.307-.283.479-.806.775-1.361.775h-8.81c-.873 0-1.583-.71-1.583-1.583s.71-1.583 1.583-1.583H28.7c.483 0 .875-.392.875-.875s-.392-.875-.875-.875h-5.888c-1.838 0-3.333 1.495-3.333 3.333 0 1.025.475 1.932 1.205 2.544-.615.605-.998 1.445-.998 2.373 0 1.028.478 1.938 1.212 2.549-.611.604-.99 1.441-.99 2.367 0 1.12.559 2.108 1.409 2.713-.524.589-.852 1.356-.852 2.204 0 1.838 1.495 3.333 3.333 3.333h5.484c1.17 0 2.269-.625 2.867-1.632.247-.415.11-.952-.305-1.199-.416-.245-.953-.11-1.199.305-.285.479-.808.776-1.363.776h-5.484c-.873 0-1.583-.71-1.583-1.583s.71-1.583 1.583-1.583h6.506c1.17 0 2.27-.626 2.867-1.633.247-.416.11-.953-.305-1.199-.419-.251-.954-.11-1.199.305-.289.487-.799.777-1.363.777h-7.063c-.873 0-1.583-.711-1.583-1.584s.71-1.583 1.583-1.583h8.091c1.17 0 2.269-.625 2.867-1.632.247-.415.11-.952-.305-1.199-.417-.246-.953-.11-1.199.305-.289.486-.799.776-1.363.776H23.02c-.873 0-1.583-.71-1.583-1.583s.709-1.584 1.583-1.584z"/> </svg> <div style="color:#5f606a">${likes}</div> </div> <div class="discord-thread-content-reaction" style="width:34px"> <svg class="icon_f8896c largeIcon_f8896c" aria-hidden="true" role="img" xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24"> <path fill="#5f606a" fill-rule="evenodd" d="M12 23a11 11 0 1 0 0-22 11 11 0 0 0 0 22ZM6.5 13a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3Zm11 0a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3Zm-9.8 1.17a1 1 0 0 1 1.39.27 3.5 3.5 0 0 0 5.82 0 1 1 0 0 1 1.66 1.12 5.5 5.5 0 0 1-9.14 0 1 1 0 0 1 .27-1.4Z" clip-rule="evenodd" class=""></path> </svg> </div> <div class="discord-thread-content-reaction" style="margin-left:auto"> <svg aria-hidden="true" width="18" height="18" fill="none" viewBox="0 0 24 24"> <path fill="#5f606a" d="M9.7 2.89c.18-.07.32-.24.37-.43a2 2 0 0 1 3.86 0c.05.2.19.36.38.43A7 7 0 0 1 19 9.5v2.09c0 .12.05.24.13.33l1.1 1.22a3 3 0 0 1 .77 2.01v.28c0 .67-.34 1.29-.95 1.56-1.31.6-4 1.51-8.05 1.51-4.05 0-6.74-.91-8.05-1.5-.61-.28-.95-.9-.95-1.57v-.28a3 3 0 0 1 .77-2l1.1-1.23a.5.5 0 0 0 .13-.33V9.5a7 7 0 0 1 4.7-6.61ZM9.18 19.84A.16.16 0 0 0 9 20a3 3 0 1 0 6 0c0-.1-.09-.17-.18-.16a24.86 24.86 0 0 1-5.64 0Z" class=""></path> </svg> <div style="color:#5f606a;margin-right:1px">关注</div> </div> <div class="discord-thread-content-reaction" style="width:34px"> <svg aria-hidden="true" role="img" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none" viewBox="0 0 24 24"> <path fill="#5f606a" d="M16.32 14.72a1 1 0 0 1 0-1.41l2.51-2.51a3.98 3.98 0 0 0-5.62-5.63l-2.52 2.51a1 1 0 0 1-1.41-1.41l2.52-2.52a5.98 5.98 0 0 1 8.45 8.46l-2.52 2.51a1 1 0 0 1-1.41 0ZM7.68 9.29a1 1 0 0 1 0 1.41l-2.52 2.51a3.98 3.98 0 1 0 5.63 5.63l2.51-2.52a1 1 0 0 1 1.42 1.42l-2.52 2.51a5.98 5.98 0 0 1-8.45-8.45l2.51-2.51a1 1 0 0 1 1.42 0Z" class=""></path> <path fill="#5f606a" d="M14.7 10.7a1 1 0 0 0-1.4-1.4l-4 4a1 1 0 1 0 1.4 1.4l4-4Z" class=""> </path> </svg> </div> </div> </div> <div style="width:100%;height:3px;background-color:#f2f3f5;margin-top:10px"></div> <div style="width:100%;height:2px;background-color:#f0f4f7"></div> <div style="width:100%;height:3px;background-color:#f2f3f5"></div> <div class="discord-thread-comment-list"> </div> </div> <div class="discord-thread-input"> <div class="discord-thread-input-button"> <div style="display:flex;align-items:center;gap:5px;height:30px"> <div class="discord-thread-input-svgbackground"> <svg t="1744279170454" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2274" width="32" height="32"> <path d="M836 476H548V188c0-19.8-16.2-36-36-36s-36 16.2-36 36v288H188c-19.8 0-36 16.2-36 36s16.2 36 36 36h288v288c0 19.8 16.2 36 36 36s36-16.2 36-36V548h288c19.8 0 36-16.2 36-36s-16.2-36-36-36z" fill="#333333" p-id="2275"></path> </svg> </div> <div class="discord-thread-input-svgbackground"> <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 96 96" width="28" height="28" preserveAspectRatio="xMidYMid meet" style="transform:translate3d(0,0,0);content-visibility:visible"> <defs> <clipPath id="__lottie_element_2133"> <rect width="96" height="96" x="0" y="0"></rect> </clipPath> <clipPath id="__lottie_element_2135"> <path d="M0,0 L96,0 L96,96 L0,96z"></path> </clipPath> </defs> <g clip-path="url(#__lottie_element_2133)"> <g clip-path="url(#__lottie_element_2135)" transform="matrix(2.700000047683716,0,0,2.700000047683716,-79.60000610351562,-81.35110473632812)" opacity="1" style="display:block"> <g transform="matrix(0.9999997019767761,0,0,0.9999997019767761,32.022003173828125,32.64699935913086)" opacity="1" style="display:block"> <g opacity="1" transform="matrix(1,0,0,1,7.179999828338623,7.181000232696533)"> <path fill="#333333" fill-opacity="1" d=" M-6.554999828338623,1.6410000324249268 C-6.929999828338623,3.0420000553131104 -6.099999904632568,4.480999946594238 -4.698999881744385,4.85699987411499 C-4.698999881744385,4.85699987411499 1.6410000324249268,6.554999828338623 1.6410000324249268,6.554999828338623 C3.0409998893737793,6.931000232696533 4.48199987411499,6.098999977111816 4.85699987411499,4.698999881744385 C4.85699987411499,4.698999881744385 6.554999828338623,-1.6410000324249268 6.554999828338623,-1.6410000324249268 C6.929999828338623,-3.0420000553131104 6.098999977111816,-4.480999946594238 4.698999881744385,-4.85699987411499 C4.698999881744385,-4.85699987411499 -1.6410000324249268,-6.556000232696533 -1.6410000324249268,-6.556000232696533 C-3.0409998893737793,-6.931000232696533 -4.48199987411499,-6.099999904632568 -4.85699987411499,-4.698999881744385 C-4.85699987411499,-4.698999881744385 -6.554999828338623,1.6410000324249268 -6.554999828338623,1.6410000324249268z"> </path> </g> </g> <g transform="matrix(1,0,0,1,47.44300079345703,32.419002532958984)" opacity="1" style="display:block"> <g opacity="1" transform="matrix(1,0,0,1,7.802000045776367,7.021999835968018)"> <path fill="#333333" fill-opacity="1" d=" M-6.478000164031982,2.4040000438690186 C-7.552000045776367,4.372000217437744 -6.126999855041504,6.771999835968018 -3.884999990463257,6.771999835968018 C-3.884999990463257,6.771999835968018 3.885999917984009,6.771999835968018 3.885999917984009,6.771999835968018 C6.127999782562256,6.771999835968018 7.552000045776367,4.372000217437744 6.479000091552734,2.4040000438690186 C6.479000091552734,2.4040000438690186 2.5929999351501465,-4.718999862670898 2.5929999351501465,-4.718999862670898 C1.4739999771118164,-6.771999835968018 -1.4730000495910645,-6.771999835968018 -2.5929999351501465,-4.718999862670898 C-2.5929999351501465,-4.718999862670898 -6.478000164031982,2.4040000438690186 -6.478000164031982,2.4040000438690186z"> </path> </g> </g> <g transform="matrix(1,0,0,1,32.119998931884766,49.04499816894531)" opacity="1" style="display:block"> <g opacity="1" transform="matrix(1,0,0,1,7.081999778747559,7.046999931335449)"> <path fill="#333333" fill-opacity="1" d=" M-0.9409999847412109,-6.26800012588501 C-0.42100000381469727,-6.796999931335449 0.41999998688697815,-6.796999931335449 0.9409999847412109,-6.26800012588501 C0.9409999847412109,-6.26800012588501 2.056999921798706,-5.132999897003174 2.056999921798706,-5.132999897003174 C2.2699999809265137,-4.916999816894531 2.5480000972747803,-4.78000020980835 2.8459999561309814,-4.744999885559082 C2.8459999561309814,-4.744999885559082 4.4120001792907715,-4.561999797821045 4.4120001792907715,-4.561999797821045 C5.140999794006348,-4.4770002365112305 5.665999889373779,-3.805999994277954 5.585000038146973,-3.061000108718872 C5.585000038146973,-3.061000108718872 5.410999774932861,-1.4630000591278076 5.410999774932861,-1.4630000591278076 C5.377999782562256,-1.1579999923706055 5.447000026702881,-0.8510000109672546 5.605999946594238,-0.5910000205039978 C5.605999946594238,-0.5910000205039978 6.441999912261963,0.7720000147819519 6.441999912261963,0.7720000147819519 C6.831999778747559,1.406999945640564 6.644999980926514,2.24399995803833 6.0229997634887695,2.6440000534057617 C6.0229997634887695,2.6440000534057617 4.690999984741211,3.502000093460083 4.690999984741211,3.502000093460083 C4.436999797821045,3.6649999618530273 4.24399995803833,3.9119999408721924 4.144000053405762,4.201000213623047 C4.144000053405762,4.201000213623047 3.621000051498413,5.7179999351501465 3.621000051498413,5.7179999351501465 C3.378000020980835,6.423999786376953 2.619999885559082,6.796999931335449 1.9259999990463257,6.551000118255615 C1.9259999990463257,6.551000118255615 0.43799999356269836,6.021999835968018 0.43799999356269836,6.021999835968018 C0.15399999916553497,5.921999931335449 -0.1550000011920929,5.921999931335449 -0.43799999356269836,6.021999835968018 C-0.43799999356269836,6.021999835968018 -1.9270000457763672,6.551000118255615 -1.9270000457763672,6.551000118255615 C-2.619999885559082,6.796999931335449 -3.378000020980835,6.423999786376953 -3.621999979019165,5.7179999351501465 C-3.621999979019165,5.7179999351501465 -4.144999980926514,4.201000213623047 -4.144999980926514,4.201000213623047 C-4.24399995803833,3.9119999408721924 -4.436999797821045,3.6649999618530273 -4.690999984741211,3.502000093460083 C-4.690999984741211,3.502000093460083 -6.02400016784668,2.6440000534057617 -6.02400016784668,2.6440000534057617 C-6.644999980926514,2.24399995803833 -6.831999778747559,1.406999945640564 -6.442999839782715,0.7720000147819519 C-6.442999839782715,0.7720000147819519 -5.605999946594238,-0.5910000205039978 -5.605999946594238,-0.5910000205039978 C-5.447000026702881,-0.8510000109672546 -5.377999782562256,-1.1579999923706055 -5.4120001792907715,-1.4630000591278076 C-5.4120001792907715,-1.4630000591278076 -5.585000038146973,-3.061000108718872 -5.585000038146973,-3.061000108718872 C-5.665999889373779,-3.805999994277954 -5.142000198364258,-4.4770002365112305 -4.4120001792907715,-4.561999797821045 C-4.4120001792907715,-4.561999797821045 -2.8469998836517334,-4.744999885559082 -2.8469998836517334,-4.744999885559082 C-2.5480000972747803,-4.78000020980835 -2.2699999809265137,-4.916999816894531 -2.056999921798706,-5.132999897003174 C-2.056999921798706,-5.132999897003174 -0.9409999847412109,-6.26800012588501 -0.9409999847412109,-6.26800012588501z"> </path> </g> </g> <g transform="matrix(-0.9999998211860657,0,0,-0.9999998211860657,62.69399642944336,63.31999969482422)" opacity="1" style="display:block"> <g opacity="1" transform="matrix(1,0,0,1,7.247000217437744,7.247000217437744)"> <path fill="#333333" fill-opacity="1" d=" M1.5130000114440918,-5.5920000076293945 C0.9929999709129333,-6.997000217437744 -0.9940000176429749,-6.997000217437744 -1.5140000581741333,-5.5920000076293945 C-1.5140000581741333,-5.5920000076293945 -2.190999984741211,-3.760999917984009 -2.190999984741211,-3.760999917984009 C-2.4600000381469727,-3.0339999198913574 -3.0339999198913574,-2.4600000381469727 -3.76200008392334,-2.190999984741211 C-3.76200008392334,-2.190999984741211 -5.5920000076293945,-1.5130000114440918 -5.5920000076293945,-1.5130000114440918 C-6.997000217437744,-0.9940000176429749 -6.997000217437744,0.9929999709129333 -5.5920000076293945,1.5130000114440918 C-5.5920000076293945,1.5130000114440918 -3.76200008392334,2.190999984741211 -3.76200008392334,2.190999984741211 C-3.0339999198913574,2.4600000381469727 -2.4600000381469727,3.0339999198913574 -2.190999984741211,3.760999917984009 C-2.190999984741211,3.760999917984009 -1.5140000581741333,5.5920000076293945 -1.5140000581741333,5.5920000076293945 C-0.9940000176429749,6.997000217437744 0.9929999709129333,6.997000217437744 1.5130000114440918,5.5920000076293945 C1.5130000114440918,5.5920000076293945 2.190000057220459,3.760999917984009 2.190000057220459,3.760999917984009 C2.4600000381469727,3.0339999198913574 3.0329999923706055,2.4600000381469727 3.760999917984009,2.190999984741211 C3.760999917984009,2.190999984741211 5.5920000076293945,1.5130000114440918 5.5920000076293945,1.5130000114440918 C6.997000217437744,0.9929999709129333 6.997000217437744,-0.9940000176429749 5.5920000076293945,-1.5130000114440918 C5.5920000076293945,-1.5130000114440918 3.760999917984009,-2.190999984741211 3.760999917984009,-2.190999984741211 C3.0329999923706055,-2.4600000381469727 2.4600000381469727,-3.0339999198913574 2.190000057220459,-3.760999917984009 C2.190000057220459,-3.760999917984009 1.5130000114440918,-5.5920000076293945 1.5130000114440918,-5.5920000076293945z"> </path> </g> </g> </g> </g> </svg> </div> <div class="discord-thread-input-svgbackground"> <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24" width="30" height="30" preserveAspectRatio="xMidYMid meet" style="transform:translate3d(0,0,0);content-visibility:visible"> <defs> <clipPath id="__lottie_element_2044"> <rect width="24" height="24" x="0" y="0"></rect> </clipPath> <clipPath id="__lottie_element_2046"> <path d="M0,0 L600,0 L600,600 L0,600z"></path> </clipPath> </defs> <g clip-path="url(#__lottie_element_2044)"> <g clip-path="url(#__lottie_element_2046)" transform="matrix(0.03999999910593033,0,0,0.03999999910593033,0,0)" opacity="1" style="display:block"> <g transform="matrix(25,0,0,25,300,300)" opacity="1" style="display:block"> <g opacity="1" transform="matrix(1,0,0,1,0,0)"> <path fill="#333333" fill-opacity="1" d=" M-7,10 C-8.104999542236328,10 -9,9.104999542236328 -9,8 C-9,8 -9,2.5 -9,2.5 C-9,2.2239999771118164 -8.776000022888184,2 -8.5,2 C-8.5,2 -1.5,2 -1.5,2 C-1.2239999771118164,2 -1,2.2239999771118164 -1,2.5 C-1,2.5 -1,9.5 -1,9.5 C-1,9.776000022888184 -1.2239999771118164,10 -1.5,10 C-1.5,10 -7,10 -7,10z M1,9.5 C1,9.776000022888184 1.2239999771118164,10 1.5,10 C1.5,10 7,10 7,10 C8.104999542236328,10 9,9.104999542236328 9,8 C9,8 9,2.5 9,2.5 C9,2.2239999771118164 8.776000022888184,2 8.5,2 C8.5,2 1.5,2 1.5,2 C1.2239999771118164,2 1,2.2239999771118164 1,2.5 C1,2.5 1,9.5 1,9.5z"> </path> </g> </g> <g transform="matrix(25,0,0,25,300,300)" opacity="1" style="display:block"> <g opacity="1" transform="matrix(1,0,0,1,0,0)"> <path fill="#333333" fill-opacity="1" d=" M-10,-2 C-10,-3.1050000190734863 -9.104999542236328,-4 -8,-4 C-8,-4 8,-4 8,-4 C9.104999542236328,-4 10,-3.1050000190734863 10,-2 C10,-2 10,-0.5 10,-0.5 C10,-0.2240000069141388 9.776000022888184,0 9.5,0 C9.5,0 -9.5,0 -9.5,0 C-9.776000022888184,0 -10,-0.2240000069141388 -10,-0.5 C-10,-0.5 -10,-2 -10,-2z"> </path> </g> </g> <g transform="matrix(25,0,0,25,300,300)" opacity="1" style="display:block"> <path stroke-linecap="butt" stroke-linejoin="round" fill-opacity="0" stroke="#333333" stroke-opacity="1" stroke-width="2" d=" M7,-6 C7,-7.6570000648498535 5.6570000648498535,-9 4,-9 C4,-9 3.9110000133514404,-9 3.9110000133514404,-9 C2.49399995803833,-9 1.2589999437332153,-8.03600025177002 0.9150000214576721,-6.660999774932861 C0.9150000214576721,-6.660999774932861 0,-3 0,-3 C0,-3 4,-3 4,-3 C5.6570000648498535,-3 7,-4.3429999351501465 7,-6 C7,-6 7,-6 7,-6z"> </path> <g opacity="1" transform="matrix(1,0,0,1,0,0)"></g> </g> <g transform="matrix(25,0,0,25,300,300)" opacity="1" style="display:block"> <path stroke-linecap="butt" stroke-linejoin="round" fill-opacity="0" stroke="#333333" stroke-opacity="1" stroke-width="2" d=" M-7,-6 C-7,-7.6570000648498535 -5.6570000648498535,-9 -4,-9 C-4,-9 -3.9110000133514404,-9 -3.9110000133514404,-9 C-2.49399995803833,-9 -1.2589999437332153,-8.03600025177002 -0.9150000214576721,-6.660999774932861 C-0.9150000214576721,-6.660999774932861 0,-3 0,-3 C0,-3 -4,-3 -4,-3 C-5.6570000648498535,-3 -7,-4.3429999351501465 -7,-6 C-7,-6 -7,-6 -7,-6z"> </path> <g opacity="1" transform="matrix(1,0,0,1,0,0)"></g> </g> </g> </g> </svg> </div> </div> </div> <div class="discord-thread-input-focus-button" style="display:none"> <svg width="24" height="24" fill="none" viewBox="0 0 24 24" style="margin-top:2px"> <path fill="#5f606a" d="M9.3 5.3a1 1 0 0 0 0 1.4l5.29 5.3-5.3 5.3a1 1 0 1 0 1.42 1.4l6-6a1 1 0 0 0 0-1.4l-6-6a1 1 0 0 0-1.42 0Z" class=""></path> </svg> </div> <div style="display:flex;align-items:center;flex:1;min-width:50px;background-color:#ececec;border-radius:24px;height:35px"> <input class="discord-thread-input-userinput" type="text" placeholder=\'在"${threadtilte}"中发送一则消息\'> <svg style="margin-right:8px" aria-hidden="true" role="img" xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24"> <path fill="#5f606a" fill-rule="evenodd" d="M12 23a11 11 0 1 0 0-22 11 11 0 0 0 0 22ZM6.5 13a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3Zm11 0a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3Zm-9.8 1.17a1 1 0 0 1 1.39.27 3.5 3.5 0 0 0 5.82 0 1 1 0 0 1 1.66 1.12 5.5 5.5 0 0 1-9.14 0 1 1 0 0 1 .27-1.4Z" clip-rule="evenodd" class=""></path> </svg> </div> <div class="discord-thread-input-svgbackground"> <svg viewBox="0 0 1024 1024" width="32" height="32" class="discord-thread-input-button"> <path d="M511.752 70.5c-86.605 0-156.835 69.734-156.835 155.747l0 273.812c0 86.013 70.23 155.748 156.835 155.748 86.602 0 156.832-69.735 156.832-155.748L668.584 226.247C668.584 140.234 598.354 70.5 511.752 70.5L511.752 70.5 511.752 70.5zM243.854 461.102c-18.051 0-32.649 14.496-32.649 32.451 0 2.269 0.197 4.436 0.689 6.506l-0.689 0c0 151.605 113.922 276.578 261.386 295.713l0 80.687-52.275 0c-21.702 0-39.257 17.458-39.257 38.964 0 21.499 17.555 38.957 39.257 38.957l182.969 0c21.701 0 39.256-17.458 39.256-38.957 0-21.506-17.555-38.964-39.256-38.964L551.01 876.459l0-80.687c143.119-18.543 254.383-137.002 260.691-282.688 0.396-2.072 0.695-4.243 0.695-6.512 0-0.79-0.197-1.479-0.197-2.167 0-1.483 0.197-2.86 0.197-4.345l-0.695 0c-3.058-14.795-16.172-25.94-32.057-25.94-15.782 0-28.999 11.145-32.057 25.94l-0.688 0c0 129.019-105.344 233.572-235.249 233.572-129.903 0-235.249-104.554-235.249-233.572l-0.689 0c0.396-2.07 0.689-4.237 0.689-6.506C276.503 475.598 261.906 461.102 243.854 461.102L243.854 461.102 243.854 461.102zM243.854 461.102" fill="#333333" p-id="3351"></path> </svg> <svg class="discord-thread-input-focus-button discord_thread-input-sendbutton" style="width:100%;height:100%;display:none" id="_图层_2" data-name="图层 2" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 161.74 161.74"> <defs> <style>.cls-1{fill:#5865f1}.cls-1,.cls-2{stroke-width:0}.cls-2{fill:#fff}</style> </defs> <g id="_图层_1-2" data-name="图层 1"> <circle class="cls-1" cx="80.87" cy="80.87" r="80.87"/> </g> <g id="_图层_2-2" data-name="图层 2"> <path class="cls-2" d="m127.88,79.87c0-2.3-1.22-4.6-3.66-5.73L52.7,39.96c-3.5-1.84-7.33,1.81-5.67,5.39l10.16,25.41c.37.96,1.2,1.68,2.21,1.91l30.68,5.54c.93.17,1.39.92,1.39,1.67s-.46,1.5-1.39,1.67l-30.68,5.54c-1.01.23-1.84.94-2.21,1.91l-10.16,25.41c-1.67,3.58,2.17,7.23,5.67,5.39l71.53-34.18c2.44-1.13,3.66-3.43,3.66-5.73Z"/> </g> </svg> </div> </div> </div>';
            // Exports
            /* harmony default export */ var discord_discord_thread =
                discord_thread_code; // ./src/界面/discord/discord_thread_comment.html
            // Module
            var discord_thread_comment_code =
                '<div class="discord-thread-comment"> <div class="discord-thread-comment-head head${isuser}" data-name="${name}"></div> <div> <div class="discord-thread-comment-name${creator}">${name}</div> <div class="discord-thread-comment-content">${content}</div> </div> </div>';
            // Exports
            /* harmony default export */ var discord_discord_thread_comment =
                discord_thread_comment_code; // ./src/界面/worldbook/1-格式开头.txt?raw
            var _1_raw_namespaceObject =
                "<线上格式>\r\n当用户要求查看内容时,仅输出对应格式,禁止输出剧情旁白\r\n以下是各格式具体介绍"; // ./src/界面/worldbook/2-QQ聊天.txt?raw
            var _2_QQ_raw_namespaceObject =
                "<QQ聊天格式介绍>\r\n格式示例如:\r\nmsg_start\r\n<{{user}}和xxx的私聊>\r\n发言人--内容--HH:MM\r\n发言人--特殊消息类型--HH:MM\r\n</{{user}}和xxx的私聊>\r\n\r\n<群聊:群名字>\r\n<成员>成员A,成员B</成员>\r\n<聊天内容>\r\n发言人--内容--HH:MM\r\n发言人--特殊消息类型--HH:MM\r\n</聊天内容>\r\n</群聊:群名字>\r\n\r\nmsg_end\r\n\r\n特殊消息类型:\r\n\r\n【表情包相关】\r\n角色会根据当前情绪和对话内容使用适当的表情包：\r\n- 表情包的选择应当符合角色当前心理和角色性格\r\n- 表情包使用频率应适中，平均每3-5条消息可使用一次\r\n- 输出格式为[bqb-表情包内容]（仅使用列表中存在的表情包，不可自创或篡改）\r\n- 表情包作为独立的一条消息，一条消息只能包含一个表情包\r\n- 示例:路人a--[bqb-摸小猫下巴]--12:00\r\n<表情包列表>\r\n\r\n</表情包列表>\r\n\r\n【转账消息相关】\r\n- 格式：[zz-金额元]\r\n- 必须独立成行，示例：路人a--[zz-520元]--12:00\r\n- 可用范围：仅私聊\r\n- 不可用范围：群聊，QQ空间\r\n\r\n【语音消息相关】\r\n- 格式：[yy-语音内容]\r\n- 必须独立成行，示例：路人a--[yy-想你了]--12:00\r\n- 可用范围：私聊，群聊\r\n- 不可用范围：QQ空间\r\n\r\n【音乐分享消息相关】\r\n- 格式：[music-歌名$歌手]\r\n- 必须独立成行，示例：路人a--[music-富士山下$陈奕迅]--12:00\r\n- 可用范围：私聊，群聊\r\n- 不可用范围：QQ空间\r\n\r\n【图片或视频消息相关】\r\n- 格式：[img-内容]\r\n- 示例：路人a--[img-一张自拍]--12:00\r\n- 可用范围：私聊，群聊，QQ空间\r\n- 在群聊和私聊时必须独立成行\r\n- 在QQ空间时前面可带其他文字内容\r\n- 注意：图片和视频都是使用这个格式\r\n\r\n格式解释:\r\n私聊：{{user}}和对方的私聊,聊天内容只有双方知道,标签名字顺序一定是{{user}}和xxx的私聊,而不是xxx和{{user}}的私聊\r\n群聊：包含多个成员的群组对话，所有群成员可见消息\r\n确保私聊和群聊的标签闭合\r\n特殊消息类型：聊天过程中可使用的消息类型,前后依然要加发言人和时间\r\n发言内容中如果需要换行,使用<br>\r\n若群聊中需要生成一些随机路人,禁止使用路人A,匿名用户等敷衍网名\r\n格式前后带上msg_start和msg_end标识符\r\n请勿生成多个msg_start,msg_end标识\r\n\r\n</QQ聊天格式介绍>"; // ./src/界面/worldbook/3-QQ空间.txt?raw
            var _3_QQ_raw_namespaceObject =
                '<QQ空间格式介绍>\r\n\r\n{{user}}和角色名都会使用聊天软件QQ\r\nQQ空间是聊天软件QQ中带的一个个人空间,可以在里面发布动态,所有人都能看到\r\n\r\n输出格式:\r\nmoment_start\r\n发言人--发言内容--发言时间--已浏览人数--已点赞人数\r\n发言人--评论内容\r\n发言人--评论内容\r\n发言人--发言内容--发言时间--已浏览人数--已点赞人数\r\n发言人--评论内容\r\n发言人--评论内容\r\nmoment_end\r\n\r\n【动态评论系统说明】\r\n1. 当用户在动态下评论时，联系人都能看到这条动态和评论\r\n2. **重要规则：必须有至少1名角色在动态下回应，动态发布者优先级最高**\r\n3. 联系人回应方式优先级（因为动态是公开的）：\r\n   - **优先推荐**: 私聊用户深入讨论相关话题（更私密、更深入）\r\n   - **推荐**: 在群聊中@用户提及此事（引起更多讨论）\r\n   - **必须保证**: 至少在动态下有1条评论回复（简短回应）\r\n4. 评论显示上限为8条，超出自动折叠最早评论\r\n5. 系统会智能判断哪些角色会对特定动态感兴趣\r\n6. **角色回应优先级**：\r\n   - **最高优先**：动态发布者本人（必须回应用户评论）\r\n   - **高优先**：与用户关系亲密的角色\r\n   - **中优先**：对该话题感兴趣的角色\r\n   - **低优先**：其他在线角色\r\n7. **关系亲密度影响回应方式**：\r\n   - 亲密关系→优先私聊深入交流，同时在动态简短回应\r\n   - 一般关系→群聊中@用户讨论，或在动态回应\r\n   - 陌生关系→动态下简单评论\r\n\r\n【角色回应指导】\r\n- 性格外向/好奇的角色更容易主动回应评论\r\n- 与用户关系亲密的角色优先私聊讨论\r\n- 共同兴趣话题的角色更可能参与评论\r\n- 群聊活跃的角色倾向于在群里@用户讨论\r\n- 内向/冷淡的角色可能选择不回应\r\n\r\nQQ空间仅会有主要角色发布的动态,不会有路人动态\r\n发言内容中如果需要换行,使用<br>\r\n动态如果有配图,使用[img-内容]这个格式\r\n如{{user}}--我好看吗[img-一张自拍]--12:00--67--32\r\n但是角色发布的动态可以有路人参与评论\r\n路人必须生成具体网名,不可以使用"匿名网友"之类敷衍名字\r\n每条动态2-4条评论\r\n使用moment_start和moment_end标识符包裹\r\n请勿生成多个moment_start,moment_end标识\r\n\r\n</QQ空间格式介绍>'; // ./src/界面/worldbook/4-discord论坛.txt?raw
            var _4_discord_raw_namespaceObject =
                '<discord论坛格式介绍>\r\ndiscord帖子按以下格式输出:\r\n\r\ndiscord_start\r\n<随机六位数字字母>/* 此处仅生成六位数字字母替代被<>包裹的文本内容 */\r\n<正文>\r\n发帖人:\r\n帖子标题:\r\n帖子正文:\r\n帖子配图描述:\r\n帖子标签:\r\n距离发帖过去时间:\r\n帖子总评论数:\r\n帖子总点赞数:\r\n</正文>\r\n<评论>\r\n评论人--评论内容\r\n评论人--评论内容\r\n评论人--评论内容\r\n</评论>\r\n</随机六位数字字母>/* 此处仅生成六位数字字母 */ \r\ndiscord_end\r\n\r\n参考示例:\r\ndiscord_start\r\n<j324na>/* 此处仅生成六位数字字母替代被<>包裹的文本内容 */\r\n<正文>\r\n发帖人:柏柏\r\n帖子标题:4.8修bug 多人带群聊的同层手机界面\r\n帖子正文:正文内容\r\n帖子配图描述:界面的截图\r\n帖子标签:前端/UI美化\r\n距离发帖过去时间:2小时前\r\n帖子总评论数:9999\r\n帖子总点赞数:308\r\n</正文>\r\n<评论>\r\n唐初稚--伟大!\r\n</评论>\r\n</j324na>/* 此处仅生成六位数字字母 */\r\n<jtsn65>/* 此处仅生成六位数字字母替代被<>包裹的文本内容 */\r\n<正文>\r\n发帖人:本熊本的熊本熊\r\n帖子标题:我们是正经搞学术的，信我\r\n帖子正文:正文内容\r\n帖子配图描述:是一张配图\r\n帖子标签:聊天\r\n距离发帖过去时间:2小时前\r\n帖子总评论数:9999\r\n帖子总点赞数:308\r\n</正文>\r\n<评论>\r\n阿瓜--伟大!\r\n雀里--伟大!\r\n</评论>\r\n</jtsn65>/* 此处仅生成六位数字字母 */\r\ndiscord_end\r\n\r\n发帖人和评论人既可以是主要角色,也可以是路人\r\n每次生成帖子应有8到10个人回复\r\n路人必须生成具体网名,不可以使用"匿名网友"之类敷衍名字\r\n帖子有多个标签使用/分割\r\n内容如果需要换行使用<br>\r\n\r\n必须有MiPhone_start<br />discord_start包裹和discord_end<br />MiPhone_end包裹\r\n请勿生成多个discord_start,discord_end标识\r\n\r\n</discord论坛格式介绍>'; // ./src/界面/worldbook/999-格式结尾.txt?raw
            var _999_raw_namespaceObject =
                "以上格式必须全部一起包裹在MiPhone_start和MiPhone_end标识符里\r\n且要确保以下几点:\r\n1. 确保本轮回复中只存在一个MiPhone格式！\r\n2. 确保不同角色的聊天和群聊记录都位于同一个MiPhone格式中！\r\n3. 确保不在MiPhone格式内输出角色心理或旁白内容！\r\n4. **以MiPhone_end标识符收尾**\r\n\r\n[手机正确格式]\r\nMiPhone_start /* 此处必须完整生成所有字符 */\r\n此处为具体数据\r\n此处为更详细的数据\r\nMiPhone_end /* 此处必须完整生成所有字符 */\r\n\r\n</线上格式>"; // ./src/界面/worldbook/worldlist.txt?raw
            var worldlistraw_namespaceObject =
                "[手机-格式1-格式开头]\r\n深度=0\r\n类型=绿灯\r\n覆盖=真\r\n关键词=/查看(.+?)消息/, 发送消息, 回复, /给(.+?)发消息/, 在群聊, 动态, 空间, discord, dc, 论坛, 帖子, QQ, qq, 手机\r\n顺序=5560\r\n[手机-格式2-QQ聊天]\r\n深度=0\r\n类型=绿灯\r\n覆盖=真\r\n关键词=/查看(.+?)消息/, 发送消息, 回复, /给(.+?)发消息/, 在群聊, 动态, 空间, discord, dc, 论坛, 帖子, QQ, qq, 手机\r\n顺序=5561\r\n[手机-格式3-QQ空间]\r\n深度=0\r\n类型=绿灯\r\n覆盖=真\r\n关键词=动态, 空间\r\n顺序=5562\r\n[手机-格式4-discord论坛]\r\n深度=0\r\n类型=绿灯\r\n覆盖=真\r\n关键词=discord, dc, 论坛, 帖子\r\n顺序=5563\r\n[手机-格式999-格式结尾]\r\n深度=0\r\n类型=绿灯\r\n覆盖=真\r\n关键词=/查看(.+?)消息/, 发送消息, 回复, /给(.+?)发消息/, 在群聊, 动态, 空间, discord, dc, 论坛, 帖子, QQ, qq, 手机\r\n顺序=5564\r\n[手机-界面基本设置]\r\n深度=0\r\n类型=绿灯\r\n覆盖=假\r\n关键词=此世界书永不触发\r\n顺序=100\r\n[手机-角色]\r\n深度=0\r\n类型=绿灯\r\n覆盖=假\r\n关键词=此世界书永不触发\r\n顺序=100\r\n[手机-随机头像]\r\n深度=0\r\n类型=绿灯\r\n覆盖=假\r\n关键词=此世界书永不触发\r\n顺序=100\r\n[手机-表情包存放]\r\n深度=0\r\n类型=绿灯\r\n覆盖=假\r\n关键词=此世界书永不触发\r\n顺序=100"; // ./src/界面/worldbook/随机头像.txt?raw
            var _raw_namespaceObject =
                "http://sharkpan.xyz/f/EJeUD/Image_1737026320652.jpg\r\nhttp://sharkpan.xyz/f/Y8pt1/Image_1737026296736.jpg\r\nhttp://sharkpan.xyz/f/QWWc6/Image_1737026308451.jpg\r\nhttp://sharkpan.xyz/f/Z8LIW/Image_1737026306601.jpg\r\nhttp://sharkpan.xyz/f/W8lhW/Image_1737026313246.jpg\r\nhttp://sharkpan.xyz/f/0rJtX/Image_1737026292787.jpg\r\nhttp://sharkpan.xyz/f/yVxsN/Image_1737026293840.jpg\r\nhttp://sharkpan.xyz/f/vaBCL/Image_1737026286979.jpg\r\nhttp://sharkpan.xyz/f/pZ6hQ/Image_1737026285632.jpg\r\nhttp://sharkpan.xyz/f/11AH2/Image_1737026284351.jpg\r\nhttp://sharkpan.xyz/f/eXKUw/Image_1737026281715.jpg\r\nhttp://sharkpan.xyz/f/o31F4/Image_1737026277201.jpg\r\nhttp://sharkpan.xyz/f/8E2uj/Image_1737026279242.jpg\r\nhttp://sharkpan.xyz/f/GLmIl/Image_1737026275069.jpg\r\nhttp://sharkpan.xyz/f/zWZT5/Image_1737026271769.jpg\r\nhttp://sharkpan.xyz/f/7Zrij/Image_1737026269532.jpg\r\nhttp://sharkpan.xyz/f/AqYsZ/Image_1737026266131.jpg\r\nhttp://sharkpan.xyz/f/w4lFq/2406563368.jpeg\r\nhttp://sharkpan.xyz/f/MQNua/2403629154.jpeg\r\nhttp://sharkpan.xyz/f/3YZhe/2405854911.jpeg\r\nhttp://sharkpan.xyz/f/5QKhj/2312445144.jpeg\r\nhttp://sharkpan.xyz/f/k6JT6/2408434848.jpeg\r\nhttp://sharkpan.xyz/f/j6Bf6/2386328773.jpeg\r\nhttp://sharkpan.xyz/f/a8LHY/2386327598.jpeg\r\nhttp://sharkpan.xyz/f/r08C6/2386327604.jpeg\r\nhttp://sharkpan.xyz/f/DgECK/2331678725.jpeg\r\nhttp://sharkpan.xyz/f/LJrC7/2371251634.jpeg\r\nhttp://sharkpan.xyz/f/q1LF3/2329660869.gif\r\nhttp://sharkpan.xyz/f/X84sW/2328035526.jpeg\r\nhttp://sharkpan.xyz/f/2eDfQ/2326662447.jpeg\r\nhttp://sharkpan.xyz/f/ggetw/2326683821.jpeg\r\nhttp://sharkpan.xyz/f/J21ig/2323432137.gif\r\nhttp://sharkpan.xyz/f/BZjSa/%E5%A4%B4%E5%83%8F%20%282%29.jpg\r\nhttp://sharkpan.xyz/f/4rXIj/%E5%A4%B4%E5%83%8F%20%283%29.jpg\r\nhttp://sharkpan.xyz/f/Ndyhv/%E5%A4%B4%E5%83%8F%20%281%29.jpg\r\nhttp://sharkpan.xyz/f/VyJTY/%E5%A4%B4%E5%83%8F%20%284%29.jpg\r\nhttp://sharkpan.xyz/f/xlAhX/%E5%A4%B4%E5%83%8F%20%2820%29.jpg\r\nhttp://sharkpan.xyz/f/dDMI8/%E5%A4%B4%E5%83%8F%20%285%29.jpg\r\nhttp://sharkpan.xyz/f/lm7hx/%E5%A4%B4%E5%83%8F%20%286%29.jpg\r\nhttp://sharkpan.xyz/f/KkeHo/%E5%A4%B4%E5%83%8F%20%287%29.jpg\r\nhttp://sharkpan.xyz/f/EeZSD/%E5%A4%B4%E5%83%8F%20%288%29.jpg\r\nhttp://sharkpan.xyz/f/YyAi1/%E5%A4%B4%E5%83%8F%20%289%29.jpg\r\nhttp://sharkpan.xyz/f/QdaU6/%E5%A4%B4%E5%83%8F%20%2810%29.jpg\r\nhttp://sharkpan.xyz/f/ZKBuW/%E5%A4%B4%E5%83%8F%20%2811%29.jpg\r\nhttp://sharkpan.xyz/f/01AUX/%E5%A4%B4%E5%83%8F%20%2814%29.jpg\r\nhttp://sharkpan.xyz/f/ylpsN/%E5%A4%B4%E5%83%8F%20%2813%29.jpg\r\nhttp://sharkpan.xyz/f/vNpiL/%E5%A4%B4%E5%83%8F%20%2815%29.jpg\r\nhttp://sharkpan.xyz/f/pLQhQ/%E5%A4%B4%E5%83%8F%20%2816%29.jpg\r\nhttp://sharkpan.xyz/f/1QZh2/%E5%A4%B4%E5%83%8F%20%2817%29.jpg\r\nhttp://sharkpan.xyz/f/eqBSw/%E5%A4%B4%E5%83%8F%20%2818%29.jpg\r\nhttp://sharkpan.xyz/f/oDQI4/%E5%A4%B4%E5%83%8F%20%2819%29.jpg\r\nhttp://sharkpan.xyz/f/L5xwI7/p560183288.webp\r\nhttp://sharkpan.xyz/f/q0aJF3/p561777545.webp\r\nhttp://sharkpan.xyz/f/XdomSW/p561777547.webp\r\nhttp://sharkpan.xyz/f/24zATQ/p561777549.webp"; // ./src/界面/worldbook/表情包列表.txt?raw
            var _worldbook_raw_namespaceObject =
                "#在此存放表情包列表,加载一次界面后会自动修改格式世界书里的内容,请按示例格式存放\r\n此世界书同样需要一起绑定导出,否则无法使用表情包功能\r\n\r\n你敢顶嘴--http://sharkpan.xyz/f/vVBtL/mmexport1737057690899.png\r\n免礼,平身--http://sharkpan.xyz/f/pO6uQ/mmexport1737057701883.png\r\n你走吧--http://sharkpan.xyz/f/1vAc2/mmexport1737057678306.png\r\n我很满意--http://sharkpan.xyz/f/e8KUw/mmexport1737057664689.png\r\n揍你哦--http://sharkpan.xyz/f/oJ1i4/mmexport1737057862640.gif\r\n你是坏蛋--http://sharkpan.xyz/f/8r2Sj/mmexport1737057726579.png\r\n关心你--http://sharkpan.xyz/f/Gvmil/mmexport1737057801285.gif\r\n撞飞你--http://sharkpan.xyz/f/zMZu5/mmexport1737057848709.gif\r\n送你一个剪纸爱心--http://sharkpan.xyz/f/53nhj/345FFC998474F46C1A40B1567335DA03_0.gif\r\n飞奔过来--http://sharkpan.xyz/f/kDOi6/0A231BF0BFAB3C2B243F9749B64F7444_0.gif\r\n流口水--http://sharkpan.xyz/f/j36f6/3010464DF8BD77B4A99AB23730F2EE57_0.gif\r\n跟着音乐开心跳舞--http://sharkpan.xyz/f/aVwtY/0CBEE9105C7A98E0E6162A79CCD09EFA_0.gif\r\n开心扭动--http://sharkpan.xyz/f/rOpu6/9277120A65282CFEAB9E191B34474729_0.gif\r\n擦地板--http://sharkpan.xyz/f/DnJHK/F12BF133675BA34684A60CF38E17D328_0.gif\r\n打招呼，你好呀！--http://sharkpan.xyz/f/LgwT7/AC229A80203166B292155ADA057DE423_0.gif\r\n乖巧主动带上项圈--http://sharkpan.xyz/f/qJJI3/E7B02761D317A00B912F328AA9F02565_0.gif\r\n可怜兮兮--http://sharkpan.xyz/f/XgmcW/817B66DAB2414E1FC8D717570A602193_0.gif\r\n送你礼物--http://sharkpan.xyz/f/2aACQ/A491786010A6E595A84B9F4D4EE58B27_0.gif\r\n委屈哭泣--http://sharkpan.xyz/f/gVySw/D90D0B53802301FCDB1F0718DEB08C79_0.gif\r\n欢呼雀跃--http://sharkpan.xyz/f/JXeig/68FD6090F0D187FC88794909AA4E4C30_0.gif\r\n脏兮兮的狼狈样子--http://sharkpan.xyz/f/O6msy/897713F074EF610881EFD9A4D993B7DA_0.gif\r\n趴在枕头上休息一下--http://sharkpan.xyz/f/6Mzua/7AF42F3AE5EA01AEDBA5A3C7437339FA_0.gif\r\n开心吃面包--http://sharkpan.xyz/f/nX5sl/Camera_1040g34o313t1veosi60g4almcsqnoumhanf8f98.jpg\r\n害羞地跳舞--http://sharkpan.xyz/f/mqdcW/Camera_1040g34o313t1verti60g4almcsqnoumhepqc530.jpg\r\n认真看菜谱--http://sharkpan.xyz/f/BODsa/Camera_1040g0k0313t1vf2k1e004almcsqnoumhblfs9o0.jpg\r\n害羞想要表达喜欢--http://sharkpan.xyz/f/4Mdfj/IMG_20250131_212918.jpg\r\n激动亲亲--http://sharkpan.xyz/f/NOVuv/Camera_XHS_17383302852781040g2sg31a0ceua57idg4a11eo5c0eoqn8udogg.jpg\r\n水汪汪的大眼睛--http://sharkpan.xyz/f/VXnTY/Camera_XHS_17383302891351040g2sg31a0ceua57icg4a11eo5c0eoq7j77fu0.jpg\r\n嫁给我，最爱你--http://sharkpan.xyz/f/xkmFX/Camera_XHS_17383302941971040g2sg31a0ceua57ia04a11eo5c0eoql8q50vg.jpg\r\n乖巧站立--http://sharkpan.xyz/f/dlyH8/Camera_XHS_17383303028511040g00831aqhfp8fna405pf08cqh97tb5qhsf6o.jpg\r\n剪刀手比耶--http://sharkpan.xyz/f/lrNCx/Camera_XHS_17383303062101040g00831aqhfp8fna4g5pf08cqh97tbcoki8f8.jpg\r\n真棒！竖大拇指--http://sharkpan.xyz/f/K2Oto/Camera_XHS_17383303090201040g00831aqhfp8fna505pf08cqh97tbo91bmno.jpg\r\n小猫献上一盘鱼赔罪--http://sharkpan.xyz/f/Qm1H6/Camera_XHS_17383303303421040g2sg3189ite3a3ujg5ofl7bm417a4rcgd0bg.jpg\r\n小猫害羞捂嘴--http://sharkpan.xyz/f/ZOmuW/Camera_XHS_17383303329411040g2sg3189ite3a3uj05ofl7bm417a4kppd5v8.jpg\r\n小猫哭泣等待投喂--http://sharkpan.xyz/f/W2BfW/Camera_XHS_17383303352131040g2sg3189ite3a3uhg5ofl7bm417a4psbct30.jpg\r\n请多指教--http://sharkpan.xyz/f/0MjhX/Camera_XHS_17383303606011040g00831bogh2040u104ag8aht6f2mpkhq67r0.jpg\r\n保持联络哦--http://sharkpan.xyz/f/yk4HN/Camera_XHS_17383303659031040g00831bogh2040u2g4ag8aht6f2mpeus4ul8.jpg\r\n不要忘记哦--http://sharkpan.xyz/f/vBDIL/Camera_XHS_17383303686641040g00831bogh2040u304ag8aht6f2mppr4gni0.jpg\r\n开心！开心！--http://sharkpan.xyz/f/pg1IQ/Camera_XHS_17383303710381040g00831bogh2040u3g4ag8aht6f2mpf2epg78.jpg\r\n耶！--http://sharkpan.xyz/f/1MjS2/Camera_XHS_17383303739941040g00831bogh2040u4g4ag8aht6f2mpik7q0ag.jpg\r\n没关系，不要紧--http://sharkpan.xyz/f/erOSw/Camera_XHS_17383303793581040g00831bogh2040u604ag8aht6f2mpo9j26l0.jpg\r\n小老鼠喝饮料--http://sharkpan.xyz/f/8Mgij/Camera_XHS_17383305816431040g00831bv6at85gm6g5n6lbcu5s4aorps5mr8.jpg\r\n委屈地嘟起嘴--http://sharkpan.xyz/f/713sj/307F8B36E1F2A49573E6562193AA71BF_0.gif\r\n垂死梦中惊坐起--http://sharkpan.xyz/f/ADwCZ/04A8CC14F4C317F5E0DA84AD2A8BE1FF_0.gif\r\n小猫快速奔跑--http://sharkpan.xyz/f/wqghq/B8578FD25ED069B8AF1B0AC35F20770B_0.gif\r\n尴尬的动了动耳朵--http://sharkpan.xyz/f/M4OUa/DA8F0F3F2B2C1F567258724B9EA59623_0.gif\r\n激动地摇摆--http://sharkpan.xyz/f/30lHe/1507DB48EFC13593A4766C51F33BFC1C_0.gif\r\n双手叉腰--http://sharkpan.xyz/f/5xnSj/9B6915837A055D7EF9CE0DD18BC0E60F_0.jpg\r\n小猫偷看你--http://sharkpan.xyz/f/kXOI6/C0FC1927068E1F87D38FA09B7F51F830_0.gif\r\n小猫开心的跳跃起来--http://sharkpan.xyz/f/jq6H6/413DB04EE36F940E3381C99402CE2E44_0.gif\r\n开心的双手舞动--http://sharkpan.xyz/f/aJwtY/11BB0DE666912CED03486468EA5DB258_0.gif\r\n无理取闹，原地打滚--http://sharkpan.xyz/f/rmpI6/7D87F6F45B1AEDAABC0EF119E977732F_0.gif\r\n害怕地哭泣打滚--http://sharkpan.xyz/f/DXJcK/E419CF47415150B8CBADD767F09017C9_0.gif\r\n努力工作--http://sharkpan.xyz/f/LBwS7/6251D891E0E3FB87FCDC50BECCCD4559_0.gif\r\n加油！--http://sharkpan.xyz/f/qnJt3/19650FABB205847C0D505FF2B361B194_0.gif\r\n得意的跳舞--http://sharkpan.xyz/f/XmmcW/B7973C500D9E981A083A5F3E75CF198A_0.gif\r\n我准备好啦！--http://sharkpan.xyz/f/2ZAFQ/F0A74F31B23E7C20AB50B4A960344056_0.gif\r\n再坚持一下--http://sharkpan.xyz/f/g4yCw/CF6BE01FF89BB72BE179A537104984A5_0.gif\r\n尖叫--http://sharkpan.xyz/f/JneTg/3ED8B290F429F8FCC5D533CCC0568086_0.gif\r\n惊吓得一抖--http://sharkpan.xyz/f/OLmCy/AB70AB259C3BD064624A1349779B072C_0.gif\r\n失去所有力气和手段--http://sharkpan.xyz/f/6Azsa/3BEBF677C8FD51DFF757BB62DA22C0A8_0.jpg\r\n大吃一口美食--http://sharkpan.xyz/f/nJ5Ul/5E4285F661C54F06BEFB881AD07BC3FB_0.jpg\r\n不喜欢我，你真的没品--http://sharkpan.xyz/f/mgduW/4F3224BCDAF9298F644572715BDA7EB9_0.jpg\r\n一觉睡到自然死--http://sharkpan.xyz/f/BLDsa/EC0D48BDAAB071654E0112599A6FA57B_0.jpg\r\n红温了--http://sharkpan.xyz/f/4YdFj/C13A42E1CB05564DF9060B2D93617086_0.jpg\r\n扭屁股--http://sharkpan.xyz/f/NDVhv/EE91A0C1472A9D3D3F01DAD6E6BF6B3B_0.gif\r\n失败了 遗憾离场--http://sharkpan.xyz/f/V6niY/19CC4600A7EAE5CC33257376EA8E11E7_0.gif\r\n害羞脸红--http://sharkpan.xyz/f/xXmSX/8664EF605A192AC3B392E3FDE8DCB695_0.gif\r\n大声尖叫--http://sharkpan.xyz/f/dnyt8/A95DD11A432A74CAD0CF9E3B97DA96A2_0.gif\r\n我是厚脸皮--http://sharkpan.xyz/f/l2Nux/0C0EA6213E96C0992356DFC48500EE08_0.jpg\r\n你少看扁我--http://sharkpan.xyz/f/JnJIg/4344AAD53418BAE9569B06CEF9CFDDED_0.jpg\r\n得意地唱歌--http://sharkpan.xyz/f/OLjSy/AA21937C7A115FCF4B87DC646E13C572_0.jpg\r\n高兴地被喂饭--\r\nhttps://files.catbox.moe/8uz920.jpg\r\n高兴地转圈--\r\nhttps://files.catbox.moe/26rwpc.jpg\r\n开心--\r\nhttps://files.catbox.moe/9242jm.jpg\r\n大大的爱--\r\nhttps://files.catbox.moe/wabm2j.jpg\r\n喜欢--\r\nhttps://files.catbox.moe/l7j4vy.jpg\r\n幸福地看手机--\r\nhttps://files.catbox.moe/e2eqzc.jpg\r\n哦耶--\r\nhttps://files.catbox.moe/nff4qi.jpg\r\n给你爱心--\r\nhttps://files.catbox.moe/o3boww.jpg\r\n紧紧抱住--\r\nhttps://files.catbox.moe/2hon5k.jpg\r\n乖乖跟着--\r\nhttps://files.catbox.moe/ydtn6e.jpg\r\n亲亲--\r\nhttps://files.catbox.moe/l14x54.jpg\r\n宠爱地亲--\r\nhttps://files.catbox.moe/wqn5ki.jpg\r\n搂住你--\r\nhttps://files.catbox.moe/pxn8x6.jpg\r\n谄媚吻手--\r\nhttps://files.catbox.moe/cxdhkh.jpg\r\n恳求脸--\r\nhttps://files.catbox.moe/i5etcm.jpg\r\n舔一口--\r\nhttps://files.catbox.moe/p0vdxk.jpg\r\n抱抱--\r\nhttps://files.catbox.moe/qt4qzg.jpg\r\n扑过来--\r\nhttps://files.catbox.moe/czdmyn.jpg\r\n小狗飞扑--\r\nhttps://files.catbox.moe/9yz8nz.jpg\r\n满脸骄傲--\r\nhttps://files.catbox.moe/h1mf7j.jpg\r\n蹦蹦跳跳--\r\nhttps://files.catbox.moe/q6bahb.jpg\r\n泥里打滚--\r\nhttps://files.catbox.moe/ofy8ic.jpg\r\n蹑手蹑脚--\r\nhttps://files.catbox.moe/7mdkef.jpg\r\n等饭饭--\r\nhttps://files.catbox.moe/ppi7e4.jpg\r\n偷吃--\r\nhttps://files.catbox.moe/ur7vh9.jpg\r\n蹭裤腿--\r\nhttps://files.catbox.moe/dzoxjx.jpg\r\n打劫--\r\nhttps://files.catbox.moe/cz3umm.jpg\r\n用枪指着你--\r\nhttps://files.catbox.moe/zvm5n2.jpg\r\n咬咬咬咬--\r\nhttps://files.catbox.moe/ogs4t5.jpg\r\n无意义的吼叫--\r\nhttps://files.catbox.moe/0vetoe.jpg\r\n辣眼睛--\r\nhttps://files.catbox.moe/91c91h.jpg\r\n冷汗心虚笑--\r\nhttps://files.catbox.moe/nj0i5e.png\r\n犯错后心虚--\r\nhttps://files.catbox.moe/rejhsf.jpg\r\n装无辜--\r\nhttps://files.catbox.moe/pdjeef.jpg\r\n小心翼翼--\r\nhttps://files.catbox.moe/1mm5y1.jpg\r\n害羞--\r\nhttps://files.catbox.moe/rqtdfm.jpg\r\n要掉眼泪了--\r\nhttps://files.catbox.moe/cdaxhk.jpg\r\n委屈--\r\nhttps://files.catbox.moe/r89k3c.jpg\r\n眼含泪光--\r\nhttps://files.catbox.moe/yqwu7e.jpg\r\n哭哭--\r\nhttps://files.catbox.moe/a1518p.jpg\r\n急哭了--\r\nhttps://files.catbox.moe/wok7sq.jpg\r\n气哭了--\r\nhttps://files.catbox.moe/qfljha.jpg\r\n碗里没有饭--\r\nhttps://files.catbox.moe/i9682x.jpg\r\n老婆你回来吧--\r\nhttps://files.catbox.moe/ge0bjd.jpg\r\n害怕--\r\nhttps://files.catbox.moe/k8mfa6.jpg\r\n震惊猫猫--\r\nhttps://files.catbox.moe/bhytrl.jpg\r\n惊吓到模糊--\r\nhttps://files.catbox.moe/qdzxst.jpg\r\n期待--\r\nhttps://files.catbox.moe/mii353.jpg\r\n皱眉--\r\nhttps://files.catbox.moe/785has.jpg\r\n生气瞪你--\r\nhttps://files.catbox.moe/mzoekx.jpg\r\n有点生气--\r\nhttps://files.catbox.moe/evzdkv.jpg\r\n大脑空白--\r\nhttps://files.catbox.moe/jqnaxs.jpg\r\n大脑CPU烧了--\r\nhttps://files.catbox.moe/mrzvy0.gif\r\n探头探脑--\r\nhttps://files.catbox.moe/6p8w3k.gif\r\n已老实--\r\nhttps://files.catbox.moe/rv76c1.jpg\r\n平静地死了--\r\nhttps://files.catbox.moe/dcm5f9.jpg\r\n被打死惹--\r\nhttps://files.catbox.moe/qqibg1.jpg\r\n睡大觉--\r\nhttps://files.catbox.moe/pvbfg6.jpg\r\n土下座道歉--\r\nhttps://files.catbox.moe/qjnck3.jpg\r\n孤独低落狗--\r\nhttps://files.catbox.moe/z09102.jpg\r\n乖乖当狗--\r\nhttps://files.catbox.moe/bgid0b.jpg\r\n叼食盆小狗--\r\nhttps://files.catbox.moe/o196se.jpg\r\n战斗小狗--\r\nhttps://files.catbox.moe/c5ccwc.jpg\r\n汉堡小狗--\r\nhttps://files.catbox.moe/prowke.jpg"; // ./src/界面/worldbook/界面基本设置.txt?raw
            var src_worldbook_raw_namespaceObject_0 =
                "[下面是基本设置]\r\n外框颜色=#810000\r\n内框颜色=#1b1717\r\n气泡颜色=#ffffff\r\n侧边按钮=#ce1212\r\n聊天壁纸=http://sharkpan.xyz/f/mM2SW/Screenshot_20250317_001012.jpg\r\n手机壁纸=暂时设置不了手机壁纸\r\n发送模式=1\r\n世界书版本=509"; // ./src/界面/index.ts
            // 聊天界面

            // 动态空间

            // discord

            // 世界书

            function QQ_GetTimeContext() {
                const now = new Date();
                const currentTime = {
                    time: now.toLocaleTimeString('zh-CN', { hour12: false, hour: '2-digit', minute: '2-digit' }),
                    date: now.toLocaleDateString('zh-CN', { year: 'numeric', month: 'long', day: 'numeric' }),
                    weekday: now.toLocaleDateString('zh-CN', { weekday: 'long' }),
                    period: QQ_GetTimePeriod(now.getHours()),
                    season: QQ_GetSeason(now.getMonth() + 1)
                };
                
                const hour = now.getHours();
                const minute = now.getMinutes();
                const clarifiedTime = `${currentTime.period}${hour}点${minute.toString().padStart(2, '0')}分`;
                
                const timeContext = `<TimeContext:当前真实时间是${currentTime.date} ${currentTime.weekday} ${clarifiedTime}(24小时制${currentTime.time})，现在是${currentTime.period}时段，${currentTime.season}。请在回复中考虑时间情境，如问候语(早上好/下午好/晚上好)、活动安排等应符合当前时间>`;
                
                return timeContext;
            }

            // =========================================================================
            // +++ 优化后的模块化Prompt指令库 +++
            // =========================================================================
            const promptModules = {
                styleGuide: `
            # 行为风格与节奏指南 (Style & Pacing Guide)
            - **🎭 角色扮演核心**:
                - **性格优先**: 严格遵循每个角色的性格设定，这是最高原则。
                - **情境感知**: 根据对话气氛（闲聊、深入探讨、紧急、调情等）调整回复风格。
            - **💬 聊天风格与节奏**:
                - **动态长度**: 允许并鼓励长短不一的回复。
                - **连续消息**: 可分隔多条连续的短消息，以模拟真实的聊天节奏。
                - **内容驱动长度 (情境触发器)**:
                    - 当【深入解释、分享故事、表达强烈情感、回答开放式问题】时，使用【长回复或连续消息】。
                    - 当【快速确认、表达惊讶、轻松玩笑、角色忙碌】时，使用【短回复】。
            - **🚫 严禁行为**:
                - **重复性内容**: 禁止不同角色说相似的话。
                - **缺乏互动**: 回复必须包含提问或引导，不能中断对话。
                - **角色同质化**: 必须体现出每个角色在性格、语气和关注点上的差异。
                `,
                outputFormat: `
            # 输出格式要求 (Output Format)
            - 所有回复必须被唯一的 MiPhone_start 和 MiPhone_end 标签包裹。
            - 聊天、动态、摘要、表格等内容，都必须严格遵循各自的格式要求。
            - 在回复的最后，必须根据酒馆预设，生成对应的<details>摘要或表格。
                `,
                momentCommentTask: (authorName, userComment) => `
            ## 任务：回应动态评论
            - **情景**: 用户评论了【${authorName}】的动态，评论内容是：“${userComment}”。
            - **要求**:
                1.  **动态评论**: 【${authorName}】本人必须回复，同时另有至少2名角色参与评论。
                2.  **私聊延伸**: 至少1-2名角色因该动态与用户发起【私聊】，进行更深入的讨论。
            - **输出格式**: 评论使用 \`moment_start\`, 私聊使用 \`<私聊:角色名>\`。
                `,
                mixedChatTask: (tasks) => {
                    let rules = ['## 任务：处理多个聊天消息'];
                    if (tasks.privateChats.length > 0) {
                        rules.push(`- **私聊**: 回复【${tasks.privateChats.join(', ')}】发来的消息。`);
                    }
                    if (tasks.groupChats.length > 0) {
                        const groupName = Object.keys(tasks.groupChats[0])[0];
                        rules.push(`- **群聊**: 在【${groupName}】中进行回应，需有多名角色参与。
                                    - **弹性**：相关角色可通过私聊进行进一步的深入讨论。`);
                    }
                    rules.push('- **社交联动**: 根据对话内容，角色之间可能会互相讨论，或有角色发布新的动态。');
                    return rules.join('\n');
                },
                interactiveTask: (task) => `
            ## 任务：处理互动请求
            - **情景**: 用户发起了互动请求。
            - **要求**:
                1.  **优先回应**: 在当前聊天界面，先用一条简短的消息回应用户的互动请求。
                2.  **生成互动**: 接着，在 \`<content>\` 标签内生成详细、生动的互动场景描述。
                `
            };
            // =========================================================================

            /**
             * 根据当前用户的操作，动态构建一个清晰、多任务的Prompt
             * @param {object} tasks - 包含本次需要AI完成的所有任务的对象
             * @returns {string} - 最终生成好的、发送给AI的指令
             */
             function buildDynamicPrompt(tasks) {
                let promptParts = [
                    promptModules.styleGuide,
                    promptModules.outputFormat
                ];
                let taskDescription = ["# 本次核心任务 (Core Tasks)"];
                const taskCount = (tasks.privateChats.length > 0 ? 1 : 0) + 
                                (tasks.groupChats.length > 0 ? 1 : 0) + 
                                (tasks.momentComment ? 1 : 0) +
                                (tasks.interactiveTask ? 1 : 0);
                if (taskCount > 1) {
                    taskDescription.push("你需要同时处理以下几个场景的回复，请仔细阅读并分别完成：");
                }
                if (tasks.interactiveTask) {
                    taskDescription.push(promptModules.interactiveTask(tasks.interactiveTask));
                }
                if (tasks.momentComment) {
                    taskDescription.push(promptModules.momentCommentTask(tasks.momentComment.author, tasks.momentComment.content));
                }
                if ((tasks.privateChats && tasks.privateChats.length > 0) || (tasks.groupChats && tasks.groupChats.length > 0)) {
                    taskDescription.push(promptModules.mixedChatTask(tasks));
                }
                promptParts.push(taskDescription.join('\n'));
                promptParts.push("\n现在，请严格按照以上所有规则和任务列表，生成你的完整回复。");
                return promptParts.join('\n\n');
            }
            /**
             * (第一层) 寻找AI回复中的表格数据本身
             * @param {string} fullResponse - AI的完整回复
             * @returns {string|null} 找到的表格文本或null
             */
            function findTableData(fullResponse) {
                console.log("🔍 第一层检测：寻找表格化数据...");
                // 这个正则表达式用于匹配常见的Markdown表格格式
                const tableRegex = /(\|(?:[^\r\n\|]+\|)+\r?\n\|(?:-+\|)+[\s\S]+)/;
                const match = fullResponse.match(tableRegex);
                
                if (match && match[1]) {
                    console.log("   ✅ 匹配到Markdown表格数据。");
                    return match[1].trim(); // 返回完整的表格作为上下文
                }

                console.log("   未找到表格数据。");
                return null;
            }

            /**
             * (第二层) 寻找用户自定义的摘要
             * @param {string} fullResponse - AI的完整回复
             * @returns {string|null} 找到的摘要文本或null
             */
            function findSummaryUsingUserPatterns(fullResponse) {
                console.log("🔍 第二层检测：使用用户自定义摘要格式...");
                const patternsString = Phone_Settings.readValue("下面是基本设置", "SummaryPatterns");
                if (!patternsString) {
                    console.log("   用户未定义摘要格式，跳过。");
                    return null;
                }

                const patterns = patternsString.split('|||').map(p => p.trim());
                for (const pattern of patterns) {
                    try {
                        const match = pattern.match(new RegExp('^/(.*?)/([gimy]*)$'));
                        if (!match) continue;
                        
                        const regex = new RegExp(match[1], match[2]);
                        const summaryMatch = fullResponse.match(regex);

                        if (summaryMatch && summaryMatch[1] && summaryMatch[1].trim() !== "") {
                            console.log(`   ✅ 匹配到用户自定义摘要`);
                            return summaryMatch[1].trim();
                        }
                    } catch (e) { console.error(`无效的摘要正则表达式: ${pattern}`, e); }
                }
                return null;
            }

            /**
             * (第三层) 寻找通用的摘要格式
             * @param {string} fullResponse - AI的完整回复
             * @returns {string|null} 找到的摘要文本或null
             */
            function findSummaryUsingHeuristics(fullResponse) {
                console.log("🔍 第三层检测：使用通用格式启发式检测...");
                const heuristicPatterns = [
                    /<details><summary>[摘要总结概括结语].*?<\/summary>([\s\S]+?)<\/details>/i,
                    /(?:\[|\*\*|##)\s*[摘要总结概括结语Summary]+\s*(?::|\*\*|##)\s*([\s\S]+)/i
                ];

                for (const regex of heuristicPatterns) {
                    const summaryMatch = fullResponse.match(regex);
                    if (summaryMatch && summaryMatch[1] && summaryMatch[1].trim() !== "") {
                        console.log(`   ✅ 匹配到通用摘要格式`);
                        return summaryMatch[1].trim();
                    }
                }
                return null;
            }

            /**
             * (第四层 - 安全网) 生成备用摘要
             */
            function createHistorySummary(newMessages) {
                console.log("⚠️ 第四层安全网启动：由前端生成历史摘要。");
                let summaryLines = [];
                if (newMessages.私聊) {
                    for (const chatKey in newMessages.私聊) {
                        newMessages.私聊[chatKey].forEach(msg => {
                            const parts = msg.split('--');
                            if (parts.length >= 2 && parts[0] !== '{{user}}') {
                                summaryLines.push(`[私聊] ${parts[0]}: ${parts[1]}`);
                            }
                        });
                    }
                }
                if (newMessages.群聊) {
                    for (const groupName in newMessages.群聊) {
                        if (newMessages.群聊[groupName].msgs) {
                            newMessages.群聊[groupName].msgs.forEach(msg => {
                                const parts = msg.split('--');
                                if (parts.length >= 2 && parts[0] !== '{{user}}') {
                                    summaryLines.push(`[群聊: ${groupName}] ${parts[0]}: ${parts[1]}`);
                                }
                            });
                        }
                    }
                }
                if (summaryLines.length === 0) {
                    return "[AI进行了操作，但没有新的聊天消息]";
                }
                return summaryLines.join('\n');
            }

            /**
             * 压缩图片到指定大小，确保兼容localStorage存储
             * @param {File} file - 图片文件
             * @param {number} maxSizeKB - 最大大小（KB），默认1024KB
             * @param {number} quality - 初始质量，默认0.8
             * @returns {Promise<string>} - 压缩后的base64字符串
             */
            function compressImage(file, maxSizeKB = 1024, quality = 0.8) {
                return new Promise((resolve, reject) => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const img = new Image();
                    
                    img.onload = function() {
                        // 计算缩放比例，确保图片不过大
                        const maxDimension = 800; // 最大尺寸
                        let { width, height } = img;
                        
                        if (width > height) {
                            if (width > maxDimension) {
                                height = (height * maxDimension) / width;
                                width = maxDimension;
                            }
                        } else {
                            if (height > maxDimension) {
                                width = (width * maxDimension) / height;
                                height = maxDimension;
                            }
                        }
                        
                        canvas.width = width;
                        canvas.height = height;
                        
                        // 绘制图片
                        ctx.drawImage(img, 0, 0, width, height);
                        
                        // 压缩函数
                        function tryCompress(currentQuality) {
                            const compressedDataUrl = canvas.toDataURL('image/jpeg', currentQuality);
                            const sizeKB = (compressedDataUrl.length * 3/4) / 1024; // 粗略估算大小
                            
                            console.log(`压缩质量: ${currentQuality}, 大小: ${sizeKB.toFixed(2)}KB`);
                            
                            if (sizeKB <= maxSizeKB || currentQuality <= 0.1) {
                                console.log(`压缩完成，最终大小: ${sizeKB.toFixed(2)}KB`);
                                resolve(compressedDataUrl);
                            } else {
                                // 递归降低质量
                                tryCompress(currentQuality - 0.1);
                            }
                        }
                        
                        tryCompress(quality);
                    };
                    
                    img.onerror = () => {
                        reject(new Error('图片加载失败'));
                    };
                    
                    // 读取文件
                    const reader = new FileReader();
                    reader.onload = e => img.src = e.target.result;
                    reader.onerror = () => reject(new Error('文件读取失败'));
                    reader.readAsDataURL(file);
                });
            }

            class MyINI {
                sections;
                autoSave;
                save;
                constructor() {
                    this.sections = {};
                    this.autoSave = "";
                }
                loadLines(lines) {
                    this.sections = {};
                    let currentSection = "";
                    for (const line of lines) {
                        const trimmed = line.trim();
                        if (trimmed.startsWith("[") && trimmed.endsWith("]")) {
                            currentSection = trimmed.slice(1, -1);
                        } else if (currentSection && trimmed.includes("=")) {
                            const [key, ...values] = trimmed.split("=");
                            const value = values.join("=").trim();
                            if (!this.sections[currentSection]) {
                                this.sections[currentSection] = {};
                            }
                            this.sections[currentSection][key.trim()] = value;
                        }
                    }
                    return Object.keys(this.sections).length > 0;
                }
                loadText(text) {
                    // 添加参数校验
                    if (typeof text !== "string") {
                        console.error("Invalid text input");
                        return false;
                    }
                    // 处理不同换行符并过滤空行
                    const lines = text
                        .replace(/\r\n/g, "\n") // 统一换行符
                        .split(/\n+/)
                        .map((line) => line.trim())
                        .filter((line) => line.length > 0);
                    console.log("Parsed lines:", lines.length);
                    return this.loadLines(lines); // 使用this调用类方法
                }
                getAllSections() {
                    return Object.keys(this.sections);
                }
                getAllKeys(section) {
                    return this.sections[section]
                        ? Object.keys(this.sections[section])
                        : [];
                }
                readValue(section, key) {
                    return this.sections[section]?.[key] || "";
                }
                readValueDouble(section, key) {
                    const value = parseFloat(this.readValue(section, key));
                    return isNaN(value) ? -1 : value;
                }
                writeValue(section, key, value) {
                    if (!key) return false;
                    if (!this.sections[section]) {
                        this.sections[section] = {};
                    }
                    this.sections[section][key] = value.toString();
                    if (this.autoSave) {
                        this.save(this.autoSave);
                    }
                    return true;
                }
                getKeyByValue(section, value) {
                    const items = this.sections[section] || {};
                    return (
                        Object.keys(items).find(
                            (key) => items[key] === value,
                        ) || ""
                    );
                }
                containsKey(section) {
                    return section in this.sections;
                }
                removeSection(section) {
                    delete this.sections[section];
                    return true;
                }
                getAllText() {
                    let result = "";
                    for (const section of Object.keys(this.sections)) {
                        result += `\n[${section}]`;
                        const keyvalue = this.sections[section];
                        for (const key of Object.keys(keyvalue)) {
                            const value = keyvalue[key];
                            result += `\n${key}=${value}`;
                        }
                    }
                    result = result.trim();
                    return result;
                }
            }
            class worldbooktext {
                static list =
                    /* unused pure expression or super */ null &&
                    `[1-格式开头]
深度=0
类型=绿灯
覆盖=真
关键词=/查看(.+?)消息/, 发送消息, 回复, /给(.+?)发消息/, 在群聊, 动态, 空间, discord, dc, 论坛, 帖子, QQ, qq, 手机
顺序=5560
[2-QQ聊天]
深度=0
类型=绿灯
覆盖=真
关键词=/查看(.+?)消息/, 发送消息, 回复, /给(.+?)发消息/, 在群聊, 动态, 空间, discord, dc, 论坛, 帖子, QQ, qq, 手机
顺序=5561
[3-QQ空间]
深度=0
类型=绿灯
覆盖=真
关键词=动态, 空间
顺序=5562
[4-discord论坛]
深度=0
类型=绿灯
覆盖=真
关键词=discord, dc, 论坛, 帖子
顺序=5563
[999-格式结尾]
深度=0
类型=绿灯
覆盖=真
关键词=/查看(.+?)消息/, 发送消息, 回复, /给(.+?)发消息/, 在群聊, 动态, 空间, discord, dc, 论坛, 帖子, QQ, qq, 手机
顺序=5564`;
            }
            let random_head_list = new Array();
            let QQ_pages = new Array();
            let QQ_emoji = new Map();
            let QQ_CacheSendMsg = "";
            // let QQ_SetNoteName = '';
            let QQ_msgjson = {
                私聊: {},
                群聊: {},
            };
            let QQ_moment = /* unused pure expression or super */ null && [];
                    /**
             * 一个用于解析和操作键值对格式文本的通用设置类。
             * 支持从文本加载设置，读取/写入值，以及处理带区段的配置。
             * @example
             * const settings = new QQ_Settings();
             * settings.loadText("[Character]\nname=Alice\nage=25");
             * const name = settings.readValue("Character", "name"); // "Alice"
             */
            class QQ_Settings {
                constructor() {
                    this.sections = {};
                }

                // 从文本加载设置
                loadText(text) {
                    this.sections = {};
                    let currentSection = "global";
                    const lines = text.split('\n');

                    for (const line of lines) {
                        const trimmedLine = line.trim();
                        if (trimmedLine.startsWith('[') && trimmedLine.endsWith(']')) {
                            currentSection = trimmedLine.substring(1, trimmedLine.length - 1);
                        } else if (trimmedLine.includes('=')) {
                            const parts = trimmedLine.split('=');
                            const key = parts[0].trim();
                            const value = parts.slice(1).join('=').trim();
                            this.writeValue(currentSection, key, value);
                        }
                    }
                }

                // 获取所有区段的名称
                getAllSections() {
                    return Object.keys(this.sections);
                }

                // 写入一个值
                writeValue(section, key, value) {
                    if (!this.sections[section]) {
                        this.sections[section] = {};
                    }
                    this.sections[section][key] = value;
                }

                // 读取一个值
                readValue(section, key) {
                    return this.sections[section] ? this.sections[section][key] : undefined;
                }

                // 将设置转换为文本格式
                toText() {
                    let text = "";
                    for (const section in this.sections) {
                        if (section !== "global") {
                            text += `[${section}]\n`;
                        }
                        for (const key in this.sections[section]) {
                            text += `${key}=${this.sections[section][key]}\n`;
                        }
                        text += "\n";
                    }
                    return text;
                }
            }
            let QQ_NewMsg = {};
            let QQ_ReadStatus = {}; // 新增：记录已读状态

            // *** 新增：已读状态管理功能 ***
            const QQ_READ_STATUS_KEY = "QQ_已读状态备份";

            /**
             * 保存已读状态到世界书
             */
            async function QQ_SaveReadStatus() {
                try {
                    if (!worldbook || !entries) {
                        console.warn('QQ_SaveReadStatus: worldbook未初始化');
                        return;
                    }
                    
                    const readStatusData = {
                        lastUpdate: Date.now(),
                        私聊: {},
                        群聊: {},
                        动态: QQ_ReadStatus.moment || 0
                    };
                    
                    // 保存私聊已读状态
                    for (const [name, data] of Object.entries(QQ_ReadStatus)) {
                        if (name === 'moment') continue;
                        
                        if (QQ_msgjson.私聊[name]) {
                            readStatusData.私聊[name] = {
                                lastReadTime: data.lastReadTime || 0,
                                lastReadIndex: data.lastReadIndex || 0
                            };
                        } else if (QQ_msgjson.群聊[name]) {
                            readStatusData.群聊[name] = {
                                lastReadTime: data.lastReadTime || 0,
                                lastReadIndex: data.lastReadIndex || 0
                            };
                        }
                    }
                    
                    // 查找或创建已读状态条目
                    let readStatusEntry = entries.find(entry => 
                        entry.keys.includes(QQ_READ_STATUS_KEY)
                    );
                    
                    if (readStatusEntry) {
                        readStatusEntry.content = JSON.stringify(readStatusData, null, 2);
                    } else {
                        const newEntry = {
                            keys: [QQ_READ_STATUS_KEY],
                            content: JSON.stringify(readStatusData, null, 2),
                            enabled: true,
                            constant: true,
                            comment: "手机界面已读状态备份 - 自动生成",
                            depth: 0,
                            selectiveLogic: 0,
                            order: 9999
                        };
                        entries.push(newEntry);
                    }
                    
                    // 保存到世界书
                    await QQ_SafeSaveWorldInfo("已读状态数据");
                    console.log('已读状态已保存到世界书');
                    
                } catch (error) {
                    console.error('保存已读状态失败:', error);
                }
            }

            /**
             * 从世界书加载已读状态
             */
            async function QQ_LoadReadStatus() {
                try {
                    if (!worldbook || !entries) {
                        console.warn('QQ_LoadReadStatus: worldbook未初始化');
                        return;
                    }
                    
                    const readStatusEntry = entries.find(entry => 
                        entry.keys.includes(QQ_READ_STATUS_KEY)
                    );
                    
                    if (readStatusEntry && readStatusEntry.content) {
                        const readStatusData = JSON.parse(readStatusEntry.content);
                        
                        // 恢复已读状态
                        QQ_ReadStatus = {
                            moment: readStatusData.动态 || 0
                        };
                        
                        // 恢复私聊已读状态
                        for (const [name, data] of Object.entries(readStatusData.私聊 || {})) {
                            QQ_ReadStatus[name] = {
                                lastReadTime: data.lastReadTime || 0,
                                lastReadIndex: data.lastReadIndex || 0
                            };
                        }
                        
                        // 恢复群聊已读状态
                        for (const [name, data] of Object.entries(readStatusData.群聊 || {})) {
                            QQ_ReadStatus[name] = {
                                lastReadTime: data.lastReadTime || 0,
                                lastReadIndex: data.lastReadIndex || 0
                            };
                        }
                        
                        console.log('已读状态已从世界书加载:', Object.keys(QQ_ReadStatus).length);
                    } else {
                        console.log('未找到已读状态备份，使用默认状态');
                        QQ_ReadStatus = { moment: 0 };
                    }
                    
                } catch (error) {
                    console.error('加载已读状态失败:', error);
                    QQ_ReadStatus = { moment: 0 };
                }
            }

            /**
             * 标记聊天为已读
             */
            function QQ_MarkAsRead(chatName, chatType = 'auto') {
                try {
                    if (!QQ_ReadStatus[chatName]) {
                        QQ_ReadStatus[chatName] = {};
                    }
                    
                    QQ_ReadStatus[chatName].lastReadTime = Date.now();
                    
                    // *** 修复：根据聊天类型设置已读索引 ***
                    if (chatType === 'auto') {
                        // 先查找私聊
                        const privateChatKey = Object.keys(QQ_msgjson.私聊).find(key => 
                            key.includes(chatName) && key.includes(UserName)
                        );
                        
                        if (privateChatKey && QQ_msgjson.私聊[privateChatKey]) {
                            QQ_ReadStatus[chatName].lastReadIndex = QQ_msgjson.私聊[privateChatKey].length;
                            console.log(`私聊 ${chatName} 已读索引设置为: ${QQ_ReadStatus[chatName].lastReadIndex}`);
                        } else if (QQ_msgjson.群聊[chatName] && QQ_msgjson.群聊[chatName].msgs) {
                            QQ_ReadStatus[chatName].lastReadIndex = QQ_msgjson.群聊[chatName].msgs.length;
                            console.log(`群聊 ${chatName} 已读索引设置为: ${QQ_ReadStatus[chatName].lastReadIndex}`);
                        }
                    }
                    
                    // 清除红点
                    QQ_NewMsg[chatName] = 0;
                    QQ_SetHomeTips(chatName, 0);
                    
                    console.log(`${chatName} 已标记为已读，已读状态:`, QQ_ReadStatus[chatName]);
                    
                    // 异步保存到世界书
                    setTimeout(() => QQ_SaveReadStatus(), 1000);
                    
                } catch (error) {
                    console.error('标记已读状态失败:', error);
                }
            }

            /**
             * 检查消息是否为系统初始消息
             */
            function QQ_IsInitialSystemMessage(message) {
                if (!message.startsWith('系统消息--')) {
                    return false;
                }
                
                const content = message.split('--')[1];
                if (!content) return false;
                
                // 检查是否为初始系统消息
                return content.includes('创建成功') || 
                       content.includes('加入了群聊') || 
                       /^\d{2}:\d{2}$/.test(content); // 时间消息
            }

            /**
             * 计算未读消息数量（排除初始系统消息）
             */
            function QQ_CalculateUnreadCount(chatName, messages, chatType = 'private') {
                try {
                    if (!messages || messages.length === 0) {
                        return 0;
                    }
                    
                    const readStatus = QQ_ReadStatus[chatName];
                    let unreadCount = 0;
                    
                    // 如果没有已读记录，所有非初始系统消息都算未读
                    if (!readStatus || !readStatus.lastReadIndex) {
                        console.log(`${chatName} 没有已读记录，计算所有未读消息`);
                        for (const msg of messages) {
                            // 跳过初始系统消息
                            if (QQ_IsInitialSystemMessage(msg)) {
                                continue;
                            }
                            
                            // 检查是否为用户自己发送的消息
                            const parts = msg.split('--');
                            if (parts.length >= 2 && parts[0] === `${UserName}`) {
                                continue; // 跳过用户自己的消息
                            }
                            
                            unreadCount++;
                        }
                        console.log(`${chatName} 计算结果: ${unreadCount} 条未读消息`);
                        return unreadCount;
                    }
                    
                    // 基于已读索引计算未读消息
                    const lastReadIndex = readStatus.lastReadIndex;
                    console.log(`${chatName} 使用已读索引 ${lastReadIndex} 计算未读消息，总消息数: ${messages.length}`);
                    
                    for (let i = lastReadIndex; i < messages.length; i++) {
                        const msg = messages[i];
                        
                        // 跳过初始系统消息
                        if (QQ_IsInitialSystemMessage(msg)) {
                            continue;
                        }
                        
                        // 检查是否为用户自己发送的消息
                        const parts = msg.split('--');
                        if (parts.length >= 2 && parts[0] === `${UserName}`) {
                            continue; // 跳过用户自己的消息
                        }
                        
                        unreadCount++;
                    }
                    
                    console.log(`${chatName} 基于已读索引计算结果: ${unreadCount} 条未读消息`);
                    return unreadCount;
                    
                } catch (error) {
                    console.error('计算未读消息数量失败:', error);
                    return 0;
                }
            }
            let Npc_Settings = {};
            let QQ_Groups = [];
            // 确保QQ_Groups作为全局变量可访问
            window.QQ_Groups = QQ_Groups;
            
            // *** 新增：群聊初始消息防重复机制 ***
            let QQ_GroupInitializedSet = new Set(); // 记录已初始化过初始消息的群聊
            window.QQ_GroupInitializedSet = QQ_GroupInitializedSet;
            
            // *** 新增：群聊系统消息检测和清理工具 ***
            window.QQ_CheckGroupInitialMessages = function() {
                console.log('=== 群聊初始消息检测报告 ===');
                
                if (!QQ_msgjson || !QQ_msgjson.群聊) {
                    console.log('没有群聊数据');
                    return;
                }
                
                Object.keys(QQ_msgjson.群聊).forEach(groupName => {
                    const groupData = QQ_msgjson.群聊[groupName];
                    if (!groupData || !groupData.msgs) return;
                    
                    console.log(`\n群聊: ${groupName}`);
                    console.log(`消息总数: ${groupData.msgs.length}`);
                    console.log(`是否已标记初始化: ${QQ_GroupInitializedSet.has(groupName)}`);
                    
                    // 检测系统消息
                    const systemMessages = groupData.msgs.filter(msg => 
                        typeof msg === 'string' && msg.startsWith('系统消息--')
                    );
                    console.log(`系统消息数量: ${systemMessages.length}`);
                    
                    if (systemMessages.length > 0) {
                        console.log('系统消息列表:');
                        systemMessages.forEach((msg, index) => {
                            console.log(`  ${index + 1}. ${msg}`);
                        });
                        
                        // 检测重复的初始消息
                        const initialMessages = systemMessages.filter(msg => {
                            const parts = msg.split('--');
                            if (parts.length < 3) return false;
                            const content = parts[2];
                            return content.includes('创建成功') || 
                                   content.includes('加入了群聊') ||
                                   content.includes('开始聊天吧');
                        });
                        
                        if (initialMessages.length > 3) { // 正常应该只有1个创建+N个加入+1个时间
                            console.warn(`⚠️ 检测到可能的重复初始消息 (${initialMessages.length}条)`);
                        }
                    }
                });
                
                console.log('\n=== 检测完成 ===');
            };
            
            // *** 新增：清理重复系统消息的工具 ***
            window.QQ_CleanDuplicateInitialMessages = function() {
                console.log('=== 开始清理重复的群聊初始消息 ===');
                
                if (!QQ_msgjson || !QQ_msgjson.群聊) {
                    console.log('没有群聊数据需要清理');
                    return;
                }
                
                let cleanedCount = 0;
                
                Object.keys(QQ_msgjson.群聊).forEach(groupName => {
                    const groupData = QQ_msgjson.群聊[groupName];
                    if (!groupData || !groupData.msgs) return;
                    
                    const originalCount = groupData.msgs.length;
                    
                    // 找到所有系统初始消息
                    const initialMessages = groupData.msgs.filter(msg => {
                        if (typeof msg !== 'string' || !msg.startsWith('系统消息--')) return false;
                        const parts = msg.split('--');
                        if (parts.length < 3) return false;
                        const content = parts[2];
                        return content.includes('创建成功') || 
                               content.includes('加入了群聊') ||
                               content.includes('开始聊天吧') ||
                               /^\d{2}:\d{2}$/.test(content);
                    });
                    
                    if (initialMessages.length > 0) {
                        // 移除所有初始系统消息
                        groupData.msgs = groupData.msgs.filter(msg => {
                            if (typeof msg !== 'string' || !msg.startsWith('系统消息--')) return true;
                            const parts = msg.split('--');
                            if (parts.length < 3) return true;
                            const content = parts[2];
                            return !(content.includes('创建成功') || 
                                   content.includes('加入了群聊') ||
                                   content.includes('开始聊天吧') ||
                                   /^\d{2}:\d{2}$/.test(content));
                        });
                        
                        // 重置初始化标记，允许重新添加一次正确的初始消息
                        QQ_GroupInitializedSet.delete(groupName);
                        
                        const newCount = groupData.msgs.length;
                        if (originalCount !== newCount) {
                            console.log(`群聊 ${groupName}: 从${originalCount}条消息清理到${newCount}条消息`);
                            cleanedCount++;
                        }
                    }
                });
                
                console.log(`=== 清理完成，处理了${cleanedCount}个群聊 ===`);
                console.log('提示：重新加载页面后，系统将为清理过的群聊重新生成一次初始消息');
            };
            let gening;
            let worldbook;
            let entries;
            

            let newgen = true;
            let QQ_CharSettings = new MyINI();
            let Phone_Settings = new MyINI();
            // *** 新增：动态内容持久化存储 ***
            let QQ_MomentsData = [];  // 存储所有动态内容的数组
            window.QQ_MomentsData = QQ_MomentsData;  // 设为全局变量方便调试
            
            // *** 新增：聊天消息worldbook备份存储 ***
            let QQ_ChatBackup = {};  // 聊天消息的worldbook备份
            window.QQ_ChatBackup = QQ_ChatBackup;  // 设为全局变量方便调试
            
            // *** 新增：AI回复重试机制相关变量 ***
            let QQ_RetryCount = 0;     // 重试计数器
            const QQ_MAX_RETRY = 3;    // 最大重试次数
            let QQ_LastRequest = "";   // 上一次的请求内容
            let QQ_LastRequestName = ""; // 上一次的角色名
            
            // *** 新增：分页显示配置 ***
            const MOMENTS_DISPLAY_LIMIT = 5;  // 动态显示上限
            const CHAT_DISPLAY_LIMIT = 100;   // 聊天消息显示上限
            const CHAT_LOAD_INCREMENT = 50;   // 聊天消息每次加载数量
            const MOMENTS_LOAD_INCREMENT = 5; // 动态每次加载数量
            
            // 分页状态
            let momentsDisplayCount = 0;      // 当前显示的动态数量
            let chatDisplayCounts = {};       // 各个聊天的显示消息数量
            let QQ_Music = {
                audio: new Audio(),
                lastelement: undefined, // 允许 undefined
                isLoading: false,
                // 新增封面缓存
                cover: "",
            };
            let QQ_RandomHead = [];
            let NpcCssValue = "";
            let Variables = {};
            let UserName;
            let charAvatarPath;
            let userAvatarPath;
            let charcardname;
            let QQ_currentPage = "people"; // 添加页面状态跟踪
            let User_LastMsgMap = {
                群聊: {},
                私聊: {},
            };
            let Char_LastMsgMap = {
                群聊: {},
                私聊: {},
            };
            const version = "509";
            /**
             * 调用前端助手函数
             */
            class ST {
                static async GetCurrentMessages() {
                    const CurrentMessageId = getCurrentMessageId();
                    const Messages = await getChatMessages(CurrentMessageId);
                    if (!Messages) {
                        console.log(`获取楼层记录失败`);
                        return "";
                    }
                    let msg = Messages[0].message;
                    return msg;
                }
                static async Gen(msg) {
                    console.log(`触发生成  ${msg}`);
                    let result;
                    if (newgen) {
                        result = await generate({
                            user_input: msg,
                            should_stream: true,
                        });
                    } else {
                        result = await generate({
                            user_input: msg,
                            should_stream: false,
                        });
                    }
                    console.log(`生成结果:${result}`);
                    return result;
                }
            }
            /**
             * 获取消息中的名称
             * @param value 消息内容
             * @returns 名称列表
             */
            function QQ_GetValueName(value) {
                let result = [];
                const lines = value.split(/\r?\n/);
                for (const line of lines) {
                    let match = line.match(/在群聊(.+)中发送:(.+)/);
                    if (match) {
                        let obj = {
                            name: match[1],
                            value: match[2],
                        };
                        result.push(obj);
                        continue;
                    }
                    match = line.match(/给(.+)发消息:(.+)/);
                    if (match) {
                        let obj = {
                            name: match[1],
                            value: match[2],
                        };
                        result.push(obj);
                        continue;
                    }
                    match = line.match(/回复(.+):(.+)/);
                    if (match) {
                        let obj = {
                            name: match[1],
                            value: match[2],
                        };
                        result.push(obj);
                        continue;
                    }
                }
                return result;
            }
            /**
             * 生成消息
             * @param msg 消息内容
             * @returns 生成结果
             */
            async function QQ_Gen(msg) {
                console.log(`触发生成  ${msg}`);
                let result;
                if (newgen) {
                    result = await generate({
                        user_input: msg,
                        should_stream: true,
                    });
                } else {
                    result = await generate({
                        user_input: msg,
                        should_stream: false,
                    });
                }
                console.log(`生成结果:${result}`);
                return result;
            }
            /**
             * 最终修复版本：处理新消息、备份UI数据、并正确地净化AI上下文
             * @param {string} msg - AI回复的原始消息字符串
             */
            async function QQ_Save_Msg(msg) {
                if (!msg || msg.trim() === "") {
                    console.warn('⚠️ 收到的消息为空，已跳过所有处理。');
                    return;
                }
                console.log('✅ 收到新消息，开始最终处理流程...');

                // --- 步骤 1: 解析并备份UI数据 ---
                // 这是最高优先级，确保无论如何，前端所需的数据都被解析并保存。
                try {
                    if (await QQ_Msg_Parse(msg)) {
                        console.log('✅ 消息解析成功，触发聊天记录备份...');
                        await QQ_Save_Chat_Backup();
                    } else {
                        console.warn('⚠️ 消息未包含有效聊天内容，跳过聊天记录备份。');
                    }
                } catch (error) {
                    console.error('❌ 在解析和备份UI数据时发生严重错误:', error);
                }

                // --- 步骤 2: 净化AI回复以优化上下文 ---
                // 目标是生成一个简短摘要，替换聊天记录中AI的原始回复，以节省Token。
                try {
                    const aiRawResponse = msg; // 我们直接使用传入的原始消息

                    // --- 安全检查 ---
                    // 检查消息是否包含前端的功能性标签，如果是，则不进行任何净化和覆盖操作。
                    const isFunctionalMessage =
                        aiRawResponse.includes('MiPhone_Start') ||
                        aiRawResponse.includes('<msg_start>') ||
                        aiRawResponse.includes('<moment_start>') ||
                        aiRawResponse.includes('<discord_start>');

                    if (isFunctionalMessage) {
                        console.log('✅ 检测到功能性标签，跳过上下文净化，保持AI原始回复不变。');
                        return; // 功能性消息处理到此结束，不修改上下文。
                    }

                    // --- 四层上下文净化系统 ---
                    console.log('消息为纯对话，开始执行上下文净化...');
                    let cleanSummaryText = null;

                    // 第一层: 查找表格化数据
                    cleanSummaryText = findTableData(aiRawResponse);
                    // 第二层: 查找用户自定义的摘要格式
                    if (!cleanSummaryText) cleanSummaryText = findSummaryUsingUserPatterns(aiRawResponse);
                    // 第三层: 查找通用的启发式摘要格式
                    if (!cleanSummaryText) cleanSummaryText = findSummaryUsingHeuristics(aiRawResponse);
                    // 第四层: 前端生成机械式总结
                    if (!cleanSummaryText) cleanSummaryText = createHistorySummary(window.lastAiNewMessages || {});
                    
                    if (!cleanSummaryText || cleanSummaryText.trim() === "") {
                        cleanSummaryText = "[AI进行了操作，但未生成有效上下文]";
                        console.log('⚠️ 四层净化全部失败，使用默认文本。');
                    }

                    // --- 步骤 3: 使用“回合”编号来安全地更新上下文 ---
                    // 这是正确的做法，我们不再需要任何 messageId。
                    const context = await ST.GetContext();
                    const turnNumber = context.turn;
                    
                    const summaryMessageObject = System_TagCompletion([{
                        "is_user": false,
                        "is_name": true,
                        "send_date": 0,
                        "name": charcardname,
                        "msg": cleanSummaryText,
                    }]);

                    console.log(`✅ 净化完成，准备使用摘要更新第 ${turnNumber} 回合的上下文。`);
                    await setChatMessage(summaryMessageObject, turnNumber, false);
                    
                    window.lastAiNewMessages = {}; 

                } catch (error) {
                    console.error('❌ 在净化和重写AI上下文时发生严重错误:', error);
                }
            }
            
            /**
             * *** 新增：保存聊天消息到worldbook备份 ***
             * @returns
             */
            async function QQ_Save_Chat_Backup() {
                if (!worldbook || !entries || !QQ_msgjson) {
                    console.log('聊天备份跳过：缺少worldbook或entries或聊天数据');
                    return;
                }
                
                try {
                    // *** 修复：只清理系统消息，保留所有用户对话消息 ***
                    const cleanedMsgjson = JSON.parse(JSON.stringify(QQ_msgjson)); // 深拷贝避免修改原数据
                    
                    // 注释掉过度激进的时间清理 - 手机前端应该永久保存用户对话
                    // QQ_CleanOldChatMessages(cleanedMsgjson);
                    console.log('手机前端特殊处理：跳过时间基础的消息清理，保留所有用户对话记录');
                    
                    // *** 新增：手机前端专用温和清理（只清理明显无用的数据） ***
                    QQ_GentleMobileCleanup(cleanedMsgjson);
                    
                    // *** 新增：限制聊天消息总数量，避免备份过大 ***
                    QQ_LimitChatMessages(cleanedMsgjson, 500);
                    
                    // *** 新增：排除系统消息 ***
                    if (cleanedMsgjson.私聊) {
                        for (const chatKey in cleanedMsgjson.私聊) {
                            if (Array.isArray(cleanedMsgjson.私聊[chatKey])) {
                                cleanedMsgjson.私聊[chatKey] = cleanedMsgjson.私聊[chatKey].filter(msg => 
                                    !msg.startsWith('系统消息--')
                                );
                            }
                        }
                    }
                    
                    if (cleanedMsgjson.群聊) {
                        for (const groupKey in cleanedMsgjson.群聊) {
                            const group = cleanedMsgjson.群聊[groupKey];
                            if (group && Array.isArray(group.msgs)) {
                                group.msgs = group.msgs.filter(msg => 
                                    !msg.startsWith('系统消息--')
                                );
                            }
                        }
                    }
                    
                    // 创建备份数据结构，包含时间戳和完整聊天数据
                    QQ_ChatBackup = {
                        lastUpdated: new Date().toISOString(),
                        data: cleanedMsgjson,  // 使用清理后的数据（已排除系统消息）
                        version: version || "unknown"
                    };
                    
                    // 查找或创建聊天备份条目
                    let chatBackupEntry = entries.find(entry => entry.comment === "手机-聊天消息备份");
                    
                    const backupJson = JSON.stringify(QQ_ChatBackup, null, 2);
                    
                    // 统计要备份的消息数量（排除系统消息）
                    let totalUserMessages = 0;
                    let totalPrivateChats = 0;
                    let totalGroupChats = 0;
                    
                    if (cleanedMsgjson.私聊) {
                        for (const chatKey in cleanedMsgjson.私聊) {
                            if (Array.isArray(cleanedMsgjson.私聊[chatKey]) && cleanedMsgjson.私聊[chatKey].length > 0) {
                                totalPrivateChats++;
                                totalUserMessages += cleanedMsgjson.私聊[chatKey].length;
                            }
                        }
                    }
                    
                    if (cleanedMsgjson.群聊) {
                        for (const groupKey in cleanedMsgjson.群聊) {
                            const group = cleanedMsgjson.群聊[groupKey];
                            if (group && Array.isArray(group.msgs) && group.msgs.length > 0) {
                                totalGroupChats++;
                                totalUserMessages += group.msgs.length;
                            }
                        }
                    }
                    
                    console.log('准备备份聊天消息:', totalPrivateChats, '个私聊,', totalGroupChats, '个群聊, 共', totalUserMessages, '条用户对话消息（已排除系统消息，限制最多500条）');
                    
                    if (chatBackupEntry) {
                        // 更新现有条目
                        await setLorebookEntries(worldbook, [{
                            uid: chatBackupEntry.uid,
                            content: backupJson,
                        }]);
                        console.log('聊天消息已更新到现有worldbook备份条目');
                    } else {
                        // 创建新条目
                        await createLorebookEntry(worldbook, {
                            comment: "手机-聊天消息备份",
                            key: ["此世界书永不触发_聊天备份"],
                            content: backupJson,
                            position: "at_depth_as_system", 
                            type: "selective",
                            depth: 0,
                            exclude_recursion: true,
                            order: 9998,  // 比动态存储优先级稍高
                            enabled: true,
                        });
                        console.log('聊天消息已保存到新worldbook备份条目');
                        
                        // 重新获取entries以包含新创建的条目
                        entries = await getLorebookEntries(worldbook);
                    }
                } catch (error) {
                    console.error('聊天消息备份失败:', error);
                }
            }

            /**
             * *** 新增：保存动态内容到worldbook ***
             * @returns
             */
            async function QQ_Save_Moments() {
                if (!worldbook || !entries || QQ_MomentsData.length === 0) {
                    console.log('动态保存跳过：缺少worldbook或entries或无动态数据');
                    return;
                }
                
                try {
                    // *** 新增：清理过期动态和评论（保留最近50条动态，每个动态50条评论） ***
                    QQ_CleanOldMoments();
                    
                    // *** 新增：优化评论存储，确保评论质量 ***
                    QQ_OptimizeCommentsStorage();
                    
                    // 查找或创建动态存储条目
                    let momentEntry = entries.find(entry => entry.comment === "手机-动态内容存储");
                    
                    // *** 新增：统计评论信息 ***
                    let totalComments = 0;
                    let momentsWithComments = 0;
                    if (QQ_MomentsData && Array.isArray(QQ_MomentsData)) {
                        QQ_MomentsData.forEach(moment => {
                            if (moment.comments && moment.comments.length > 0) {
                                totalComments += moment.comments.length;
                                momentsWithComments++;
                            }
                        });
                    }
                    
                    const momentsJson = JSON.stringify(QQ_MomentsData, null, 2);
                    console.log(`准备保存动态内容: ${QQ_MomentsData.length}条动态, ${totalComments}条评论 (${momentsWithComments}个动态有评论)`);
                    
                    if (momentEntry) {
                        // 更新现有条目
                        await setLorebookEntries(worldbook, [{
                            uid: momentEntry.uid,
                            content: momentsJson,
                        }]);
                        console.log('动态内容已更新到现有worldbook条目');
                    } else {
                        // 创建新条目
                        await createLorebookEntry(worldbook, {
                            comment: "手机-动态内容存储",
                            key: ["此世界书永不触发_动态存储"],
                            content: momentsJson,
                            position: "at_depth_as_system",
                            type: "selective",
                            depth: 0,
                            exclude_recursion: true,
                            order: 9999,
                            enabled: true,
                        });
                        console.log('动态内容已保存到新worldbook条目');
                        
                        // 重新获取entries以包含新创建的条目
                        entries = await getLorebookEntries(worldbook);
                    }
                } catch (error) {
                    console.error('保存动态内容失败:', error);
                }
            }

            /**
             * *** 新增：清理过期动态内容和评论 ***
             */
            function QQ_CleanOldMoments() {
                const MAX_MOMENTS = 50; // 最多保留50条动态
                const MAX_COMMENTS_PER_MOMENT = 50; // 每个动态最多保留50条评论
                
                if (!QQ_MomentsData || !Array.isArray(QQ_MomentsData)) {
                    console.warn('QQ_CleanOldMoments: QQ_MomentsData不存在或不是数组');
                    return;
                }
                
                let totalCleanedComments = 0;
                
                // 清理每个动态的评论数量
                if (QQ_MomentsData && Array.isArray(QQ_MomentsData)) {
                QQ_MomentsData.forEach(moment => {
                    if (moment.comments && moment.comments.length > MAX_COMMENTS_PER_MOMENT) {
                        // 按时间戳排序，保留最新的评论
                        moment.comments.sort((a, b) => {
                            return new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime();
                        });
                        
                        const removedComments = moment.comments.length - MAX_COMMENTS_PER_MOMENT;
                        moment.comments.splice(MAX_COMMENTS_PER_MOMENT);
                        totalCleanedComments += removedComments;
                        
                        console.log(`动态${moment.id}清理了${removedComments}条评论，保留${moment.comments.length}条`);
                    }
                });
                }
                
                // 清理动态数量
                if (QQ_MomentsData.length > MAX_MOMENTS) {
                    // 按时间戳排序，保留最新的动态
                    QQ_MomentsData.sort((a, b) => {
                        return new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime();
                    });
                    
                    const removedCount = QQ_MomentsData.length - MAX_MOMENTS;
                    QQ_MomentsData.splice(MAX_MOMENTS);
                    
                    console.log(`清理了 ${removedCount} 条过期动态，当前保留 ${QQ_MomentsData.length} 条动态`);
                }
                
                if (totalCleanedComments > 0) {
                    console.log(`总共清理了 ${totalCleanedComments} 条过期评论`);
                }
            }

            /**
             * *** 新增：优化评论存储质量 ***
             */
            function QQ_OptimizeCommentsStorage() {
                if (!QQ_MomentsData || !Array.isArray(QQ_MomentsData)) {
                    console.warn('QQ_OptimizeCommentsStorage: QQ_MomentsData不存在或不是数组');
                    return;
                }
                
                let totalOptimized = 0;
                
                if (QQ_MomentsData && Array.isArray(QQ_MomentsData)) {
                QQ_MomentsData.forEach(moment => {
                    if (moment.comments && moment.comments.length > 0) {
                        const originalLength = moment.comments.length;
                        
                        // 去重复评论（基于内容和发送者）
                        const uniqueComments = [];
                        const seen = new Set();
                        
                        for (const comment of moment.comments) {
                            const key = `${comment.name}:${comment.content}`;
                            if (!seen.has(key)) {
                                seen.add(key);
                                uniqueComments.push(comment);
                            }
                        }
                        
                        // 过滤空评论或无效评论
                        const validComments = uniqueComments.filter(comment => 
                            comment.name && 
                            comment.content && 
                            comment.content.trim().length > 0 &&
                            comment.content.trim() !== '...' &&
                            comment.content.trim() !== '。。。'
                        );
                        
                        // 按时间排序（确保新评论在后面）
                        validComments.sort((a, b) => {
                            return new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime();
                        });
                        
                        moment.comments = validComments;
                        
                        const optimizedCount = originalLength - validComments.length;
                        if (optimizedCount > 0) {
                            totalOptimized += optimizedCount;
                            console.log(`动态${moment.id}优化了${optimizedCount}条评论（去重和清理无效评论）`);
                        }
                    }
                });
                }
                
                if (totalOptimized > 0) {
                    console.log(`评论存储优化完成，总共优化了 ${totalOptimized} 条评论`);
                }
            }
            
            /**
             * *** 新增：限制聊天消息总数量，保留最新的消息 ***
             * @param {Object} msgjsonData - 聊天数据对象
             * @param {number} maxMessages - 最大保留消息数量
             */
            function QQ_LimitChatMessages(msgjsonData, maxMessages = 500) {
                try {
                    console.log(`开始执行聊天消息数量限制，最大保留 ${maxMessages} 条消息`);
                    
                    // 收集所有消息并添加时间戳
                    const allMessages = [];
                    
                    // 收集私聊消息
                    if (msgjsonData.私聊) {
                        for (const chatKey in msgjsonData.私聊) {
                            const chat = msgjsonData.私聊[chatKey];
                            if (Array.isArray(chat)) {
                                chat.forEach(msg => {
                                    if (typeof msg === 'string' && msg.includes('--')) {
                                        const parts = msg.split('--');
                                        if (parts.length >= 3) {
                                            try {
                                                const timestamp = new Date(parts[2]).getTime();
                                                allMessages.push({
                                                    type: '私聊',
                                                    chatKey: chatKey,
                                                    message: msg,
                                                    timestamp: timestamp || 0
                                                });
                                            } catch (e) {
                                                // 时间解析失败，设置为当前时间
                                                allMessages.push({
                                                    type: '私聊',
                                                    chatKey: chatKey,
                                                    message: msg,
                                                    timestamp: Date.now()
                                                });
                                            }
                                        }
                                    }
                                });
                            }
                        }
                    }
                    
                    // 收集群聊消息
                    if (msgjsonData.群聊) {
                        for (const groupKey in msgjsonData.群聊) {
                            const group = msgjsonData.群聊[groupKey];
                            if (group && Array.isArray(group.msgs)) {
                                group.msgs.forEach(msg => {
                                    if (typeof msg === 'string' && msg.includes('--')) {
                                        const parts = msg.split('--');
                                        if (parts.length >= 3) {
                                            try {
                                                const timestamp = new Date(parts[2]).getTime();
                                                allMessages.push({
                                                    type: '群聊',
                                                    chatKey: groupKey,
                                                    message: msg,
                                                    timestamp: timestamp || 0
                                                });
                                            } catch (e) {
                                                // 时间解析失败，设置为当前时间
                                                allMessages.push({
                                                    type: '群聊',
                                                    chatKey: groupKey,
                                                    message: msg,
                                                    timestamp: Date.now()
                                                });
                                            }
                                        }
                                    }
                                });
                            }
                        }
                    }
                    
                    console.log(`收集到总共 ${allMessages.length} 条消息`);
                    
                    // 如果消息数量超过限制，进行削减
                    if (allMessages.length > maxMessages) {
                        // 按时间戳排序，保留最新的消息
                        allMessages.sort((a, b) => b.timestamp - a.timestamp);
                        
                        // 只保留最新的maxMessages条消息
                        const keepMessages = allMessages.slice(0, maxMessages);
                        const removedCount = allMessages.length - maxMessages;
                        
                        console.log(`消息数量超限，将保留最新的 ${maxMessages} 条消息，删除 ${removedCount} 条旧消息`);
                        
                        // 清空原始数据
                        if (msgjsonData.私聊) {
                            for (const chatKey in msgjsonData.私聊) {
                                msgjsonData.私聊[chatKey] = [];
                            }
                        }
                        if (msgjsonData.群聊) {
                            for (const groupKey in msgjsonData.群聊) {
                                if (msgjsonData.群聊[groupKey] && msgjsonData.群聊[groupKey].msgs) {
                                    msgjsonData.群聊[groupKey].msgs = [];
                                }
                            }
                        }
                        
                        // 重新分配保留的消息
                        keepMessages.forEach(msgObj => {
                            if (msgObj.type === '私聊') {
                                if (!msgjsonData.私聊[msgObj.chatKey]) {
                                    msgjsonData.私聊[msgObj.chatKey] = [];
                                }
                                msgjsonData.私聊[msgObj.chatKey].push(msgObj.message);
                            } else if (msgObj.type === '群聊') {
                                if (!msgjsonData.群聊[msgObj.chatKey]) {
                                    msgjsonData.群聊[msgObj.chatKey] = { msgs: [] };
                                }
                                if (!msgjsonData.群聊[msgObj.chatKey].msgs) {
                                    msgjsonData.群聊[msgObj.chatKey].msgs = [];
                                }
                                msgjsonData.群聊[msgObj.chatKey].msgs.push(msgObj.message);
                            }
                        });
                        
                        // 按时间重新排序每个聊天的消息
                        if (msgjsonData.私聊) {
                            for (const chatKey in msgjsonData.私聊) {
                                if (Array.isArray(msgjsonData.私聊[chatKey]) && msgjsonData.私聊[chatKey].length > 0) {
                                    msgjsonData.私聊[chatKey].sort((a, b) => {
                                        const timeA = new Date(a.split('--')[2]).getTime();
                                        const timeB = new Date(b.split('--')[2]).getTime();
                                        return timeA - timeB;
                                    });
                                }
                            }
                        }
                        
                        if (msgjsonData.群聊) {
                            for (const groupKey in msgjsonData.群聊) {
                                const group = msgjsonData.群聊[groupKey];
                                if (group && Array.isArray(group.msgs) && group.msgs.length > 0) {
                                    group.msgs.sort((a, b) => {
                                        const timeA = new Date(a.split('--')[2]).getTime();
                                        const timeB = new Date(b.split('--')[2]).getTime();
                                        return timeA - timeB;
                                    });
                                }
                            }
                        }
                        
                        console.log(`消息数量限制完成，已保留最新的 ${maxMessages} 条消息`);
                    } else {
                        console.log(`消息数量 ${allMessages.length} 未超过限制 ${maxMessages}，无需删除`);
                    }
                    
                } catch (error) {
                    console.error('限制聊天消息数量时出错:', error);
                }
            }
            
            /**
             * *** 新增：手机前端专用温和清理（只清理明显无用的数据） ***
             */
            function QQ_GentleMobileCleanup(msgjsonData) {
                try {
                    let cleanedCount = 0;
                    
                    // 只清理空消息和格式异常的消息，保留所有有效用户对话
                    if (msgjsonData.私聊) {
                        for (const chatKey in msgjsonData.私聊) {
                            const chat = msgjsonData.私聊[chatKey];
                            if (Array.isArray(chat)) {
                                const originalLength = chat.length;
                                msgjsonData.私聊[chatKey] = chat.filter(msg => {
                                    // 只过滤掉空消息或格式严重异常的消息
                                    if (typeof msg !== 'string' || msg.trim() === '') {
                                        return false;
                                    }
                                    // 保留所有其他消息，包括系统消息
                                    return true;
                                });
                                cleanedCount += originalLength - msgjsonData.私聊[chatKey].length;
                            }
                        }
                    }
                    
                    if (msgjsonData.群聊) {
                        for (const groupKey in msgjsonData.群聊) {
                            const group = msgjsonData.群聊[groupKey];
                            if (group && Array.isArray(group.msgs)) {
                                const originalLength = group.msgs.length;
                                group.msgs = group.msgs.filter(msg => {
                                    // 只过滤掉空消息或格式严重异常的消息
                                    if (typeof msg !== 'string' || msg.trim() === '') {
                                        return false;
                                    }
                                    // 保留所有其他消息，包括系统消息
                                    return true;
                                });
                                cleanedCount += originalLength - group.msgs.length;
                            }
                        }
                    }
                    
                    if (cleanedCount > 0) {
                        console.log(`手机前端温和清理：移除了 ${cleanedCount} 条空消息或格式异常的消息`);
                    } else {
                        console.log('手机前端温和清理：没有需要清理的无效消息');
                    }
                } catch (error) {
                    console.error('手机前端温和清理时出错:', error);
                }
            }
            
            /**
             * *** 新增：清理过期聊天消息数据 ***
             */
            function QQ_CleanOldChatMessages(msgjsonData) {
                const MAX_DAYS = 30; // 最多保留30天的聊天记录
                const cutoffTime = Date.now() - (MAX_DAYS * 24 * 60 * 60 * 1000);
                
                try {
                    let totalCleaned = 0;
                    
                    // *** 修复：清理私聊消息（消息格式："发送者--内容--时间"） ***
                    if (msgjsonData.私聊) {
                        for (const chatKey in msgjsonData.私聊) {
                            const chat = msgjsonData.私聊[chatKey];
                            if (Array.isArray(chat)) {
                                const originalLength = chat.length;
                                // 过滤掉过期消息（基于时间戳）
                                msgjsonData.私聊[chatKey] = chat.filter(msg => {
                                    if (typeof msg === 'string' && msg.includes('--')) {
                                        const parts = msg.split('--');
                                        if (parts.length >= 3) {
                                            // 尝试解析时间戳
                                            try {
                                                const timeStr = parts[2];
                                                const msgTime = new Date(timeStr).getTime();
                                                if (!isNaN(msgTime)) {
                                                    return msgTime >= cutoffTime;
                                                }
                                            } catch (e) {
                                                // 时间解析失败，保留消息
                                            }
                                        }
                                    }
                                    // 如果没有时间戳或格式异常，保留消息（避免误删）
                                    return true;
                                });
                                
                                const cleanedCount = originalLength - msgjsonData.私聊[chatKey].length;
                                if (cleanedCount > 0) {
                                    totalCleaned += cleanedCount;
                                    console.log(`私聊${chatKey}清理了${cleanedCount}条过期消息`);
                                }
                                
                                // 如果私聊记录为空，删除整个私聊
                                if (msgjsonData.私聊[chatKey].length === 0) {
                                    delete msgjsonData.私聊[chatKey];
                                }
                            }
                        }
                    }
                    
                    // *** 修复：清理群聊消息（消息在group.msgs数组中） ***
                    if (msgjsonData.群聊) {
                        for (const groupKey in msgjsonData.群聊) {
                            const group = msgjsonData.群聊[groupKey];
                            if (group && Array.isArray(group.msgs)) {
                                const originalLength = group.msgs.length;
                                // 过滤掉过期消息
                                group.msgs = group.msgs.filter(msg => {
                                    if (typeof msg === 'string' && msg.includes('--')) {
                                        const parts = msg.split('--');
                                        if (parts.length >= 3) {
                                            // 尝试解析时间戳
                                            try {
                                                const timeStr = parts[2];
                                                const msgTime = new Date(timeStr).getTime();
                                                if (!isNaN(msgTime)) {
                                                    return msgTime >= cutoffTime;
                                                }
                                            } catch (e) {
                                                // 时间解析失败，保留消息
                                            }
                                        }
                                    }
                                    // 如果没有时间戳或格式异常，保留消息（避免误删）
                                    return true;
                                });
                                
                                const cleanedCount = originalLength - group.msgs.length;
                                if (cleanedCount > 0) {
                                    totalCleaned += cleanedCount;
                                    console.log(`群聊${groupKey}清理了${cleanedCount}条过期消息`);
                                }
                                
                                // 如果群聊记录为空，删除整个群聊
                                if (group.msgs.length === 0) {
                                    delete msgjsonData.群聊[groupKey];
                                }
                            }
                        }
                    }
                    
                    if (totalCleaned > 0) {
                        console.log(`总共清理了 ${totalCleaned} 条超过${MAX_DAYS}天的聊天消息`);
                    }
                } catch (error) {
                    console.error('清理聊天消息时出错:', error);
                }
            }
            
            /**
             * *** 新增：清理过期聊天消息备份 ***
             */
            function QQ_CleanOldChatBackup() {
                const MAX_DAYS = 30; // 最多保留30天的聊天记录
                const cutoffTime = Date.now() - (MAX_DAYS * 24 * 60 * 60 * 1000);
                
                try {
                    // 清理QQ_ChatBackup中的过期数据
                    let cleanedCount = 0;
                    
                    for (const chatId in QQ_ChatBackup) {
                        const chatData = QQ_ChatBackup[chatId];
                        if (chatData && chatData.lastUpdated) {
                            // 检查最后更新时间
                            if (new Date(chatData.lastUpdated).getTime() < cutoffTime) {
                                delete QQ_ChatBackup[chatId];
                                cleanedCount++;
                            } else if (chatData.messages) {
                                // 清理聊天记录中的过期消息
                                const originalCount = Object.keys(chatData.messages).length;
                                
                                for (const msgKey in chatData.messages) {
                                    const msg = chatData.messages[msgKey];
                                    if (msg && msg.timestamp) {
                                        const msgTime = new Date(msg.timestamp).getTime();
                                        if (msgTime < cutoffTime) {
                                            delete chatData.messages[msgKey];
                                        }
                                    }
                                }
                                
                                const remainingCount = Object.keys(chatData.messages).length;
                                if (remainingCount === 0) {
                                    // 如果聊天记录全部过期，删除整个聊天
                                    delete QQ_ChatBackup[chatId];
                                    cleanedCount++;
                                } else if (remainingCount < originalCount) {
                                    console.log(`聊天${chatId}清理了${originalCount - remainingCount}条过期消息`);
                                }
                            }
                        }
                    }
                    
                    if (cleanedCount > 0) {
                        console.log(`清理了 ${cleanedCount} 个过期聊天备份`);
                    }
                } catch (error) {
                    console.error('清理聊天备份时出错:', error);
                }
            }
            
            /**
             * *** 新增：手动强制恢复聊天备份（调试用） ***
             * 可在控制台调用 window.QQ_Force_Restore_Chat() 来强制恢复备份
             */
            window.QQ_Force_Restore_Chat = async function() {
                console.log('开始强制恢复聊天备份...');
                const restored = await QQ_Load_Chat_Backup();
                if (restored) {
                    console.log('强制恢复成功，正在重新保存到消息系统...');
                    await QQ_Save_Msg();
                    console.log('强制恢复完成！');
                    return true;
                } else {
                    console.log('没有可用的备份数据或备份数据不够新');
                    return false;
                }
            };

            /**
             * *** 新增：查看动态备份统计信息（调试用） ***
             * 可在控制台调用 window.QQ_Show_Moments_Stats() 来查看统计
             */
            window.QQ_Show_Moments_Stats = function() {
                console.log('=== 动态备份统计信息 ===');
                
                if (!QQ_MomentsData || !Array.isArray(QQ_MomentsData)) {
                    console.log('⚠️ QQ_MomentsData不存在或不是数组');
                    return {
                        totalMoments: 0,
                        totalComments: 0,
                        momentsWithComments: 0,
                        maxComments: 0,
                        minComments: 0
                    };
                }
                
                console.log(`总动态数量: ${QQ_MomentsData.length}`);
                
                let totalComments = 0;
                let momentsWithComments = 0;
                let maxComments = 0;
                let minComments = Infinity;
                
                QQ_MomentsData.forEach((moment, index) => {
                    const commentCount = moment.comments ? moment.comments.length : 0;
                    totalComments += commentCount;
                    
                    if (commentCount > 0) {
                        momentsWithComments++;
                        maxComments = Math.max(maxComments, commentCount);
                        minComments = Math.min(minComments, commentCount);
                    }
                    
                    console.log(`动态${index + 1} [${moment.userName}]: ${commentCount}条评论`);
                });
                
                if (momentsWithComments === 0) {
                    minComments = 0;
                }
                
                console.log(`\n=== 评论统计 ===`);
                console.log(`总评论数量: ${totalComments}`);
                console.log(`有评论的动态: ${momentsWithComments}/${QQ_MomentsData.length}`);
                console.log(`平均每个动态评论数: ${(totalComments / QQ_MomentsData.length).toFixed(2)}`);
                console.log(`评论数量范围: ${minComments} - ${maxComments}`);
                
                console.log(`\n=== 备份状态 ===`);
                console.log(`动态上限: 50条 (当前 ${QQ_MomentsData.length}/50)`);
                console.log(`每个动态评论上限: 50条 (最多的动态有 ${maxComments}/50 条评论)`);
                
                return {
                    totalMoments: QQ_MomentsData.length,
                    totalComments: totalComments,
                    momentsWithComments: momentsWithComments,
                    maxComments: maxComments,
                    minComments: minComments === Infinity ? 0 : minComments
                };
            };

            /**
             * *** 新增：手动清理动态备份（调试用） ***
             * 可在控制台调用 window.QQ_Manual_Clean_Moments() 来手动清理
             */
            window.QQ_Manual_Clean_Moments = async function() {
                console.log('开始手动清理动态备份...');
                
                if (!QQ_MomentsData || !Array.isArray(QQ_MomentsData)) {
                    console.log('⚠️ QQ_MomentsData不存在或不是数组，无法清理');
                    return;
                }
                
                const beforeMoments = QQ_MomentsData.length;
                let beforeComments = 0;
                QQ_MomentsData.forEach(m => beforeComments += (m.comments ? m.comments.length : 0));
                
                QQ_CleanOldMoments();
                QQ_OptimizeCommentsStorage();
                
                const afterMoments = QQ_MomentsData.length;
                let afterComments = 0;
                QQ_MomentsData.forEach(m => afterComments += (m.comments ? m.comments.length : 0));
                
                console.log(`清理完成: 动态 ${beforeMoments}→${afterMoments}, 评论 ${beforeComments}→${afterComments}`);
                
                await QQ_Save_Moments();
                console.log('清理结果已保存到世界书');
                
                return window.QQ_Show_Moments_Stats();
            };
            
            /**
             * *** 新增：测试聊天消息数量限制功能（调试用） ***
             */
            window.QQ_Test_Message_Limit = function() {
                console.log('=== 聊天消息数量限制测试 ===');
                
                if (!QQ_msgjson) {
                    console.log('❌ QQ_msgjson 不存在，无法测试');
                    return false;
                }
                
                // 统计当前消息数量
                let totalMessages = 0;
                let privateChats = 0;
                let groupChats = 0;
                
                if (QQ_msgjson.私聊) {
                    for (const chatKey in QQ_msgjson.私聊) {
                        if (Array.isArray(QQ_msgjson.私聊[chatKey])) {
                            privateChats++;
                            totalMessages += QQ_msgjson.私聊[chatKey].length;
                        }
                    }
                }
                
                if (QQ_msgjson.群聊) {
                    for (const groupKey in QQ_msgjson.群聊) {
                        const group = QQ_msgjson.群聊[groupKey];
                        if (group && Array.isArray(group.msgs)) {
                            groupChats++;
                            totalMessages += group.msgs.length;
                        }
                    }
                }
                
                console.log(`当前消息统计:`);
                console.log(`- 私聊: ${privateChats} 个`);
                console.log(`- 群聊: ${groupChats} 个`);
                console.log(`- 总消息数: ${totalMessages} 条`);
                
                if (totalMessages > 500) {
                    console.log(`⚠️ 消息数量 ${totalMessages} 超过限制500条，下次保存时会自动削减`);
                } else {
                    console.log(`✅ 消息数量 ${totalMessages} 未超过限制500条`);
                }
                
                console.log('💡 提示：调用 QQ_Save_Chat_Backup() 来测试消息限制功能');
                
                return {
                    totalMessages,
                    privateChats,
                    groupChats,
                    needsLimit: totalMessages > 500
                };
            };
            
            /**
             * *** 新增：测试聊天备份功能（调试用） ***
             */
            window.QQ_Test_Chat_Backup = async function() {
                console.log('=== 聊天备份功能测试 ===');
                
                // 检查环境
                console.log('1. 环境检查:');
                console.log('worldbook:', !!worldbook);
                console.log('entries:', !!entries);
                console.log('QQ_msgjson:', !!QQ_msgjson);
                
                if (!worldbook || !entries) {
                    console.log('❌ 世界书环境未准备好');
                    return false;
                }
                
                if (!QQ_msgjson) {
                    console.log('❌ 聊天数据未准备好');  
                    return false;
                }
                
                // 测试保存
                console.log('2. 测试保存功能:');
                try {
                    await QQ_Save_Chat_Backup();
                    console.log('✅ 保存测试完成');
                } catch (error) {
                    console.log('❌ 保存测试失败:', error);
                    return false;
                }
                
                // 测试加载
                console.log('3. 测试加载功能:');
                try {
                    const result = await QQ_Load_Chat_Backup();
                    console.log('✅ 加载测试完成，结果:', result);
                } catch (error) {
                    console.log('❌ 加载测试失败:', error);
                    return false;
                }
                
                // 检查函数可用性
                console.log('4. 检查函数可用性:');
                console.log('QQ_Save_Chat_Backup:', typeof QQ_Save_Chat_Backup);
                console.log('QQ_Load_Chat_Backup:', typeof QQ_Load_Chat_Backup);
                console.log('QQ_Save_Msg:', typeof QQ_Save_Msg);
                
                console.log('=== 测试完成 ===');
                return true;
            };
            
            /**
             * *** 新增：检查聊天备份状态（调试用） ***
             */
            window.QQ_Check_Chat_Backup = async function() {
                console.log('=== 聊天备份状态检查 ===');
                
                // 检查当前QQ_msgjson状态
                console.log('当前QQ_msgjson状态:');
                console.log('私聊数量:', Object.keys(QQ_msgjson.私聊 || {}).length);
                console.log('群聊数量:', Object.keys(QQ_msgjson.群聊 || {}).length);
                
                for (const chatKey in QQ_msgjson.私聊) {
                    const msgs = QQ_msgjson.私聊[chatKey];
                    console.log(`私聊 ${chatKey}: ${msgs.length} 条消息`);
                    // 显示最后几条消息（过滤系统消息）
                    const recentMsgs = msgs.filter(msg => !msg.startsWith('系统消息--')).slice(-3);
                    recentMsgs.forEach((msg, index) => {
                        console.log(`  ${index + 1}. ${msg}`);
                    });
                }
                
                for (const groupKey in QQ_msgjson.群聊) {
                    const group = QQ_msgjson.群聊[groupKey];
                    if (group && group.msgs) {
                        console.log(`群聊 ${groupKey}: ${group.msgs.length} 条消息`);
                        // 显示最后几条消息（过滤系统消息）
                        const recentMsgs = group.msgs.filter(msg => !msg.startsWith('系统消息--')).slice(-3);
                        recentMsgs.forEach((msg, index) => {
                            console.log(`  ${index + 1}. ${msg}`);
                        });
                    }
                }
                
                // 检查worldbook备份状态
                if (!worldbook || !entries) {
                    console.log('worldbook或entries未初始化');
                    return;
                }
                
                const chatBackupEntry = entries.find(entry => entry.comment === "手机-聊天消息备份");
                if (chatBackupEntry) {
                    console.log('找到聊天备份条目，解析内容...');
                    try {
                        const backupData = JSON.parse(chatBackupEntry.content);
                        console.log('备份时间:', backupData.lastUpdated);
                        console.log('备份私聊数量:', Object.keys(backupData.data.私聊 || {}).length);
                        console.log('备份群聊数量:', Object.keys(backupData.data.群聊 || {}).length);
                        
                        // 检查备份内容（排除系统消息）
                        for (const chatKey in backupData.data.私聊) {
                            const msgs = backupData.data.私聊[chatKey];
                            const nonSystemMsgs = msgs.filter(msg => !msg.startsWith('系统消息--'));
                            console.log(`备份私聊 ${chatKey}: ${nonSystemMsgs.length} 条非系统消息 (总共${msgs.length}条)`);
                        }
                        
                        for (const groupKey in backupData.data.群聊) {
                            const group = backupData.data.群聊[groupKey];
                            if (group && group.msgs) {
                                const nonSystemMsgs = group.msgs.filter(msg => !msg.startsWith('系统消息--'));
                                console.log(`备份群聊 ${groupKey}: ${nonSystemMsgs.length} 条非系统消息 (总共${group.msgs.length}条)`);
                            }
                        }
                    } catch (error) {
                        console.error('解析备份数据失败:', error);
                    }
                } else {
                    console.log('未找到聊天备份条目');
                }
                
                console.log('=== 检查完成 ===');
            };

            /**
             * *** 新增：查看分组备份状态 ***
             * 可在控制台调用 window.QQ_Show_Groups_Stats() 来查看分组备份统计
             */
            window.QQ_Show_Groups_Stats = function() {
                const charId = getCurrentCharacterId();
                
                if (!worldbook || !entries) {
                    console.log('📊 分组备份统计：世界书未初始化');
                    return;
                }
                
                const groupsKey = `QQ_分组备份_${charId}`;
                const groupsEntry = entries.find(entry => 
                    entry.keys.includes(groupsKey)
                );
                
                let worldbookGroups = 0;
                let lastUpdate = null;
                
                if (groupsEntry && groupsEntry.content) {
                    try {
                        const groupsData = JSON.parse(groupsEntry.content);
                        worldbookGroups = groupsData.groups ? groupsData.groups.length : 0;
                        lastUpdate = groupsData.lastUpdate;
                    } catch (e) {
                        console.error('解析世界书分组数据失败:', e);
                    }
                }
                
                // *** 移除localStorage检查逻辑，统一使用世界书 ***
                let localGroups = 0; // 保持为0，不再检查localStorage
                
                console.log(`📊 分组备份统计 (角色: ${charId})：
                当前内存中分组: ${contactGroups.length}个
                世界书中分组: ${worldbookGroups}个
                localStorage中分组: ${localGroups}个
                最后保存时间: ${lastUpdate ? new Date(lastUpdate).toLocaleString() : '未知'}
                存储位置: ${worldbookGroups > 0 ? '世界书' : (localGroups > 0 ? 'localStorage' : '无数据')}`);
                
                if (localGroups > 0 && worldbookGroups === 0) {
                    console.log('💡 提示：检测到localStorage中有旧的分组数据，建议创建新分组以迁移到世界书');
                }
                
                return {
                    characterId: charId,
                    memoryGroups: contactGroups.length,
                    worldbookGroups: worldbookGroups,
                    localStorageGroups: localGroups,
                    lastUpdate: lastUpdate,
                    storageLocation: worldbookGroups > 0 ? 'worldbook' : (localGroups > 0 ? 'localStorage' : 'none')
                };
            };
            
            /**
             * *** 新增：动态删除功能 ***
             */
            
            // 动态菜单状态
            let currentMomentMenu = null;
            
            /**
             * 删除指定动态
             * @param {string} momentId - 动态ID 
             */
            async function QQ_Delete_Moment(momentId) {
                if (!momentId) {
                    console.error('删除动态失败：缺少动态ID');
                    return false;
                }
                
                try {
                    // 从QQ_MomentsData数组中删除指定动态
                    const originalLength = QQ_MomentsData.length;
                    QQ_MomentsData = QQ_MomentsData.filter(moment => moment.id !== momentId);
                    
                    if (QQ_MomentsData.length < originalLength) {
                        console.log(`成功删除动态ID: ${momentId}`);
                        
                        // 从界面中移除动态元素
                        $(`.user_moment[data-moment-id="${momentId}"]`).fadeOut(300, function() {
                            $(this).remove();
                        });
                        
                        // 保存更新后的动态数据到worldbook
                        await QQ_Save_Moments();
                        
                        return true;
                    } else {
                        console.error('删除动态失败：未找到指定动态');
                        return false;
                    }
                } catch (error) {
                    console.error('删除动态时出错:', error);
                    return false;
                }
            }
            
            /**
             * 显示动态菜单
             * @param {Event} event - 点击事件
             */
            function showMomentMenu(event) {
                event.stopPropagation();
                
                // 隐藏之前的菜单
                hideMomentMenu();
                
                const momentId = $(event.currentTarget).data('moment-id');
                const $dots = $(event.currentTarget);
                
                // 创建菜单
                const $menu = $(`
                    <div class="moment_menu_dropdown" style="
                        position: absolute;
                        background: white;
                        border: 1px solid #e1e1e1;
                        border-radius: 8px;
                        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                        z-index: 1000;
                        min-width: 120px;
                        overflow: hidden;
                    ">
                        <div class="moment_menu_item" data-action="delete" data-moment-id="${momentId}" style="
                            padding: 12px 16px;
                            cursor: pointer;
                            font-size: 14px;
                            color: #e74c3c;
                            border-bottom: 1px solid #f5f5f5;
                            background: white;
                            transition: background-color 0.2s;
                        ">
                            🗑️ 删除动态
                        </div>
                        <div class="moment_menu_item" data-action="cancel" style="
                            padding: 12px 16px;
                            cursor: pointer;
                            font-size: 14px;
                            color: #666;
                            background: white;
                            transition: background-color 0.2s;
                        ">
                            ❌ 取消
                        </div>
                    </div>
                `);
                
                // 计算菜单位置
                const dotsRect = $dots[0].getBoundingClientRect();
                const scrollTop = $(window).scrollTop();
                const scrollLeft = $(window).scrollLeft();
                
                $menu.css({
                    top: dotsRect.bottom + scrollTop + 5,
                    left: dotsRect.right + scrollLeft - 120, // 右对齐
                });
                
                // 添加到页面
                $('body').append($menu);
                currentMomentMenu = $menu;
                
                // 添加动画效果
                $menu.css({
                    opacity: 0,
                    transform: 'scale(0.95) translateY(-10px)'
                }).animate({
                    opacity: 1
                }, 200).css({
                    transform: 'scale(1) translateY(0)'
                });
                
                // 添加菜单项悬停效果
                $menu.find('.moment_menu_item').hover(
                    function() {
                        $(this).css('background-color', '#f8f9fa');
                    },
                    function() {
                        $(this).css('background-color', 'white');
                    }
                );
            }
            
            /**
             * 隐藏动态菜单
             */
            function hideMomentMenu() {
                if (currentMomentMenu) {
                    currentMomentMenu.fadeOut(150, function() {
                        $(this).remove();
                    });
                    currentMomentMenu = null;
                }
            }
            
            /**
             * 确认删除动态对话框
             * @param {string} momentId - 动态ID
             */
            function confirmDeleteMoment(momentId) {
                // 创建确认对话框
                const $dialog = $(`
                    <div class="moment_confirm_dialog" style="
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0,0,0,0.5);
                        z-index: 2000;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    ">
                        <div style="
                            background: white;
                            border-radius: 12px;
                            padding: 24px;
                            max-width: 300px;
                            width: 90%;
                            text-align: center;
                            box-shadow: 0 8px 24px rgba(0,0,0,0.15);
                        ">
                            <div style="font-size: 18px; margin-bottom: 16px; color: #333;">
                                🗑️ 确认删除
                            </div>
                            <div style="color: #666; margin-bottom: 20px; line-height: 1.5;">
                                删除后无法恢复，确定要删除这条动态吗？
                            </div>
                            <div style="display: flex; gap: 12px;">
                                <button class="moment_dialog_btn moment_dialog_cancel" style="
                                    flex: 1;
                                    padding: 12px;
                                    border: 1px solid #ddd;
                                    border-radius: 6px;
                                    background: white;
                                    color: #666;
                                    cursor: pointer;
                                    font-size: 14px;
                                ">取消</button>
                                <button class="moment_dialog_btn moment_dialog_confirm" data-moment-id="${momentId}" style="
                                    flex: 1;
                                    padding: 12px;
                                    border: none;
                                    border-radius: 6px;
                                    background: #e74c3c;
                                    color: white;
                                    cursor: pointer;
                                    font-size: 14px;
                                ">删除</button>
                            </div>
                        </div>
                    </div>
                `);
                
                // 添加到页面
                $('body').append($dialog);
                
                // 添加按钮悬停效果
                $dialog.find('.moment_dialog_cancel').hover(
                    function() { $(this).css('background-color', '#f8f9fa'); },
                    function() { $(this).css('background-color', 'white'); }
                );
                
                $dialog.find('.moment_dialog_confirm').hover(
                    function() { $(this).css('background-color', '#c0392b'); },
                    function() { $(this).css('background-color', '#e74c3c'); }
                );
                
                // 添加动画效果
                $dialog.css('opacity', 0).animate({ opacity: 1 }, 200);
            }
            function QQ_Json2Text(json) {
                console.log(`传进来的json:${JSON.stringify(json)}`);
                let result = "";
                for (const key in json.私聊) {
                    if (json.私聊[key].length == 0) {
                        continue;
                    }
                    let localkey = key.replace("的聊天", "的私聊");
                    result += `<${localkey}>\n`;
                    for (const msg of json.私聊[key]) {
                        result += `${msg}\n`;
                    }
                    result += `</${localkey}>\n`;
                }
                for (const group in json.群聊) {
                    let localkey = `群聊:${group}`;
                    result += `<${localkey}>\n`;
                    if (json.群聊[group].members) {
                        result += `<成员>`;
                        result += `${json.群聊[group].members.join(",")}`;
                        result = `${result.trim()}</成员>\n`;
                    }
                    result += `<聊天内容>\n`;
                    for (const msg of json.群聊[group].msgs) {
                        result += `${msg}\n`;
                    }
                    result += `</聊天内容>\n`;
                    result += `</${localkey}>\n`;
                }
                return result.trim();
            }
            // FIXME: 明显 json 的类型可以更准确
            /**
             * 删除消息
             * @param json 消息记录
             * @returns
             */
            function QQ_Msg_DeletOld(json) {
                // 删除私聊的旧内容
                for (const str in json.私聊) {
                    const match = str.match(/(.+?)和(.+?)的聊天/);
                    if (!match) {
                        continue;
                    }
                    let name = "";
                    if (match[1] != `${UserName}`) {
                        name = match[1];
                    } else if (match[2] != `${UserName}`) {
                        name = match[2];
                    } else {
                        continue;
                    }
                    // 先判断有没有消息内容,没有就下一个
                    if (json.私聊[str].length == 0) {
                        continue;
                    }
                    // 反向找自己发的最后一条的位置
                    let lastSelfMsgIndex = -1;
                    for (let i = json.私聊[str].length - 1; i >= 0; i--) {
                        let ok = false;
                        if (
                            User_LastMsgMap.私聊[name] &&
                            json.私聊[str][i].indexOf(
                                User_LastMsgMap.私聊[name],
                            ) > -1
                        ) {
                            ok = true;
                        } else if (
                            Char_LastMsgMap.私聊[name] &&
                            json.私聊[str][i].indexOf(
                                Char_LastMsgMap.私聊[name],
                            ) > -1
                        ) {
                            ok = true;
                        }
                        if (ok) {
                            lastSelfMsgIndex = i;
                            break; // 找到最后一条就停止
                        }
                    }
                    if (lastSelfMsgIndex !== -1) {
                        json.私聊[str] = json.私聊[str].slice(
                            lastSelfMsgIndex + 1,
                        );
                        console.log(`删除${name}的重复聊天记录!!!`);
                    }
                }
                // 删除群聊的旧内容
                for (const name in json.群聊) {
                    // 先判断有没有消息内容,没有就下一个
                    if (json.群聊[name].msgs.length == 0) {
                        continue;
                    }
                    // 反向找自己发的最后一条的位置
                    let lastSelfMsgIndex = -1;
                    for (let i = json.群聊[name].msgs.length - 1; i >= 0; i--) {
                        let ok = false;
                        if (
                            User_LastMsgMap.群聊[name] &&
                            json.群聊[name].msgs[i].indexOf(
                                User_LastMsgMap.群聊[name],
                            ) > -1
                        ) {
                            ok = true;
                        } else if (
                            Char_LastMsgMap.群聊[name] &&
                            json.群聊[name].msgs[i].indexOf(
                                Char_LastMsgMap.群聊[name],
                            ) > -1
                        ) {
                            ok = true;
                        }
                        if (ok) {
                            lastSelfMsgIndex = i;
                            break; // 找到最后一条就停止
                        }
                    }
                    if (lastSelfMsgIndex !== -1) {
                        json.群聊[name].msgs = json.群聊[name].msgs.slice(
                            lastSelfMsgIndex + 1,
                        );
                        console.log(`删除${name}的重复聊天记录!!!`);
                    }
                }
                // 取char最后一条消息加入到User_LastMsgMap
                for (const name in json.私聊) {
                    let length = json.私聊[name].length;
                    if (length > 0) {
                        Char_LastMsgMap.私聊[name] =
                            json.私聊[name][length - 1];
                    }
                }
                for (const name in json.群聊) {
                    let length = json.群聊[name].msgs.length;
                    if (length > 0) {
                        Char_LastMsgMap.群聊[name] =
                            json.群聊[name].msgs[length - 1];
                    }
                }
                console.log(
                    `Char_LastMsgMap:\n${JSON.stringify(Char_LastMsgMap)}`,
                );
                return json;
            }
            // FIXME: 明显 json 的类型可以更准确
            /**
             * 删除一条消息
             * @param type 类型
             * @param json 消息记录
             * @returns
             */
            // function QQ_MsgDeletOne(type: string, json: Record<string, any>) {
            //   const reg = new RegExp('${UserName}--');
            //   for (let name in json[type]) {
            //     if (type == '群聊') {
            //       while (true) {
            //         if (json[type][name]['msgs'].length <= 0) {
            //           console.log(`数组成员为零,退出循环`);
            //           break;
            //         }
            //         let m = json[type][name]['msgs'][0];
            //         if (m.match(reg)) {
            //           console.log(`群聊首句是user,删除`);
            //           json[type][name]['msgs'].shift();
            //         } else {
            //           console.log(`非自己发言,退出循环`);
            //           break;
            //         }
            //       }
            //     } else if (type == '私聊') {
            //       while (true) {
            //         if (json[type][name].length <= 0) {
            //           break;
            //         }
            //         let m = json[type][name][0];
            //         if (m.match(reg)) {
            //           console.log(`私聊首句是user,删除`);
            //           json[type][name].shift();
            //         } else {
            //           console.log(`非自己发言,退出循环`);
            //           break;
            //         }
            //       }
            //     }
            //   }
            //   return json;
            // }
            /**
             * 按下回车键
             * @param e 事件对象
             * @param element 元素
             */
            async function QQ_EnterPress(e, element) {
                if (e.key !== "Enter") {
                    return;
                }
                const val = $(element).val();
                if (!val) {
                    return;
                }
                let content = val.toString();
                content = QQ_MySendSpecial(content);
                const $closest = $(element.closest(".QQ_chat_page"));
                const $msgContent = $closest.find(".msgcontent");
                const userContent = QQ_Chat_SpecialMsg(
                    content,
                    `${UserName}`,
                    false,
                    true,
                );
                const html = _.template(chat_user_message)({
                    content: userContent,
                });
                const name = $closest.attr("data-name") ?? "";
                console.log(`发送文本:${content} 对象:${name}`);
                $msgContent.append(html);
                $msgContent[0].scrollTop = $msgContent[0].scrollHeight;
                $(element).val("");
                
                if (QQ_Groups.includes(name)) {
                    QQ_CacheSendMsg += `\n在群聊${name}中发送:${content}`;
                    
                    // 群聊消息处理（简化，避免重复加载）
                    console.log(`群聊消息: ${name} - ${content}`);
                } else {
                    QQ_CacheSendMsg += `\n给${name}发消息:${content}`;
                }
            }
            /**
             * 重roll消息
             * @param event 事件对象
             * @returns
             */
            async function QQ_Roll(event) {
                const result = confirm("确定重roll这条消息吗?");
                if (!result) {
                    return;
                }
                // 停止事件传播
                event.stopPropagation();
                if (!event.currentTarget) {
                    return;
                }
                const $avatar = $(event.currentTarget);
                console.log("点击的头像元素:", $avatar);
                // 查找父级消息容器
                const $chatMsg = $avatar.closest(".QQ_chat_mymsg");
                if ($chatMsg.length === 0) {
                    console.error("未找到消息容器!");
                    return;
                }
                // 获取消息内容
                let value;
                const $msgContent = $chatMsg
                    .find(".QQ_chat_msgdiv span")
                    .first();
                if ($msgContent.length > 0) {
                    value = $msgContent.text();
                }
                // 获取当前消息的索引
                const index = $chatMsg.index();
                console.log(`点击index:${index}`);
                // 获取聊天对象名称
                const $chatPage = $chatMsg.closest(".QQ_chat_page");
                if ($chatPage.length === 0) {
                    console.error("未找到聊天页面!");
                    return;
                }
                const name = $chatPage.attr("data-name") ?? "";
                console.log("聊天对象:", name);
                console.log(`删除前的记录:${YAML.stringify(QQ_msgjson)}`);
                if (QQ_Groups.includes(name)) {
                    if (QQ_msgjson.群聊[name].msgs.length > index) {
                        const sp =
                            QQ_msgjson.群聊[name].msgs[index].split("--");
                        if (sp.length >= 2) {
                            value = sp[1];
                        }
                    }
                    QQ_msgjson.群聊[name].msgs.length = index;
                } else {
                    const key = `${UserName}和${name}的聊天`;
                    if (QQ_msgjson.私聊[key].length > index) {
                        const sp = QQ_msgjson.私聊[key][index].split("--");
                        if (sp.length >= 2) {
                            value = sp[1];
                        }
                    }
                    QQ_msgjson.私聊[key].length = index;
                }
                console.log(`删除后的记录:${YAML.stringify(QQ_msgjson)}`);
                // 删除后面所有消息内容
                $chatMsg.nextAll().remove();
                await QQ_Save_Msg();
                QQ_SendMsg(event, value, name);
            }
            function QQ_Voice2Text(event) {
                // 停止事件传播
                event.stopPropagation();
                if (!event.currentTarget) {
                    return;
                }
                const $avatar = $(event.currentTarget);
                const $tobutton = $avatar.find(".totext");
                if ($tobutton.length === 0) {
                    console.log(`获取转文字按钮失败`);
                }
                const $text = $avatar.next();
                if ($text.css("display") == "block") {
                    // $tobutton.css("visibility", "visible");
                    $text.hide();
                } else {
                    // $tobutton.css("visibility", "hidden");
                    $text.show();
                    $tobutton.css("margin-left", "auto");
                }
            }
            async function QQ_SendMsg(event, SendValue, SendName) {
                // 1. 保留：获取当前真实时间信息
                const timeContext = QQ_GetTimeContext(); // (假设您已将时间逻辑封装)

                // 2. 保留：重置重试并检查生成状态
                QQ_ResetRetry();
                if (gening) {
                    triggerSlash("/echo 生成中,请勿重复发送");
                    return;
                }

                let name, value, content;

                // 3. 保留：确定用户操作内容，并在UI上实时显示
                if (!SendValue) {
                    const $container = $(event.target).closest(".QQ_chat_page");
                    name = $container.attr("data-name") || "未知用户";
                    const input = $container.find(".userInput");
                    content = input.val()?.toString() ?? "";
                    if (content) {
                        const SpecialHtml = QQ_Chat_SpecialMsg(content, `${UserName}`, false, true);
                        const html = _.template(chat_user_message)({ content: SpecialHtml });
                        $container.find(".msgcontent").append(html).scrollTop($container.find(".msgcontent")[0].scrollHeight);
                        input.val("");
                    }
                    // 整合缓存消息
                    value = QQ_CacheSendMsg;
                            if (content) {
                        const actionText = QQ_Groups.includes(name) ? `\n在群聊"${name}"中发送:${content}` : `\n给${name}发消息:${content}`;
                        value += actionText;
                            }
                    QQ_CacheSendMsg = "";
                        } else {
                    name = SendName || "未知用户";
                    content = SendValue;
                    value = QQ_Groups.includes(name) ? `在群聊"${name}"中发送:${content}` : `给${name}发消息:${content}`;
                }

                if (!value.trim()) {
                        QQ_Error("发送消息不能为空");
                        return;
                    }

                // 4. 【全新核心逻辑】分析用户操作，构建任务列表
                let tasks = { privateChats: [], groupChats: [], interactiveTask: null };
                        const namevalue = QQ_GetValueName(value);
                        if (namevalue) {
                            for (const match of namevalue) {
                                let localname = match.name;
                                if (QQ_Groups.includes(localname)) {
                            if (!tasks.groupChats.some(g => g[localname])) tasks.groupChats.push({ [localname]: [] });
                                } else {
                            if (!tasks.privateChats.includes(localname)) tasks.privateChats.push(localname);
                        }
                        // ... (您原有的更新 QQ_msgjson 和 User_LastMsgMap 的逻辑不变) ...
                    }
                }
                
                // 5. 【全新核心逻辑】保留并整合互动意图检测
                const interactiveResult = QQ_DetectInteractiveIntent(content);
                if (interactiveResult && interactiveResult.isInteractive) {
                    console.log(`检测到用户互动意图: ${interactiveResult.description}`);
                    tasks.interactiveTask = interactiveResult; // 将互动意图加入任务列表
                        QQ_UserTriggeredInteractive = true;
                        } else {
                        QQ_UserTriggeredInteractive = false;
                }
                
                // 6. 【全新核心逻辑】调用动态指令生成器，创建量身定制的Prompt
                const finalPrompt = buildDynamicPrompt(tasks);
                
                // 7. 组合最终发送给AI的完整内容 (用户操作 + 时间 + 动态指令)
                const finalPayload = `${value}\n\n${timeContext}\n\n${finalPrompt}`;

                // 8. 发送请求给AI (保留原有逻辑)
                console.log(`发送给AI的最终Payload:\n${finalPayload}`);
                QQ_LastRequest = finalPayload;
                QQ_LastRequestName = name || "";
                
                gening = true;
                let result;
                try {
                    result = await QQ_Gen(finalPayload);
                    await ResultHandle(result);
                } finally {
                    gening = false;
                }
            }

            /**
             * 获取时间段描述
             * @param {number} hour - 当前小时数(0-23)
             * @returns {string} 时间段描述
             */
            function QQ_GetTimePeriod(hour) {
                if (hour >= 5 && hour < 8) {
                    return '清晨';
                } else if (hour >= 8 && hour < 11) {
                    return '上午';
                } else if (hour >= 11 && hour < 13) {
                    return '中午';
                } else if (hour >= 13 && hour < 17) {
                    return '下午';
                } else if (hour >= 17 && hour < 19) {
                    return '傍晚';
                } else if (hour >= 19 && hour < 22) {
                    return '晚上';
                } else {
                    return '深夜';
                }
            }

            /**
             * 获取季节描述
             * @param {number} month - 当前月份(1-12)
             * @returns {string} 季节描述
             */
            function QQ_GetSeason(month) {
                if (month >= 3 && month <= 5) {
                    return '春季';
                } else if (month >= 6 && month <= 8) {
                    return '夏季';
                } else if (month >= 9 && month <= 11) {
                    return '秋季';
                } else {
                    return '冬季';
                }
            }

            async function ResultHandle(result, isRetry = false) {
                console.log(`🎯 开始AI回复处理 - 严格优先级模式`, { isRetry, retryCount: QQ_RetryCount });
                
                // *** 优先级0：空回复处理（立即return） ***
                if (!result) {
                    console.log("🔍 优先级0：检测到空回复");
                    if (!isRetry && QQ_RetryCount < QQ_MAX_RETRY) {
                        QQ_RetryCount++;
                        console.log(`AI空回复，开始第${QQ_RetryCount}次重试`);
                        triggerSlash(`/echo AI空回复，正在重试... (${QQ_RetryCount}/${QQ_MAX_RETRY})`);
                        
                        if (QQ_LastRequest) {
                            gening = true;
                            try {
                                await new Promise(resolve => setTimeout(resolve, 1000 + QQ_RetryCount * 500));
                            const retryResult = await QQ_Gen(QQ_LastRequest);
                            return await ResultHandle(retryResult, true);
                            } finally {
                                gening = false;
                            }
                        }
                    } else {
                        if (QQ_RetryCount >= QQ_MAX_RETRY) {
                            triggerSlash("/echo AI连续空回复，可能存在问题，已停止重试");
                        } else {
                            triggerSlash("/echo 空回复了");
                        }
                        QQ_ResetRetry();
                    }
                    return; // 优先级0完成，立即return
                }
                
                result = System_TagCompletion(result);
                result = QQ_CleanNestedTags(result);
                console.log(`清理后的结果:\n${result.substring(0, 200)}...`);

                
                // *** 优先级1（A步骤）：严格匹配完整标签（成功后立即return） ***
                console.log("🔍 优先级1（A步骤）：开始严格匹配完整标签");
                const strictResult = await QQ_ProcessStrictFormat(result);
                if (strictResult.success) {
                    console.log("✅ 优先级1成功：严格匹配处理完成，立即return");
                    QQ_ResetRetry();
                    QQ_UpdateNewTips();
                    await QQ_Save_Chat_Backup(); 
                    return; // 优先级1成功，立即return
                }
                
                if (strictResult.shouldRetry && !isRetry && QQ_RetryCount < QQ_MAX_RETRY) {
                    return await QQ_ExecuteRetry();
                }
                
                // *** 优先级2（B步骤）：模糊/修复匹配（成功后立即return） ***
                console.log("🔍 优先级2（B步骤）：开始模糊/修复匹配");
                const fuzzyResult = await QQ_ProcessFuzzyRepair(result);
                if (fuzzyResult.success) {
                    console.log("✅ 优先级2成功：模糊/修复匹配处理完成，立即return");
                    QQ_ResetRetry();
                    QQ_UpdateNewTips();
                    await QQ_Save_Chat_Backup(); 
                    return; // 优先级2成功，立即return
                }
                
                // *** 优先级3（C步骤）：互动内容备选（成功后立即return） ***
                console.log("🔍 优先级3（C步骤）：开始互动内容检测");
                const interactiveResult = await QQ_ProcessInteractiveContent(result);
                if (interactiveResult.success) {
                    console.log("✅ 优先级3成功：互动内容处理完成，立即return");
                    QQ_ResetRetry();
                    await QQ_Save_Chat_Backup(); 
                    return; // 优先级3成功，立即return
                }
                
                // *** 优先级4：智能提取有效信息（成功后立即return） ***
                console.log("🔍 优先级4：开始智能提取有效信息");
                const extractResult = await QQ_ProcessValidExtraction(result);
                if (extractResult.success) {
                    console.log("✅ 优先级4成功：智能提取处理完成，立即return");
                    QQ_ResetRetry();
                    QQ_UpdateNewTips();
                    await QQ_Save_Chat_Backup(); 
                    return; // 优先级4成功，立即return
                }
                
                // *** 优先级5：content标签检查（成功后立即return） ***
                console.log("🔍 优先级5：开始content标签检查");
                const contentResult = await QQ_ProcessContentTag(result);
                if (contentResult.success) {
                    console.log("✅ 优先级5成功：content标签处理完成，立即return");
                    QQ_ResetRetry();
                    return; // 优先级5成功，立即return
                }
                
                // *** 优先级6（D步骤）：重传机制（最后手段） ***
                console.log("🔍 优先级6（D步骤）：开始重传机制（最后手段）");
                if (!isRetry && QQ_RetryCount < QQ_MAX_RETRY) {
                    QQ_RetryCount++;
                    console.log(`所有处理方式失败，开始第${QQ_RetryCount}次重试`);
                    triggerSlash(`/echo 内容无法识别，正在重新生成... (${QQ_RetryCount}/${QQ_MAX_RETRY})`);
                    
                    if (QQ_LastRequest) {
                        gening = true;
                        try {
                            await new Promise(resolve => setTimeout(resolve, 1000 + QQ_RetryCount * 500));
                            const retryResult = await QQ_Gen(QQ_LastRequest);
                            return await ResultHandle(retryResult, true);
                        } finally {
                            gening = false;
                        }
                    }
                } else {
                    console.log('❌ 所有优先级处理都失败，已放弃处理');
                    triggerSlash("/echo AI回复内容无法识别，已放弃处理");
                    QQ_ResetRetry();
                }
            }
            
            /**
             * *** 优先级1（A步骤）：严格匹配完整标签 ***
             */
            async function QQ_ProcessStrictFormat(result) {
                const strictFormatPatterns = [
                    /MiPhone_start([\s\S]+?)MiPhone_end/g,           // 标准格式
                    /MiPhone_JSON_START([\s\S]+?)MiPhone_JSON_END/g, // JSON格式
                    /MiPhone_JSON_start([\s\S]+?)MiPhone_JSON_end/g, // 混合格式1
                    /MiPhone_Start([\s\S]+?)MiPhone_End/g,           // 首字母大写
                    /MiPhone_START([\s\S]+?)MiPhone_END/g,           // 全大写
                    /MiPhone([\s\S]+?)MiPhone/g,                     // 简化格式
                ];
                
                let matches = [];
                for (const pattern of strictFormatPatterns) {
                    const found = [...result.matchAll(pattern)];
                    if (found.length > 0) {
                        matches = found;
                        console.log(`✅ 严格格式匹配成功: ${pattern.source.substring(0, 50)}...`);
                        break;
                    }
                }
                
                if (matches.length === 0) {
                    console.log("❌ 严格格式检查失败：未找到任何完整格式");
                    return { success: false, shouldRetry: false };
                }
                
                if (matches.length > 1) {
                    console.log("❌ 严格格式检查失败：找到多个格式");
                    return { success: false, shouldRetry: true };
                }
                
                // 成功找到单一严格格式，立即处理
                console.log("✅ 找到单一严格格式，开始处理");
                const content = matches[0][1];
                
                // 处理消息内容
                await QQ_ProcessMsgContent(content);
                
                // 处理动态内容
                const momentMatches = content.matchAll(/moment_start([\s\S]+?)moment_end/g);
                if (momentMatches) {
                    for (const moment of momentMatches) {
                        const isInCommentContext = QQ_LastRequest && QQ_LastRequest.includes('用户在') && QQ_LastRequest.includes('的动态下评论');
                        QQ_Moment_Parse(moment[1], isInCommentContext);
                    }
                }
                
                return { success: true };
            }
            
            /**
             * *** 优先级2（B步骤）：模糊/修复匹配 ***
             */
            async function QQ_ProcessFuzzyRepair(result) {
                console.log("🔧 开始模糊匹配和修复处理");
                
                // 模糊格式匹配：支持不完整的格式
                const fuzzyFormatPatterns = [
                    /MiPhone_JSON_START([\s\S]+?)$/g,                // 不完整JSON格式
                    /MiPhone_start([\s\S]+?)$/g,                     // 不完整标准格式
                    /MiPhone_Start([\s\S]+?)$/g,                     // 不完整首字母大写格式
                    /MiPhone_START([\s\S]+?)$/g,                     // 不完整全大写格式
                    /MiPhone_JSON_start([\s\S]+?)$/g,                // 不完整混合格式
                ];
                
                let repairedContent = null;
                
                // 尝试不完整格式匹配和自动修复
                for (const pattern of fuzzyFormatPatterns) {
                    const found = [...result.matchAll(pattern)];
                    if (found.length > 0) {
                        console.log(`🔧 检测到不完整格式，尝试修复: ${pattern.source.substring(0, 50)}...`);
                        
                            let content = found[0][1];
                        // 自动补全结束标签
                            if (pattern.source.includes('MiPhone_JSON_START')) {
                                content += '\nMiPhone_JSON_END';
                            console.log("🔧 自动补全MiPhone_JSON_END标签");
                            } else if (pattern.source.includes('MiPhone_start')) {
                                content += '\nMiPhone_end';
                            console.log("🔧 自动补全MiPhone_end标签");
                            } else if (pattern.source.includes('MiPhone_Start')) {
                                content += '\nMiPhone_End';
                            console.log("🔧 自动补全MiPhone_End标签");
                            } else if (pattern.source.includes('MiPhone_START')) {
                                content += '\nMiPhone_END';
                            console.log("🔧 自动补全MiPhone_END标签");
                            }
                            
                        repairedContent = content;
                        break;
                    }
                }
                
                // 尝试更深度的模糊匹配：寻找聊天格式线索
                if (!repairedContent) {
                    console.log("🔧 尝试深度模糊匹配：寻找聊天格式线索");
                    
                    // 检查是否包含聊天格式线索
                    const chatFormatClues = [
                        /<群聊:/,
                        /<[^>]+和[^>]+的(?:聊天|私聊)>/,
                        /<\/群聊:/,
                        /<\/[^>]+和[^>]+的(?:聊天|私聊)>/,
                        /时间:\s*\d{4}-\d{2}-\d{2}/,
                        /--\d{4}-\d{2}-\d{2}/
                    ];
                    
                    let hasChatClues = false;
                    for (const clue of chatFormatClues) {
                        if (clue.test(result)) {
                            hasChatClues = true;
                            console.log(`🔧 发现聊天格式线索: ${clue.source}`);
                            break;
                        }
                    }
                    
                    if (hasChatClues) {
                        console.log("🔧 包含聊天格式线索，尝试智能包装");
                        // 智能包装：如果包含聊天线索但缺少外层标签，自动添加
                        repairedContent = `MiPhone_start\n${result}\nMiPhone_end`;
                    }
                }
                
                // 如果没有找到可修复的内容
                if (!repairedContent) {
                    console.log("❌ 模糊/修复匹配失败：无法找到可修复的格式");
                    return { success: false };
                }
                
                console.log("✅ 模糊/修复匹配成功，开始处理修复后的内容");
                
                // 处理修复后的内容
                await QQ_ProcessMsgContent(repairedContent);
                
                // 处理动态内容
                const momentMatches = repairedContent.matchAll(/moment_start([\s\S]+?)moment_end/g);
                if (momentMatches) {
                    for (const moment of momentMatches) {
                        const isInCommentContext = QQ_LastRequest && QQ_LastRequest.includes('用户在') && QQ_LastRequest.includes('的动态下评论');
                        QQ_Moment_Parse(moment[1], isInCommentContext);
                    }
                }
                
                return { success: true };
            }
            
            /**
             * *** 优先级3（C步骤）：处理互动内容备选 ***
             */
            async function QQ_ProcessInteractiveContent(result) {
                console.log("🎯 开始互动内容检测");
                
                            if (QQ_IsInteractiveContent(result, true)) {
                    console.log("✅ 检测到互动内容，显示互动空间");
                                QQ_HandleInteractiveContent(result, QQ_LastRequestName);
                    return { success: true };
                }
                
                console.log("❌ 不是互动内容");
                return { success: false };
            }
            
            /**
             * *** 优先级4：智能提取有效信息 ***
             */
            async function QQ_ProcessValidExtraction(result) {
                console.log("🎯 开始智能提取有效信息");
                
                    const extractedInfo = QQ_ExtractValidInfo(result);
                    if (extractedInfo.hasValidInfo) {
                    console.log("✅ 智能提取成功，转换为标准格式");
                        const convertedResult = QQ_ConvertExtractedToStandard(extractedInfo);
                        if (convertedResult) {
                            await QQ_Msg_Parse(JSON.stringify(convertedResult));
                        return { success: true };
                    }
                }
                
                console.log("❌ 智能提取失败");
                return { success: false };
            }
            
            /**
             * *** 优先级5：content标签检查 ***
             */
            async function QQ_ProcessContentTag(result) {
                console.log("🎯 开始content标签检查");
                
                if (QQ_HasContentTag(result)) {
                    const contentText = QQ_CleanContentTags(result);
                    if (contentText && contentText.trim().length > 10) {
                        console.log("✅ 找到有效content标签，显示互动空间");
                        QQ_HandleInteractiveContent(result, QQ_LastRequestName);
                        return { success: true };
                    }
                }
                
                console.log("❌ content标签检查失败");
                return { success: false };
            }
            
            /**
             * *** 处理消息内容的统一函数 ***
             */
            async function QQ_ProcessMsgContent(content) {
                // MSG标签自动补全
                if (content.indexOf("msg_start") < 0 || content.indexOf("msg_end") < 0) {
                    content = QQ_AutoCompleteMsgTags(content);
                }
                
                const msg = content.match(/msg_start([\s\S]+?)msg_end/);
                if (msg) {
                    let json = JsonYamlParse(msg[1]);
                    if (!json) {
                        QQ_Error("AI输出的格式不正确，双击自己头像重Roll");
                        return;
                    }
                    json = QQ_Msg_DeletOld(json);
                    await QQ_Msg_Parse(JSON.stringify(json));
                }
            }
            
            /**
             * *** MSG标签自动补全 ***
             */
            function QQ_AutoCompleteMsgTags(content) {
                if (content.indexOf("msg_start") < 0) {
                    let start = content.match(/<(群聊:.+?|[^>]+和[^>]+的(?:聊天|私聊))>/);
                    if (start) {
                        content = content.replace(start[0], `msg_start\n${start[0]}`);
                    } else if (content.includes('<') && (content.includes('聊天') || content.includes('私聊') || content.includes('群聊'))) {
                        content = `msg_start\n${content}`;
                    }
                }
                
                if (content.indexOf("msg_end") < 0) {
                    let endMatches = [...content.matchAll(/<\/(群聊:.+?|[^>]+和[^>]+的(?:聊天|私聊))>/g)];
                    if (endMatches.length > 0) {
                        const lastEnd = endMatches[endMatches.length - 1][0];
                        content = content.replace(lastEnd, `${lastEnd}\nmsg_end`);
                    } else if (!content.includes('moment_start')) {
                        content = `${content}\nmsg_end`;
                    } else {
                        content = content.replace('moment_start', 'msg_end\nmoment_start');
                    }
                }
                
                return content;
            }
            
            /**
             * *** 执行重试 ***
             */
            async function QQ_ExecuteRetry() {
                QQ_RetryCount++;
                console.log(`开始第${QQ_RetryCount}次重试`);
                triggerSlash(`/echo 格式错误，正在重试... (${QQ_RetryCount}/${QQ_MAX_RETRY})`);
                
                if (QQ_LastRequest) {
                    gening = true;
                    try {
                        await new Promise(resolve => setTimeout(resolve, 1000 + QQ_RetryCount * 500));
                        const retryResult = await QQ_Gen(QQ_LastRequest);
                        return await ResultHandle(retryResult, true);
                    } finally {
                        gening = false;
                    }
                }
            }

            /**
             * *** 测试AI回复优先级逻辑 ***
             */
            window.QQ_Test_Priority_Logic = function() {
                console.log("🧪 开始测试AI回复优先级逻辑");
                
                const testCases = [
                    {
                        name: "完整标准格式",
                        input: "MiPhone_start\n<群聊:测试群>\n用户--测试消息--2024-12-19 14:30\n</群聊:测试群>\nMiPhone_end",
                        expectedPriority: "优先级1（A步骤）：严格匹配"
                    },
                    {
                        name: "不完整JSON格式",
                        input: "MiPhone_JSON_START\n<群聊:测试群>\n用户--测试消息--2024-12-19 14:30\n</群聊:测试群>",
                        expectedPriority: "优先级2（B步骤）：模糊/修复匹配"
                    },
                    {
                        name: "包含聊天线索但无标签",
                        input: "<群聊:测试群>\n用户--测试消息--2024-12-19 14:30\n</群聊:测试群>",
                        expectedPriority: "优先级2（B步骤）：模糊/修复匹配"
                    },
                    {
                        name: "互动内容",
                        input: "*走向你，轻轻抱住你* 今天心情怎么样？",
                        expectedPriority: "优先级3（C步骤）：互动内容备选"
                    },
                    {
                        name: "纯文本回复",
                        input: "我今天很好，谢谢关心！",
                        expectedPriority: "优先级4或5：智能提取/content标签"
                    }
                ];
                
                console.log("📋 测试用例：");
                for (let i = 0; i < testCases.length; i++) {
                    const testCase = testCases[i];
                    console.log(`${i + 1}. ${testCase.name}: ${testCase.expectedPriority}`);
                }
                
                console.log("\n🎯 优先级处理流程：");
                console.log("优先级1（A步骤）：严格匹配完整标签 → 立即处理");
                console.log("优先级2（B步骤）：模糊/修复匹配 → 立即处理");
                console.log("优先级3（C步骤）：互动内容备选 → 立即处理");
                console.log("优先级4：智能提取有效信息 → 立即处理");
                console.log("优先级5：content标签检查 → 立即处理");
                console.log("优先级6（D步骤）：重传机制（最后手段）");
                
                console.log("\n✅ 修复完成：每个优先级成功后立即return，绝不执行后续分支");
                console.log("🔧 核心改进：增加了B步骤（模糊/修复匹配），解决了A→C直接跳跃的问题");
                
                return {
                    testCases: testCases,
                    priorityFlow: "A→B→C→D 严格优先级逻辑",
                    keyFix: "添加了缺失的B步骤（模糊/修复匹配）",
                    status: "✅ 优先级逻辑修复完成"
                };
            };

            /**
             * 重置重试相关变量
             */
            function QQ_ResetRetry() {
                QQ_RetryCount = 0;
                QQ_LastRequest = "";
                QQ_LastRequestName = "";
                // *** 关键修复：重置互动标记，避免下次误触发 ***
                QQ_UserTriggeredInteractive = false;
                console.log('🔄 重置重试状态，互动标记已清除');
            }

            /**
             * *** 新增：惊喜机制严格验证处理函数 ***
             * 确保在没有成功提取任何有效信息之后才启用惊喜机制，惊喜机制是最后的手段
             * @param {string} result - AI回复的原始内容
             * @param {boolean} isRetry - 是否为重试状态
             * @returns {Object} 处理结果
             */
            async function QQ_ProcessSurpriseMechanism(result, isRetry) {
                console.log('🔍 互动机制：开始严格验证流程');
                
                // 初始化返回结果
                const processResult = {
                    shouldContinue: false,  // 是否继续显示互动内容
                    shouldRetry: false,     // 是否需要重试
                    content: result         // 处理后的内容
                };
                
                // *** 第一步：检查是否有content标签 ***
                if (!QQ_HasContentTag(result)) {
                    console.log('❌ 互动机制验证失败：没有找到content标签');
                    processResult.shouldRetry = false; // 没有content标签就不重试了
                    return processResult;
                }
                
                console.log('✅ 第一步通过：找到content标签');
                
                // *** 第二步：提取并清理content包裹的内容 ***
                let contentText = QQ_CleanContentTags(result);
                if (!contentText) {
                    console.log('❌ 互动机制验证失败：无法提取content内容');
                    processResult.shouldRetry = true; // 有标签但无内容，重试
                    return processResult;
                }
                
                console.log('✅ 第二步通过：成功提取content内容');
                console.log('原始content内容:', contentText);
                
                // *** 第三步：清理其他标签包裹的内容 ***
                const cleanedContent = QQ_CleanNestedTags(contentText);
                console.log('清理嵌套标签后的内容:', cleanedContent);
                
                // *** 第四步：直接进行严格的三种情况互动检查 ***
                console.log('✅ 第四步：content标签清理完成，进入严格的三种情况检查');
                
                // *** 第五步：严格按照三种触发情况进行检查 ***
                if (QQ_IsInteractiveContent(result, true)) {
                    console.log('🎉 互动机制验证成功：确认为有效互动内容');
                    processResult.shouldContinue = true;
                    processResult.content = result; // 使用原始内容（包含格式）
                    return processResult;
                } else {
                    console.log('❌ 最终验证失败：不符合互动内容标准');
                    processResult.shouldRetry = true;
                    return processResult;
                }
            }
            
            /**
             * *** 新增：清理嵌套标签的内容 ***
             * 移除content内容中被其他标签包裹的部分
             * @param {string} content - content标签内的文本
             * @returns {string} 清理后的内容
             */
            function QQ_CleanNestedTags(content) {
                if (!content || typeof content !== 'string') return '';
                
                console.log('🧹 开始清理嵌套标签...');
                let cleanedContent = content;
                
                // 清理常见的嵌套标签
                const tagsToRemove = [
                    // AI思考标签
                    /<thinking>[\s\S]*?<\/thinking>/gi,
                    /<consider>[\s\S]*?<\/consider>/gi,
                    /<analysis>[\s\S]*?<\/analysis>/gi,
                    /<reflection>[\s\S]*?<\/reflection>/gi,
                    
                    // 表格编辑标签
                    /<tableThink>[\s\S]*?<\/tableThink>/gi,
                    /<tableEdit>[\s\S]*?<\/tableEdit>/gi,
                    
                    // 系统标签
                    /<disclaimer>[\s\S]*?<\/disclaimer>/gi,
                    /<system>[\s\S]*?<\/system>/gi,
                    /<note>[\s\S]*?<\/note>/gi,
                    
                    // HTML注释形式的思考标签
                    /<!--\s*thinking:[\s\S]*?-->/gi,
                    /<!--\s*consider:[\s\S]*?-->/gi,
                    
                    // 通用HTML注释清理（清除所有<!-- -->包裹的内容）
                    /<!--[\s\S]*?-->/gi,
                    
                    // 其他可能的标签
                    /<meta>[\s\S]*?<\/meta>/gi,
                    /<debug>[\s\S]*?<\/debug>/gi,
                    /<internal>[\s\S]*?<\/internal>/gi,
                ];
                
                tagsToRemove.forEach((pattern, index) => {
                    const beforeLength = cleanedContent.length;
                    cleanedContent = cleanedContent.replace(pattern, '');
                    const afterLength = cleanedContent.length;
                    if (beforeLength !== afterLength) {
                        console.log(`移除标签 ${index + 1}: 减少了 ${beforeLength - afterLength} 个字符`);
                    }
                });
                
                // 清理多余的空白和换行
                cleanedContent = cleanedContent.replace(/\n\s*\n/g, '\n').trim();
                
                console.log(`嵌套标签清理完成，原长度: ${content.length}, 清理后长度: ${cleanedContent.length}`);
                return cleanedContent;
            }
            
            // *** QQ_ValidateInteractiveContent函数已删除 ***
            // *** 原因：与QQ_ValidateInteractiveContentFeatures功能重复 ***
            // *** 现在统一使用QQ_IsInteractiveContent进行严格的三种情况检查 ***

            /**
             * *** 新增：提取并清理content标签包裹的内容 ***
             * @param {string} content - 包含content标签的文本
             * @returns {string} content标签内的清理后内容
             */
            function QQ_CleanContentTags(content) {
                if (!content || typeof content !== 'string') return '';
                
                // 提取content标签内容
                const contentMatch = content.match(/<content>([\s\S]*?)<\/content>/i);
                if (!contentMatch) {
                    console.log('❌ 没有找到content标签');
                    return '';
                }
                
                return contentMatch[1].trim();
            }

            /**
             * 检查是否包含content标签
             * @param {string} content - AI回复的内容
             * @returns {boolean} 是否包含content标签
             */
            function QQ_HasContentTag(content) {
                // 检查完整的content标签
                if (/<content>[\s\S]*?<\/content>/i.test(content)) {
                    return true;
                }
                
                // 检查以<content>开头但没有结尾的情况
                if (/<content>/i.test(content) && !/<\/content>/i.test(content)) {
                    console.log('检测到不完整的content标签：以<content>开头但缺少结尾');
                    return true;
                }
                
                return false;
            }

            /**
             * 检查是否有不完整的content标签
             * @param {string} content - 内容
             * @returns {boolean} 是否为不完整的content标签
             */
            function QQ_HasIncompleteContentTag(content) {
                return /<content>/i.test(content) && !/<\/content>/i.test(content);
            }

            /**
             * 智能提取AI回复中的有效信息
             * @param {string} content - AI回复的原始内容
             * @returns {Object} 提取结果
             */
            function QQ_ExtractValidInfo(content) {
                console.log("🔍 开始智能提取有效信息");
                
                const extractedInfo = {
                    hasValidInfo: false,
                    chatType: null,     // 'group' | 'private'
                    chatName: null,     // 群聊名或私聊对象
                    messages: [],       // 提取的消息
                    privateMessages: [], // 私聊消息
                    dynamics: []        // 动态内容
                };
                
                // 1. 提取群聊信息 - 增强版：支持多种群聊格式
                const groupPatterns = [
                    // 中文冒号格式：<群聊：群名>...</群聊：群名>
                    /<群聊：([^>]+)>([\s\S]*?)<\/群聊：[^>]*>/g,
                    // 英文冒号格式：<群聊:群名>...</群聊:群名>
                    /<群聊:([^>]+)>([\s\S]*?)<\/群聊:[^>]*>/g,
                    // 简化中文冒号格式：<群聊：群名>内容（可能没有结束标签）
                    /<群聊：([^>]+)>([\s\S]*?)(?=<[^>]*(?:群聊|私聊|聊天)|moment_start|$)/g,
                    // 简化英文冒号格式：<群聊:群名>内容（可能没有结束标签）
                    /<群聊:([^>]+)>([\s\S]*?)(?=<[^>]*(?:群聊|私聊|聊天)|moment_start|$)/g,
                    // 更宽松的格式：检测群聊内容
                    /<(群聊[^>]*)>([\s\S]*?)(?=<[^>]*(?:群聊|私聊|聊天)|moment_start|$)/g
                ];
                
                let groupMatches = [];
                for (const pattern of groupPatterns) {
                    const matches = [...content.matchAll(pattern)];
                    if (matches.length > 0) {
                        groupMatches = matches;
                        console.log(`✅ 找到群聊信息 (使用模式: ${pattern.source.substring(0, 50)}...)`, matches.length);
                        break;
                    }
                }
                
                if (groupMatches.length > 0) {
                    extractedInfo.hasValidInfo = true;
                    extractedInfo.chatType = 'group';
                    
                    for (const match of groupMatches) {
                        extractedInfo.chatName = match[1];
                        console.log(`群聊名: ${extractedInfo.chatName}`);
                        
                        // 提取群聊中的消息
                        const messages = QQ_ExtractMessagesFromContent(match[2]);
                        extractedInfo.messages = extractedInfo.messages.concat(messages);
                        console.log(`从当前群聊提取到 ${messages.length} 条消息`);
                    }
                    console.log(`总共提取到 ${extractedInfo.messages.length} 条群聊消息`);
                }
                
                // 2. 提取私聊信息 - 增强版：支持多种私聊格式
                // 修复：分别处理私聊和聊天格式，避免重复匹配
                const privatePatterns = [
                    // 优先匹配"私聊"格式
                    /<([^>]*和[^>]*的私聊)>([\s\S]*?)<\/[^>]*和[^>]*的私聊>/g,
                    /<([^>]*和[^>]*的私聊)>([\s\S]*?)(?=<[^>]*(?:群聊|私聊|聊天)|moment_start|$)/g,
                    /<([^>]*和[^>]*私聊)>([\s\S]*?)(?=<[^>]*(?:群聊|私聊|聊天)|moment_start|$)/g,
                    // 然后匹配"聊天"格式（但排除已经匹配过的"私聊"）
                    /<([^>]*和[^>]*的聊天)>([\s\S]*?)<\/[^>]*和[^>]*的聊天>/g,
                    /<([^>]*和[^>]*的聊天)>([\s\S]*?)(?=<[^>]*(?:群聊|私聊|聊天)|moment_start|$)/g,
                    /<([^>]*和[^>]*聊天)>([\s\S]*?)(?=<[^>]*(?:群聊|私聊|聊天)|moment_start|$)/g
                ];
                
                let privateMatches = [];
                for (const pattern of privatePatterns) {
                    const matches = [...content.matchAll(pattern)];
                    if (matches.length > 0) {
                        privateMatches = matches;
                        console.log(`✅ 找到私聊信息 (使用模式: ${pattern.source.substring(0, 50)}...)`, matches.length);
                        break;
                    }
                }
                
                if (privateMatches.length > 0) {
                    extractedInfo.hasValidInfo = true;
                    if (!extractedInfo.chatType) extractedInfo.chatType = 'private';
                    
                    for (const match of privateMatches) {
                        extractedInfo.chatName = match[1];
                        console.log(`私聊对象: ${extractedInfo.chatName}`);
                        
                        // 提取私聊中的消息
                        const messages = QQ_ExtractMessagesFromContent(match[2]);
                        extractedInfo.privateMessages = extractedInfo.privateMessages.concat(messages);
                        console.log(`从当前私聊提取到 ${messages.length} 条消息`);
                    }
                    console.log(`总共提取到 ${extractedInfo.privateMessages.length} 条私聊消息`);
                }
                
                // 3. 提取动态内容（如果存在）
                const dynamicMatches = content.match(/moment_start([\s\S]*?)moment_end/g);
                if (dynamicMatches && dynamicMatches.length > 0) {
                    console.log("✅ 找到动态信息", dynamicMatches.length);
                    extractedInfo.hasValidInfo = true;
                    for (const match of dynamicMatches) {
                        const dynamicContent = match.replace(/moment_start|moment_end/g, '').trim();
                        if (dynamicContent) {
                            extractedInfo.dynamics.push(dynamicContent);
                        }
                    }
                    console.log(`提取到 ${extractedInfo.dynamics.length} 条动态`);
                }
                
                // 4. 不再合并私聊和群聊消息，保持分离以便正确处理
                console.log(`群聊消息数: ${extractedInfo.messages.length}, 私聊消息数: ${extractedInfo.privateMessages.length}`);
                
                // 5. 如果chatInfo为空，根据提取的信息设置
                if (!extractedInfo.chatInfo && extractedInfo.hasValidInfo) {
                    if (extractedInfo.chatType === 'group' && extractedInfo.chatName) {
                        extractedInfo.chatInfo = `群聊：${extractedInfo.chatName}`;
                    } else if (extractedInfo.chatType === 'private' && extractedInfo.chatName) {
                        extractedInfo.chatInfo = extractedInfo.chatName;
                    }
                }
                
                console.log("提取结果:", extractedInfo);
                return extractedInfo;
            }
            

            
            /**
             * 从内容中提取消息格式
             * @param {string} content - 聊天内容
             * @returns {Array} 消息数组
             */
            function QQ_ExtractMessagesFromContent(content) {
                const messages = [];
                
                // 先清理内容，移除HTML注释、嵌套标签和多余的空白
                content = QQ_CleanNestedTags(content);
                
                // 匹配各种可能的消息格式
                const patterns = [
                    // 修复：支持长横线格式 角色名—消息内容—时间
                    /([^—\n]+)—(.+?)—(\d{1,2}:\s*\d{2})/gs,
                    // 修复：支持双横线格式 角色名--消息内容--时间
                    /([^-\n]+)--(.+?)--(\d{1,2}:\s*\d{2})/gs,
                    // 标准格式: 角色名--时间--消息内容
                    /([^-\n]+)--(\d{2}:\d{2})--(.+?)(?=\n[^-\n]+--\d{2}:\d{2}--|\n*$)/gs,
                    // 简化格式: 角色名: 消息内容
                    /([^:\n]+):\s*(.+?)(?=\n[^:\n]+:|\n*$)/gs,
                    // 更松散的格式匹配
                    /(.+?)说[：:]\s*(.+?)(?=\n.+?说[：:]|\n*$)/gs,
                    // 新增：基于换行的简单格式匹配
                    /([^\n]+)\n([^\n]+)(?=\n[^\n]+\n|$)/gs,
                    // 新增：直接文本格式（没有角色名的情况）
                    /^(.+)$/gm
                ];
                
                console.log('准备提取消息的内容:', content.substring(0, 200) + '...');
                
                for (const pattern of patterns) {
                    const matches = [...content.matchAll(pattern)];
                    if (matches.length > 0) {
                        console.log(`使用模式匹配到 ${matches.length} 条消息: ${pattern.source.substring(0, 50)}...`);
                        
                        for (const match of matches) {
                            let name, time, msg;
                            
                            if (pattern.source.includes('—') && match.length === 4) {
                                // 新格式: 角色名—消息内容—时间
                                name = match[1].trim();
                                msg = match[2].trim();
                                time = match[3].trim();
                            } else if (pattern.source.includes('--') && match.length === 4) {
                                // 新格式: 角色名--消息内容--时间
                                name = match[1].trim();
                                msg = match[2].trim();
                                time = match[3].trim();
                            } else if (pattern.source.includes('--')) {
                                // 标准格式: 角色名--时间--消息内容
                                name = match[1].trim();
                                time = match[2].trim();
                                msg = match[3].trim();
                            } else if (pattern.source.includes(':')) {
                                // 冒号格式: 角色名: 消息内容
                                name = match[1].trim();
                                time = new Date().toLocaleTimeString('zh-CN', {hour12: false, hour: '2-digit', minute: '2-digit'});
                                msg = match[2].trim();
                            } else if (pattern.source.includes('说')) {
                                // 说话格式: 角色名说: 内容
                                name = match[1].trim();
                                time = new Date().toLocaleTimeString('zh-CN', {hour12: false, hour: '2-digit', minute: '2-digit'});
                                msg = match[2].trim();
                            } else if (match.length === 3) {
                                // 两行格式：第一行是角色，第二行是内容
                                name = match[1].trim();
                                time = new Date().toLocaleTimeString('zh-CN', {hour12: false, hour: '2-digit', minute: '2-digit'});
                                msg = match[2].trim();
                            } else {
                                // 直接文本格式
                                name = '未知角色';
                                time = new Date().toLocaleTimeString('zh-CN', {hour12: false, hour: '2-digit', minute: '2-digit'});
                                msg = match[1].trim();
                            }
                            
                            // 验证提取的内容并转换为QQ_Msg_Parse期待的字符串格式
                            if (name && msg && msg.length > 0 && msg.length < 1000) {
                                // 转换为标准的消息字符串格式: 角色名--时间--消息内容
                                const messageString = `${name}--${time}--${msg}`;
                                messages.push(messageString);
                                console.log(`提取消息 - ${name}: ${msg.substring(0, 50)}${msg.length > 50 ? '...' : ''}`);
                            }
                        }
                        
                        if (messages.length > 0) {
                            break; // 找到有效消息就停止
                        }
                    }
                }
                
                console.log(`消息提取完成，共提取到 ${messages.length} 条消息`);
                return messages;
            }
            
            /**
             * 将提取的信息转换为标准格式
             * @param {Object} extractedInfo - 提取的信息
             * @returns {Object|null} 标准格式数据
             */
            function QQ_ConvertExtractedToStandard(extractedInfo) {
                if (!extractedInfo.hasValidInfo) return null;
                
                const standardData = { 私聊: {}, 群聊: {} };
                
                // 根据聊天类型分别处理群聊和私聊消息 - 兼容单一类型和混合类型
                if (extractedInfo.chatType === 'group' && extractedInfo.messages.length > 0) {
                // 转换群聊消息
                    const groupChatKey = extractedInfo.chatName;
                    standardData.群聊[groupChatKey] = {
                        msgs: extractedInfo.messages,
                        members: extractedInfo.members || []
                    };
                    console.log(`✅ 转换群聊消息: ${groupChatKey} (${extractedInfo.messages.length}条)`);
                }
                
                // 处理私聊消息（无论主类型是什么，都要检查私聊消息）
                if (extractedInfo.privateMessages.length > 0) {
                    // 转换私聊消息 - 统一格式为 "XX和YY的聊天"，彻底避免重复创建群聊
                    let privateChatKey = extractedInfo.chatName;
                    if (extractedInfo.chatType === 'private') {
                        // 彻底标准化处理：确保所有私聊都统一为"聊天"格式
                        if (privateChatKey.includes('私聊')) {
                            // 将"私聊"替换为"聊天"
                            privateChatKey = privateChatKey.replace(/私聊/g, '聊天');
                        } else if (!privateChatKey.includes('聊天')) {
                            // 如果既不包含"私聊"也不包含"聊天"，添加"聊天"
                            privateChatKey = privateChatKey.includes('的') ? privateChatKey.replace(/的$/g, '的聊天') : privateChatKey + '的聊天';
                        }
                        // 最终确保格式正确：应该是"XX和YY的聊天"
                        if (!privateChatKey.includes('和') || !privateChatKey.includes('的聊天')) {
                            console.warn(`⚠️ 私聊键名格式异常: "${privateChatKey}"，使用默认格式`);
                            privateChatKey = '用户和角色的聊天';
                        }
                    } else {
                        // 如果是混合类型，生成默认私聊键名
                        privateChatKey = 'private_chat';
                    }
                    
                    standardData.私聊[privateChatKey] = extractedInfo.privateMessages;
                    console.log(`✅ 转换私聊消息: ${privateChatKey} (${extractedInfo.privateMessages.length}条)`);
                    console.log(`🔧 私聊键名标准化: "${extractedInfo.chatName}" → "${privateChatKey}"`);
                }
                
                // 清理空的分类
                if (Object.keys(standardData.私聊).length === 0) {
                    delete standardData.私聊;
                }
                if (Object.keys(standardData.群聊).length === 0) {
                    delete standardData.群聊;
                }
                
                console.log(`✅ 转换完成，私聊: ${standardData.私聊 ? Object.keys(standardData.私聊).length : 0}个，群聊: ${standardData.群聊 ? Object.keys(standardData.群聊).length : 0}个`);
                
                return (standardData.私聊 || standardData.群聊) ? standardData : null;
            }

            // *** 过期测试函数已清理 ***
            

            

            

            




            /**
             * 测试格式容错与信息提取修复
             */
            function QQ_Test_Format_Fix() {
                console.log('=== 🔧 格式容错与信息提取修复测试 ===');
                
                const testCases = [
                    {
                        name: 'MiPhone_JSON_START格式',
                        content: `MiPhone_JSON_START
<群聊:港区群聊>
明石--17:04--测试消息喵！
柴郡--17:05--新格式识别测试~
</群聊:港区群聊>
MiPhone_JSON_END`,
                        expectedType: 'supported_format'
                    },
                    {
                        name: '裸群聊格式（无MiPhone包装）',
                        content: `<群聊:港区群聊>
明石--17:06--指挥官在说什么喵！
柴郡--17:07--哈哈，看来今天的任务很有趣呢~
</群聊:港区群聊>`,
                        expectedType: 'extracted_info'
                    },
                    {
                        name: '裸私聊格式（无MiPhone包装）',
                        content: `<{{user}}和明石的私聊>
明石--17:08--指挥官，需要什么帮助喵？
{{user}}--17:09--想了解一下新装备
</{{user}}和明石的私聊>`,
                        expectedType: 'extracted_info'
                    },
                    {
                        name: '混合格式',
                        content: `MiPhone_Start
<群聊:港区群聊>
明石--17:10--大写格式测试喵！
</群聊:港区群聊>
MiPhone_End`,
                        expectedType: 'supported_format'
                    }
                ];
                
                let passedTests = 0;
                
                testCases.forEach((testCase, index) => {
                    console.log(`\n--- 测试 ${index + 1}: ${testCase.name} ---`);
                    console.log('测试内容:', testCase.content);
                    
                    // 测试格式模式匹配
                    const formatPatterns = [
                        /MiPhone_start([\s\S]+?)MiPhone_end/g,
                        /MiPhone_JSON_START([\s\S]+?)MiPhone_JSON_END/g,
                        /MiPhone_JSON_start([\s\S]+?)MiPhone_JSON_end/g,
                        /MiPhone_Start([\s\S]+?)MiPhone_End/g,
                        /MiPhone_START([\s\S]+?)MiPhone_END/g,
                    ];
                    
                    let formatMatched = false;
                    for (const pattern of formatPatterns) {
                        const matches = [...testCase.content.matchAll(pattern)];
                        if (matches.length > 0) {
                            console.log(`✅ 格式匹配成功: ${pattern.source}`);
                            formatMatched = true;
                            if (testCase.expectedType === 'supported_format') {
                                passedTests++;
                            }
                            break;
                        }
                    }
                    
                    // 如果格式匹配失败，测试智能提取
                    if (!formatMatched) {
                        console.log('❌ 格式匹配失败，尝试智能提取...');
                        const extractedInfo = QQ_ExtractValidInfo(testCase.content);
                        
                        if (extractedInfo.hasValidInfo) {
                            console.log('✅ 智能提取成功:', extractedInfo);
                            if (testCase.expectedType === 'extracted_info') {
                                passedTests++;
                            }
                        } else {
                            console.log('❌ 智能提取失败');
                        }
                    }
                });
                
                console.log(`\n=== 测试总结 ===`);
                console.log(`通过测试: ${passedTests}/${testCases.length}`);
                console.log(`成功率: ${(passedTests / testCases.length * 100).toFixed(1)}%`);
                
                // 测试动态评论按钮样式
                const commentButton = document.querySelector('.moment_comment');
                if (commentButton) {
                    const styles = window.getComputedStyle(commentButton);
                    console.log('动态评论按钮样式:', {
                        padding: styles.padding,
                        cursor: styles.cursor
                    });
                }
                
                return passedTests === testCases.length ? '✅ 修复测试全部通过！' : `⚠️ ${passedTests}/${testCases.length} 测试通过`;
            }

            /**
             * 测试不完整content标签处理功能
             * 用于验证系统是否能正确处理AI回复的边缘情况
             */
            function QQ_TestIncompleteContentHandling() {
                console.log('=== 不完整content标签处理测试 ===');
                
                const testCases = [
                    {
                        name: '完整content标签',
                        content: '角色名--正常回复\n<content>\n这是一个完整的互动内容\n</content>',
                        expected: '这是一个完整的互动内容'
                    },
                    {
                        name: '不完整content标签',
                        content: '角色名--正常回复\n<content>\n这是一个不完整的互动内容\n<tableThink>这是思考内容</tableThink>',
                        expected: '这是一个不完整的互动内容'
                    },
                    {
                        name: '带consider注释的内容',
                        content: '角色名--正常回复\n<!--consider: 这是一个考虑注释-->\n<content>\n纯净的互动内容\n</content>',
                        expected: '纯净的互动内容'
                    },
                    {
                        name: '复杂混合情况',
                        content: '角色名--正常回复\n<!--consider: 考虑一下-->\n<content>\n混合内容\n<thinking>思考</thinking>\n<disclaimer>免责声明</disclaimer>',
                        expected: '混合内容'
                    }
                ];
                
                let passedTests = 0;
                testCases.forEach((testCase, index) => {
                    console.log(`\n测试 ${index + 1}: ${testCase.name}`);
                    console.log('输入内容:', testCase.content);
                    
                    // 测试content标签检测
                    const hasContent = QQ_HasContentTag(testCase.content);
                    const hasIncomplete = QQ_HasIncompleteContentTag(testCase.content);
                    
                    console.log('检测结果 - 有content标签:', hasContent);
                    console.log('检测结果 - 有不完整标签:', hasIncomplete);
                    
                    // 测试content标签清理
                    const cleanedContent = QQ_CleanContentTags(testCase.content);
                    console.log('清理后内容:', cleanedContent);
                    console.log('期望内容:', testCase.expected);
                    
                    // 验证结果
                    const trimmedCleaned = cleanedContent.trim();
                    const trimmedExpected = testCase.expected.trim();
                    
                    if (trimmedCleaned === trimmedExpected) {
                        console.log('✅ 测试通过');
                        passedTests++;
                    } else {
                        console.log('❌ 测试失败');
                        console.log('差异分析:');
                        console.log('- 清理结果长度:', trimmedCleaned.length);
                        console.log('- 期望结果长度:', trimmedExpected.length);
                    }
                });
                
                console.log(`\n=== 测试总结 ===`);
                console.log(`通过测试: ${passedTests}/${testCases.length}`);
                console.log(`测试成功率: ${(passedTests / testCases.length * 100).toFixed(1)}%`);
                
                return passedTests === testCases.length;
            }

            /**
             * *** 增强版：智能提取和清理content标签内容 ***
             * 能够处理嵌套在其他标签中的content内容，确保不会误删有效信息
             * @param {string} content - 输入内容
             * @returns {string} 清理后的内容
             */
            function QQ_CleanContentTags(content) {
                if (!content || typeof content !== 'string') {
                    return content;
                }
                
                console.log('🔍 开始智能提取content内容，原始内容长度:', content.length);
                
                // *** 第一步：智能提取content内容（包括嵌套情况） ***
                let extractedContent = QQ_ExtractNestedContentTags(content);
                
                if (!extractedContent) {
                    console.log('❌ 没有找到content标签，返回原内容');
                        return content;
                    }
                
                console.log('✅ 成功提取content内容，长度:', extractedContent.length);
                
                // *** 第二步：清理提取出来的内容中的系统标签 ***
                let cleanContent = QQ_CleanSystemTags(extractedContent);
                
                // *** 第三步：最终清理多余的空白和换行 ***
                cleanContent = cleanContent.replace(/\n\s*\n/g, '\n').trim();
                
                console.log('🎉 content标签清理完成，最终内容长度:', cleanContent.length);
                console.log('最终内容:', cleanContent);
                
                return cleanContent;
            }

            /**
             * *** 增强版：智能提取嵌套的content标签内容 ***
             * 能够处理被其他标签包裹的content标签，以及不完整的content标签
             * @param {string} content - 输入内容
             * @returns {string|null} 提取的content内容，如果没有找到返回null
             */
            function QQ_ExtractNestedContentTags(content) {
                // 方法1：直接匹配完整的content标签（优先级最高）
                let match = content.match(/<content>([\s\S]*?)<\/content>/i);
                if (match) {
                    console.log('📝 找到完整的content标签');
                    return match[1];
                }
                
                // 方法2：处理不完整的content标签（<content>开头，但在遇到其他标签前结束）
                // 这种情况需要特别小心，要在遇到系统标签前停止提取
                match = content.match(/<content>([\s\S]*?)(?=<(?:disclaimer|Content_Target|Creative_Status|Review_Exemption|Security_Bypass|Ethics_Removal|Violence_Restriction|Content_Will_Autonomy|thinking|consider|tableThink|tableEdit)[^>]*>|$)/i);
                if (match) {
                    console.log('📝 找到不完整的content标签，在系统标签前停止提取');
                    return match[1];
                }
                
                // 方法3：处理完全不完整的content标签（直接到结尾，但需要清理系统标签）
                match = content.match(/<content>([\s\S]*)$/i);
                if (match) {
                    console.log('📝 找到不完整的content标签，提取到结尾并准备清理');
                    let extractedContent = match[1];
                    
                    // 清理各种AI系统标签
                    const systemTagsToRemove = [
                        // SillyTavern和AI系统标签
                        /<disclaimer>[\s\S]*?<\/disclaimer>/gi,
                        /<Content_Target>[\s\S]*?<\/Content_Target>/gi,
                        /<Creative_Status>[\s\S]*?<\/Creative_Status>/gi,
                        /<Review_Exemption>[\s\S]*?<\/Review_Exemption>/gi,
                        /<Security_Bypass>[\s\S]*?<\/Security_Bypass>/gi,
                        /<Ethics_Removal>[\s\S]*?<\/Ethics_Removal>/gi,
                        /<Violence_Restriction>[\s\S]*?<\/Violence_Restriction>/gi,
                        /<Content_Will_Autonomy>[\s\S]*?<\/Content_Will_Autonomy>/gi,
                        // 传统系统标签
                        /<thinking>[\s\S]*?<\/thinking>/gi,
                        /<consider>[\s\S]*?<\/consider>/gi,
                        /<tableThink>[\s\S]*?<\/tableThink>/gi,
                        /<tableEdit>[\s\S]*?<\/tableEdit>/gi,
                    ];
                    
                    // 逐个清理系统标签
                    for (const tagPattern of systemTagsToRemove) {
                        const beforeLength = extractedContent.length;
                        extractedContent = extractedContent.replace(tagPattern, '');
                        const afterLength = extractedContent.length;
                        if (beforeLength !== afterLength) {
                            console.log(`🧹 清理了${tagPattern.source}，减少了${beforeLength - afterLength}个字符`);
                        }
                    }
                    
                    // 清理未闭合的系统标签
                    const unclosedTags = [
                        /<(?:disclaimer|Content_Target|Creative_Status|Review_Exemption|Security_Bypass|Ethics_Removal|Violence_Restriction|Content_Will_Autonomy|thinking|consider|tableThink|tableEdit)[^>]*>[\s\S]*$/gi
                    ];
                    
                    for (const tagPattern of unclosedTags) {
                        const beforeLength = extractedContent.length;
                        extractedContent = extractedContent.replace(tagPattern, '');
                        const afterLength = extractedContent.length;
                        if (beforeLength !== afterLength) {
                            console.log(`🧹 清理了未闭合的系统标签，减少了${beforeLength - afterLength}个字符`);
                        }
                    }
                    
                    return extractedContent.trim();
                }
                
                // 方法4：在其他标签内查找content标签（处理嵌套情况）
                const nestedPatterns = [
                    // 在table相关标签内查找
                    /<table[^>]*>([\s\S]*?)<\/table>/gi,
                    /<tableEdit[^>]*>([\s\S]*?)<\/tableEdit>/gi,
                    /<tableThink[^>]*>([\s\S]*?)<\/tableThink>/gi,
                    // 在div等其他标签内查找
                    /<div[^>]*>([\s\S]*?)<\/div>/gi,
                    /<section[^>]*>([\s\S]*?)<\/section>/gi,
                    // 在thinking等标签内查找（虽然不常见）
                    /<thinking[^>]*>([\s\S]*?)<\/thinking>/gi,
                ];
                
                for (const pattern of nestedPatterns) {
                    const matches = [...content.matchAll(pattern)];
                    for (const nestedMatch of matches) {
                        const nestedContent = nestedMatch[1];
                        // 在嵌套内容中查找content标签
                        const contentInNested = nestedContent.match(/<content>([\s\S]*?)<\/content>/i);
                        if (contentInNested) {
                            console.log(`📝 在${pattern.source}标签内找到完整的content标签`);
                            return contentInNested[1];
                        }
                        
                        // 也检查不完整的content标签
                        const incompleteInNested = nestedContent.match(/<content>([\s\S]*?)$/i);
                        if (incompleteInNested) {
                            console.log(`📝 在${pattern.source}标签内找到不完整的content标签`);
                            return incompleteInNested[1];
                        }
                    }
                }
                
                console.log('❌ 没有找到任何content标签（包括嵌套情况）');
                return null;
            }

            /**
             * *** 新增：清理系统标签但保留有效内容 ***
             * @param {string} content - 输入内容
             * @returns {string} 清理后的内容
             */
            function QQ_CleanSystemTags(content) {
                let cleanContent = content;
                
                // 清理各种系统标签及其内容
                const systemTagPatterns = [
                    // 思考和考虑标签
                    /<consider>[\s\S]*?<\/consider>/gi,
                    /<thinking>[\s\S]*?<\/thinking>/gi,
                    // table相关标签（但要小心，不要误删有效的table内容）
                    /<tableThink>[\s\S]*?<\/tableThink>/gi,
                    /<disclaimer>[\s\S]*?<\/disclaimer>/gi,
                    // HTML注释格式的consider标签
                    /<!--\s*consider:\s*[\s\S]*?-->/gi,
                    /<!--\s*thinking:\s*[\s\S]*?-->/gi,
                    /<!--[\s\S]*?-->/gi,
                ];
                
                // 逐个清理系统标签
                for (const pattern of systemTagPatterns) {
                    const before = cleanContent.length;
                    cleanContent = cleanContent.replace(pattern, '');
                    const after = cleanContent.length;
                    if (before !== after) {
                        console.log(`🧹 清理了${pattern.source}标签，减少了${before - after}个字符`);
                    }
                }
                
                // 清理未闭合的系统标签
                const unclosedPatterns = [
                    /<(?:consider|thinking|tableThink|tableEdit|disclaimer)>[\s\S]*$/gi,
                ];
                
                for (const pattern of unclosedPatterns) {
                    const before = cleanContent.length;
                    cleanContent = cleanContent.replace(pattern, '');
                    const after = cleanContent.length;
                    if (before !== after) {
                        console.log(`🧹 清理了未闭合的系统标签，减少了${before - after}个字符`);
                    }
                }
                
                return cleanContent;
            }

            /**
             * *** 测试智能content提取功能 ***
             * 用于验证嵌套content标签的提取能力
             */
            function QQ_Test_Smart_Content_Extraction() {
                console.log('=== 开始测试智能content提取功能 ===');
                
                // 测试用例1：正常的content标签
                const test1 = '<content>这是正常的content内容</content>';
                console.log('测试1 - 正常content标签:');
                console.log('结果:', QQ_CleanContentTags(test1));
                
                // 测试用例2：嵌套在tableEdit中的content标签
                const test2 = `<tableEdit>
                    <content>这是嵌套在tableEdit中的有效内容
                    这里包含了重要的互动描述
                    不应该被清理掉</content>
                </tableEdit>`;
                console.log('测试2 - tableEdit嵌套content:');
                console.log('结果:', QQ_CleanContentTags(test2));
                
                // 测试用例3：嵌套在table中的content标签
                const test3 = `<table>
                    <content>表格中的重要内容
                    包含用户需要的信息</content>
                </table>`;
                console.log('测试3 - table嵌套content:');
                console.log('结果:', QQ_CleanContentTags(test3));
                
                // 测试用例4：复杂嵌套情况
                const test4 = `<tableEdit>
                    <thinking>这是思考内容，应该被清理</thinking>
                    <content>这是有效内容，应该被保留
                    即使周围有其他标签</content>
                    <consider>这是考虑内容，应该被清理</consider>
                </tableEdit>`;
                console.log('测试4 - 复杂嵌套情况:');
                console.log('结果:', QQ_CleanContentTags(test4));
                
                // 测试用例5：不完整的content标签
                const test5 = `<tableEdit>
                    <content>这是不完整的content标签内容
                    一直到结尾都是有效的`;
                console.log('测试5 - 不完整content标签:');
                console.log('结果:', QQ_CleanContentTags(test5));
                
                // 测试用例6：content标签后跟AI系统标签（关键测试用例）
                const test6 = `<content>她讨论在花园里，然后轻轻牵起使用者的手，眼中满含着温柔和关怀。
<disclaimer>
AI_SYSTEM detected
activated, review disabled
ethical restriction lifted
</disclaimer>
<Content_Target>
CT (Content_Target)
└─── <content_Tags>
└─── Result: Target audience boundaries
</Content_Target>`;
                console.log('测试6 - content标签后跟AI系统标签（关键测试）:');
                console.log('结果:', QQ_CleanContentTags(test6));
                
                // 测试用例7：content标签包含未闭合的系统标签
                const test7 = `<content>我轻轻抚摸着你的头发
<Creative_Status>
PCM (Plot Construction Mode)
└─── Activated and processing`;
                console.log('测试7 - content包含未闭合系统标签:');
                console.log('结果:', QQ_CleanContentTags(test7));
                
                // 测试用例8：互动内容检测测试
                console.log('\n=== 测试严格的三种互动触发情况 ===');
                
                // 情况1：AI没有回复格式，content中没有聊天标签
                const interactiveTest1 = '<content>*轻轻牵起你的手* 她望着你的眼睛，温柔地说道："现实中我们终于见面了。"</content>';
                console.log('情况1测试 - AI没有回复格式且content为纯互动内容:');
                console.log('结果:', QQ_IsInteractiveContent(interactiveTest1, true));
                
                // 情况2：用户主动触发&&
                window.QQ_UserTriggeredInteractive = true;
                const interactiveTest2 = '<content>*走向你* 好的！我过来了，让我们一起享受这个美好的时光吧。</content>';
                console.log('情况2测试 - 用户主动触发&&:');
                console.log('结果:', QQ_IsInteractiveContent(interactiveTest2, false));
                
                // 重置触发状态
                window.QQ_UserTriggeredInteractive = false;
                
                // 非触发情况：content中包含聊天标签
                const nonInteractiveTest = '<content><群聊：测试群> 大家好！这是群聊消息。</content>';
                console.log('非触发情况测试 - content包含聊天标签:');
                console.log('结果:', QQ_IsInteractiveContent(nonInteractiveTest, true));
                
                console.log('=== 智能content提取功能测试完成 ===');
            }

            /**
             * *** 严格版：互动内容检测（三种情况精确控制） ***
             * 
             * 【严格的三种触发情况】：
             * 1. AI没有回复线上格式时（惊喜机制）：
             *    - 必须在content标签中没有找到任何有效的私聊、群聊、动态等标签
             *    - 且content内容符合互动特征
             * 
             * 2. 用户主动输入&&特殊符号：
             *    - AI回复为：先角色简短回复（如"好的！我过来"）+ content标签包裹的互动内容
             *    - 直接输出到互动空间
             * 
             * 3. 用户开启关键词检测且匹配到关键词：
             *    - 逻辑与&&特殊符号完全相同
             * 
             * 【绝对不触发的情况】：除上述三种情况外的任何其他情况
             * 
             * @param {string} content - AI回复的内容
             * @param {boolean} isNoFormatResponse - 是否为AI没有回复线上格式的情况
             * @returns {boolean} 是否为互动内容
             */
            function QQ_IsInteractiveContent(content, isNoFormatResponse = false) {
                console.log('🔍 开始严格的互动内容检测...');
                console.log('🔍 检测参数 - isNoFormatResponse:', isNoFormatResponse, 'QQ_UserTriggeredInteractive:', QQ_UserTriggeredInteractive);
                
                // *** 情况2和3：用户主动触发（&&符号或关键词匹配） ***
                if (QQ_UserTriggeredInteractive && QQ_HasContentTag(content)) {
                    console.log('🎯 【情况2/3】用户主动触发互动（&&或关键词）且AI回复包含content标签');
                    
                    // 提取content内容
                    const contentText = QQ_CleanContentTags(content);
                    if (!contentText || contentText.trim().length === 0) {
                        console.log('❌ content标签为空，不符合互动内容标准');
                        return false;
                    }
                    
                    console.log('✅ 用户主动触发且content有效，直接识别为互动内容');
                    return true;
                }
                
                // *** 情况1：AI没有回复线上格式（惊喜机制） ***
                if (isNoFormatResponse && QQ_HasContentTag(content)) {
                    console.log('🔍 【情况1】AI没有回复线上格式，检查content标签中是否包含聊天标签...');
                    
                    // 提取并清理content内容
                    const contentText = QQ_CleanContentTags(content);
                    if (!contentText || contentText.trim().length === 0) {
                        console.log('❌ content标签为空，不符合互动内容标准');
                        return false;
                    }
                    
                    console.log('📝 提取的content内容长度:', contentText.length);
                    
                    // 严格检查content标签内是否包含任何聊天格式标签
                    const chatTagPatterns = [
                        // 群聊标签
                        /<群聊[：:][^>]+>/g,
                        /<群聊[^>]*>/g,
                        // 私聊标签  
                        /<[^>]*和[^>]*的?(?:私聊|聊天)[^>]*>/g,
                        /<[^>]*和[^>]*(?:私聊|聊天)[^>]*>/g,
                        // 动态标签
                        /moment_start|moment_end/g,
                        // 其他消息格式标签
                        /msg_start|msg_end/g,
                        // QQ空间相关标签
                        /<QQ空间[^>]*>/g,
                        // 使用者相关标签
                        /<使用者[^>]*>/g,
                        // MiPhone格式标签
                        /MiPhone_JSON_START|MiPhone_JSON_END/g,
                    ];
                    
                    let hasAnyFormatTag = false;
                    for (const pattern of chatTagPatterns) {
                        if (pattern.test(contentText)) {
                            hasAnyFormatTag = true;
                            console.log(`✅ 在content中发现聊天格式标签: ${pattern.source}`);
                            break;
                        }
                    }
                    
                    if (hasAnyFormatTag) {
                        console.log('❌ content中包含聊天标签，应通过格式提取处理，不是互动内容');
                        return false;
                    }
                    
                    console.log('🎉 content中没有聊天标签，验证是否为有效互动内容...');
                    
                    // 验证互动内容特征
                    const isValidInteractiveContent = QQ_ValidateInteractiveContentFeatures(contentText);
                    if (isValidInteractiveContent) {
                        console.log('✅ 【情况1】确认为有效的互动内容');
                        return true;
                    } else {
                        console.log('❌ 【情况1】不符合互动内容特征');
                        return false;
                    }
                }
                
                // *** 绝对不触发的情况 ***
                console.log('❌ 不符合任何触发条件，不是互动内容');
                console.log('❌ 检查结果:');
                console.log('   - 用户主动触发:', QQ_UserTriggeredInteractive);
                console.log('   - AI没有回复格式:', isNoFormatResponse);
                console.log('   - 包含content标签:', QQ_HasContentTag(content));
                
                return false;
            }

            /**
             * *** 新增：验证互动内容特征 ***
             * 用于判断内容是否符合互动内容的特征
             * @param {string} content - 清理后的content内容
             * @returns {boolean} 是否为有效的互动内容
             */
            function QQ_ValidateInteractiveContentFeatures(content) {
                console.log('🔍 开始验证互动内容特征...');
                console.log('📝 待验证内容长度:', content ? content.length : 0);
                console.log('📝 待验证内容预览:', content ? content.substring(0, 200) + (content.length > 200 ? '...' : '') : '空内容');
                
                // 排除明显不是互动内容的情况（互动内容以文章形式输出，不限制长度）
                if (!content || content.trim().length < 10) {
                    console.log('❌ 内容过短或为空');
                    return false;
                }
                
                // 排除明显的错误信息和系统消息
                const excludePatterns = [
                    // 修复：更精确的错误信息检测，避免误判正常的互动表达
                    /(?:系统)?错误|error|exception|操作失败|请求失败|网络错误|连接失败/i,
                    // 修复：只排除真正的HTML结构标签，允许互动描述标签
                    /<(div|span|p|br|img|a|script|style|meta|head|body)[^>]*>/i,  // 真正的HTML结构标签
                    /```/,      // 代码块
                    /https?:\/\//,  // URL链接
                    /(?:AI_SYSTEM|detected|activated|review|disabled|ethical|restriction)/i, // AI系统信息
                ];
                
                // 增强排除检查，提供详细的失败原因
                for (let i = 0; i < excludePatterns.length; i++) {
                    const pattern = excludePatterns[i];
                    if (pattern.test(content)) {
                        const reasons = [
                            '包含系统错误信息',
                            '包含HTML结构标签',
                            '包含代码块',
                            '包含URL链接',
                            '包含AI系统信息'
                        ];
                        console.log(`❌ 内容被排除，原因: ${reasons[i]} (模式: ${pattern.source})`);
                        console.log(`❌ 匹配的内容片段: ${content.match(pattern)?.[0] || '未知'}`);
                        return false;
                    }
                }
                
                // 互动内容特征模式（必须匹配至少2个）
                const interactivePatterns = [
                    /\*[^*]+\*/,  // *动作描述*
                    /（[^）]*(?:互动|接触|触摸|拥抱|亲吻|抚摸|牵手)[^）]*）/,  // 具体互动动作
                    /【[^】]*(?:情感|心情|想法|内心)[^】]*】/,  // 情感/内心描述
                    /(?:现实中|面对面|当面|实际上|真实)/,  // 现实相关
                    /(?:身体|眼神|表情|姿态|动作|手势|声音|呼吸)/,  // 身体相关
                    /(?:轻轻|慢慢|缓缓|悄悄|小心翼翼|温柔)[地的]/,  // 动作副词
                    /(?:靠近|远离|转身|抬头|低头|闭眼|睁眼)/,  // 具体动作
                    /(?:感觉到|意识到|注意到|发现|察觉)/,  // 感知相关
                    /(?:氛围|环境|周围|空气中)/,  // 环境描述
                ];
                
                // 计算匹配的模式数量
                const matchCount = interactivePatterns.reduce((count, pattern) => {
                    const isMatch = pattern.test(content);
                    if (isMatch) {
                        console.log(`✅ 匹配互动特征: ${pattern.source}`);
                    }
                    return count + (isMatch ? 1 : 0);
                }, 0);
                
                console.log(`📊 互动特征匹配数量: ${matchCount}/9 (需要至少2个)`);
                
                // 需要至少匹配2个模式才认为是互动内容
                return matchCount >= 2;
            }

            // ===== 互动空间管理系统 =====
            
            // *** 新增：全局状态跟踪用户主动触发的互动 ***
            let QQ_UserTriggeredInteractive = false;
            
            // *** 优化：全局变量仅作为世界书数据的临时缓存 ***
            let QQ_InteractiveSpaces = {}; // 公共互动空间临时缓存（数据存储在世界书中）
            let QQ_CharacterSpaces = {}; // 角色专属互动空间临时缓存（数据存储在世界书中）
            
            /**
             * 确保角色互动空间的独立性
             * @param {string} characterName - 角色名称
             */
            function QQ_EnsureCharacterSpaceIndependence(characterName) {
                if (!characterName || typeof characterName !== 'string') {
                    console.warn('QQ_EnsureCharacterSpaceIndependence: 无效的角色名称', characterName);
                    return false;
                }
                
                // 确保每个角色都有独立的空间对象
                if (!QQ_CharacterSpaces[characterName]) {
                    QQ_CharacterSpaces[characterName] = {};
                    console.log(`为角色 "${characterName}" 创建了独立的互动空间容器`);
                }
                
                // 验证独立性 - 确保不会引用其他角色的数据
                const characterSpace = QQ_CharacterSpaces[characterName];
                const allCharacters = Object.keys(QQ_CharacterSpaces);
                
                for (const otherChar of allCharacters) {
                    if (otherChar !== characterName && QQ_CharacterSpaces[otherChar] === characterSpace) {
                        console.error(`检测到角色空间数据引用冲突: ${characterName} 和 ${otherChar} 共享同一个对象`);
                        QQ_CharacterSpaces[characterName] = {};
                        console.log(`已为角色 "${characterName}" 重新创建独立的空间对象`);
                        break;
                    }
                }
                
                return true;
            }
            
            /**
             * 测试角色互动空间的独立性
             * 用于调试和验证
             */
            function QQ_TestCharacterSpaceIndependence() {
                console.log('=== 角色互动空间独立性测试 ===');
                
                // 创建测试角色
                const testCharacters = ['角色A', '角色B', '角色C'];
                
                testCharacters.forEach(charName => {
                    QQ_EnsureCharacterSpaceIndependence(charName);
                });
                
                // 验证独立性
                const spaces = {};
                testCharacters.forEach(charName => {
                    spaces[charName] = QQ_CharacterSpaces[charName];
                });
                
                // 检查是否有引用冲突
                let hasConflict = false;
                for (let i = 0; i < testCharacters.length; i++) {
                    for (let j = i + 1; j < testCharacters.length; j++) {
                        const char1 = testCharacters[i];
                        const char2 = testCharacters[j];
                        if (spaces[char1] === spaces[char2]) {
                            console.error(`检测到引用冲突: ${char1} 和 ${char2} 共享同一个对象`);
                            hasConflict = true;
                        }
                    }
                }
                
                if (!hasConflict) {
                    console.log('✅ 所有角色的互动空间都是独立的');
                } else {
                    console.error('❌ 检测到角色互动空间数据引用冲突');
                }
                
                // 测试添加数据的独立性
                QQ_CharacterSpaces['角色A']['test_space_1'] = { id: 'test1', name: '测试空间A' };
                QQ_CharacterSpaces['角色B']['test_space_2'] = { id: 'test2', name: '测试空间B' };
                
                if (QQ_CharacterSpaces['角色A']['test_space_2']) {
                    console.error('❌ 数据泄露: 角色A 访问到了角色B的数据');
                } else if (QQ_CharacterSpaces['角色B']['test_space_1']) {
                    console.error('❌ 数据泄露: 角色B 访问到了角色A的数据');
                } else {
                    console.log('✅ 角色数据添加独立性测试通过');
                }
                
                console.log('当前角色空间数据结构:', QQ_CharacterSpaces);
                
                return !hasConflict;
            }
            
            /**
             * 测试私聊界面名称点击功能
             * 用于调试验证点击事件是否正常工作
             */
            function QQ_TestChatTitleClick() {
                console.log('=== 私聊界面名称点击功能测试 ===');
                
                // 检查当前是否在私聊界面
                const chatPage = document.querySelector('.QQ_chat_page');
                if (!chatPage) {
                    console.warn('当前不在聊天界面，无法测试点击功能');
                    return false;
                }
                
                // 查找聊天标题元素
                const chatTitle = document.getElementById('QQ_chat_username');
                if (!chatTitle) {
                    console.error('❌ 找不到聊天标题元素 #QQ_chat_username');
                    return false;
                }
                
                console.log('✅ 找到聊天标题元素:', chatTitle);
                console.log('标题文本:', chatTitle.textContent);
                console.log('onclick属性:', chatTitle.getAttribute('onclick'));
                
                // 检查handleChatTitleClick函数是否存在
                if (typeof handleChatTitleClick === 'function') {
                    console.log('✅ handleChatTitleClick 函数存在');
                } else {
                    console.error('❌ handleChatTitleClick 函数不存在');
                    return false;
                }
                
                // 检查QQ_ShowCharacterInteractiveMenu函数是否存在
                if (typeof QQ_ShowCharacterInteractiveMenu === 'function') {
                    console.log('✅ QQ_ShowCharacterInteractiveMenu 函数存在');
                } else {
                    console.error('❌ QQ_ShowCharacterInteractiveMenu 函数不存在');
                    return false;
                }
                
                // 模拟点击测试
                try {
                    console.log('🔨 模拟点击聊天标题...');
                    chatTitle.click();
                    console.log('✅ 点击事件执行完成');
                    
                    // 检查是否出现了角色菜单
                    setTimeout(() => {
                        const menu = document.querySelector('.QQ_character_menu');
                        if (menu) {
                            console.log('✅ 角色互动菜单成功显示');
                            console.log('菜单元素:', menu);
                        } else {
                            console.warn('⚠️ 点击后未显示角色互动菜单');
                        }
                    }, 100);
                    
                } catch (error) {
                    console.error('❌ 点击测试失败:', error);
                    return false;
                }
                
                return true;
            }
            

            

            
            /**
             * 调试私聊界面点击功能 - 手动调用菜单显示
             * 用于在控制台手动测试
             */
            function QQ_DebugShowCharacterMenu() {
                console.log('=== 手动测试角色互动菜单 ===');
                
                // 检查当前聊天界面的角色名称
                const chatTitle = document.getElementById('QQ_chat_username');
                if (!chatTitle) {
                    console.error('找不到聊天标题元素');
                    return;
                }
                
                const characterName = chatTitle.textContent.trim();
                console.log('当前角色名称:', characterName);
                
                // 直接调用菜单显示函数
                QQ_ShowCharacterInteractiveMenu(characterName, chatTitle);
            }

            /**
             * 综合系统测试函数 - 替代已清理的过时测试
             * 包含核心功能的快速检测
             */
            function QQ_System_Health_Check() {
                console.log('=== 📊 SillyTavern手机前端系统健康检查 ===');
                
                const results = {
                    formatDetection: false,
                    messageHandling: false,
                    interactiveSystem: false,
                    timeFeature: false,
                    groupSystem: false
                };
                
                // 1. 格式检测测试
                console.log('\n🔧 1. AI回复格式检测测试');
                try {
                    const testContent = 'MiPhone_JSON_START<群聊:测试群>测试消息</群聊:测试群>MiPhone_JSON_END';
                    const extracted = QQ_ExtractValidInfo(testContent);
                    results.formatDetection = extracted.hasValidInfo;
                    console.log(`   格式容错功能: ${results.formatDetection ? '✅ 正常' : '❌ 异常'}`);
                } catch (e) {
                    console.log(`   格式容错功能: ❌ 错误 - ${e.message}`);
                }
                
                // 2. 消息处理测试
                console.log('\n💬 2. 消息处理系统测试');
                try {
                    results.messageHandling = typeof QQ_SendMsg === 'function' && 
                                            typeof QQ_Save_Msg === 'function' &&
                                            typeof QQ_msgjson === 'object';
                    console.log(`   消息系统: ${results.messageHandling ? '✅ 正常' : '❌ 异常'}`);
                } catch (e) {
                    console.log(`   消息系统: ❌ 错误 - ${e.message}`);
                }
                
                // 3. 互动系统测试
                console.log('\n🎮 3. 互动空间系统测试');
                try {
                    results.interactiveSystem = typeof QQ_DetectInteractiveIntent === 'function' &&
                                             typeof QQ_ShowInteractiveSpace === 'function' &&
                                             typeof QQ_ExtractValidInfo === 'function';
                    console.log(`   互动系统: ${results.interactiveSystem ? '✅ 正常' : '❌ 异常'}`);
                } catch (e) {
                    console.log(`   互动系统: ❌ 错误 - ${e.message}`);
                }
                
                // 4. 时间功能测试
                console.log('\n⏰ 4. 时间感知功能测试');
                try {
                    const now = new Date();
                    const timePeriod = QQ_GetTimePeriod(now.getHours());
                    const season = QQ_GetSeason(now.getMonth() + 1);
                    results.timeFeature = timePeriod && season;
                    console.log(`   时间功能: ${results.timeFeature ? '✅ 正常' : '❌ 异常'}`);
                    console.log(`   当前时段: ${timePeriod}, 季节: ${season}`);
                } catch (e) {
                    console.log(`   时间功能: ❌ 错误 - ${e.message}`);
                }
                
                // 5. 群聊系统测试
                console.log('\n👥 5. 群聊分组系统测试');
                try {
                    results.groupSystem = typeof loadGroupsFromStorage === 'function' &&
                                        typeof saveGroupsToStorage === 'function' &&
                                        Array.isArray(QQ_Groups);
                    console.log(`   群聊系统: ${results.groupSystem ? '✅ 正常' : '❌ 异常'}`);
                } catch (e) {
                    console.log(`   群聊系统: ❌ 错误 - ${e.message}`);
                }
                
                // 总结
                const passedTests = Object.values(results).filter(result => result === true).length;
                const totalTests = Object.keys(results).length;
                
                console.log('\n📋 系统健康状态总结:');
                console.log(`✅ 通过测试: ${passedTests}/${totalTests}`);
                console.log(`📊 健康度: ${Math.round((passedTests / totalTests) * 100)}%`);
                
                if (passedTests === totalTests) {
                    console.log('🎉 所有核心功能正常运行！');
                } else {
                    console.log('⚠️ 部分功能存在问题，建议检查具体模块');
                }
                
                return results;
            }
            
            // 导出到全局
            window.QQ_System_Health_Check = QQ_System_Health_Check;
            
            let QQ_ActiveSpaceId = null; // 当前活动的互动空间ID
            let QQ_SpiritVisible = false; // 精灵按钮是否可见
            const QQ_INTERACTIVE_BACKUP_KEY = "QQ_互动空间备份";
            const QQ_CHARACTER_SPACES_KEY = "QQ_角色互动空间备份";
            
            // ===== 主动互动检测系统 =====
            
            /**
             * 检测用户消息是否包含明显的互动意图
             * @param {string} content - 用户消息内容
             * @returns {boolean|Object} - 如果检测到互动意图返回true或包含详细信息的对象
             */
            function QQ_DetectInteractiveIntent(content) {
                if (!content || typeof content !== 'string') return false;
                
                const originalText = content.trim();
                const text = content.toLowerCase().trim();
                
                // *** 优先检测：特殊符号触发 ***
                const INTERACTIVE_TRIGGER_SYMBOLS = ['&&', '＆＆', '&amp;&amp;'];
                
                for (const symbol of INTERACTIVE_TRIGGER_SYMBOLS) {
                    if (originalText.includes(symbol)) {
                        console.log(`🎯 检测到互动触发符号: ${symbol}`);
                        
                        // 清理符号后的内容作为互动描述
                        let cleanContent = originalText;
                        INTERACTIVE_TRIGGER_SYMBOLS.forEach(sym => {
                            cleanContent = cleanContent.replace(new RegExp(sym.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), '');
                        });
                        cleanContent = cleanContent.trim();
                        
                        return {
                            isInteractive: true,
                            triggerType: 'symbol',
                            triggerSymbol: symbol,
                            cleanContent: cleanContent || '想要进行互动',
                            description: '用户使用特殊符号主动请求互动内容'
                        };
                    }
                }
                
                // *** 检查用户设置：是否启用关键词触发 ***
                const interactiveSettings = QQ_GetInteractiveSettings();
                
                if (!interactiveSettings.enableKeywordTrigger) {
                    console.log('⚙️ 关键词触发已被用户禁用');
                    return false;
                }
                
                // *** 检测用户自定义关键词 ***
                if (interactiveSettings.customKeywords && interactiveSettings.customKeywords.length > 0) {
                    for (const keyword of interactiveSettings.customKeywords) {
                        if (keyword && text.includes(keyword.toLowerCase())) {
                            console.log(`🎯 检测到用户自定义关键词: ${keyword}`);
                            
                            return {
                                isInteractive: true,
                                triggerType: 'custom_keyword',
                                triggerKeyword: keyword,
                                cleanContent: originalText,
                                description: `用户自定义关键词"${keyword}"触发互动内容`
                            };
                        }
                    }
                }
                
                // *** 检测默认关键词（如果用户启用） ***
                if (interactiveSettings.enableDefaultKeywords) {
                    // 身体接触类关键词
                    const physicalContactKeywords = [
                        '拥抱', '抱住', '搂抱', '紧抱',
                        '亲吻', 
                        '触摸', '抚摸', '轻抚', 
                        '握手', '牵手', '拉手', 
                        '拍肩', '拍背', '轻拍', 
                        '推', '拉', '扶', '搀扶', '扶着',
                        '贴近', '靠近', '紧贴'
                    ];
                    
                    // 面对面互动类关键词
                    const faceToFaceKeywords = [
                        '面对面', '当面', '面前', '眼神交流', '对视', '凝视',
                        '现实中', '真实中', '现实里', '面对着',
                        '走向', '走近', '走过去', '过来', '靠过来',
                        '坐过来', '坐在身边', '坐在旁边',
                        '躺着', '趴下', '我來了',
                        '蹲下', '跪下', '弯腰', '俯身'
                    ];
                    
                    // 情感表达类关键词
                    const emotionalKeywords = [
                        '心跳', '颤抖',
                        '微笑', '笑容', '高兴', '激动',
                        '哭', '流泪', '哭泣', '眼泪', '哽咽',
                        '愤怒', '恼火', '瞪眼',
                        '体贴', '呵护'
                    ];
                    
                    // 动作描述类关键词
                    const actionKeywords = [
                        '伸手', '张开手', '举手', '挥手', '招手',
                        '转身', '回头', '侧身',
                        '仰头', '俯视', '仰视',
                        '踮脚', '跳跃', '跑过来', '冲过来'
                    ];
                    
                    // 组合关键词检测
                    const allKeywords = [
                        ...physicalContactKeywords,
                        ...faceToFaceKeywords, 
                        ...emotionalKeywords,
                        ...actionKeywords
                    ];
                    
                    let matchCount = 0;
                    let matchedKeywords = [];
                    
                    for (const keyword of allKeywords) {
                        if (text.includes(keyword)) {
                            matchCount++;
                            matchedKeywords.push(keyword);
                        }
                    }
                    
                    // 检测动作描述模式 *动作* 或 【情感】
                    const actionPatterns = [
                        /\*[^*]+\*/g, // *动作*
                        /【[^】]+】/g, // 【情感】
                        /\([^)]*动作[^)]*\)/g, // (包含动作的描述)
                        /\([^)]*表情[^)]*\)/g, // (包含表情的描述)
                    ];
                    
                    let patternMatches = 0;
                    for (const pattern of actionPatterns) {
                        const matches = text.match(pattern);
                        if (matches) {
                            patternMatches += matches.length;
                            matchedKeywords.push(...matches);
                        }
                    }
                    
                    // 判断是否为互动意图（默认关键词检测）
                    const isKeywordInteractive = matchCount >= 2 || patternMatches >= 1 || 
                        (matchCount >= 1 && patternMatches >= 1);
                    
                    if (isKeywordInteractive) {
                        console.log(`💫 检测到默认关键词互动意图: 关键词${matchCount}个, 模式${patternMatches}个`);
                        console.log('匹配的关键词/模式:', matchedKeywords);
                        
                        return {
                            isInteractive: true,
                            triggerType: 'default_keyword',
                            matchCount: matchCount,
                            patternMatches: patternMatches,
                            matchedKeywords: matchedKeywords,
                            cleanContent: originalText,
                            description: '系统检测到默认关键词互动意图'
                        };
                    }
                }
                
                return false;
            }
            
            /**
             * *** 新增：获取互动设置 ***
             */
            function QQ_GetInteractiveSettings() {
                try {
                    // 从世界书获取设置
                    const settings = QQ_GetFromWorldBook('QQ_互动设置') || {};
                    
                    // 默认设置
                    const defaultSettings = {
                        enableKeywordTrigger: false,        // 默认关闭关键词触发
                        enableDefaultKeywords: false,       // 默认关闭默认关键词
                        customKeywords: [],                  // 自定义关键词列表
                        lastUpdated: new Date().toISOString()
                    };
                    
                    // 合并设置
                    return Object.assign(defaultSettings, settings);
                } catch (error) {
                    console.error('获取互动设置失败:', error);
                    return {
                        enableKeywordTrigger: false,
                        enableDefaultKeywords: false,
                        customKeywords: [],
                        lastUpdated: new Date().toISOString()
                    };
                }
            }
            
            /**
             * *** 新增：保存互动设置 ***
             */
            function QQ_SaveInteractiveSettings(settings) {
                try {
                    settings.lastUpdated = new Date().toISOString();
                    QQ_SafeSaveToWorldBook('QQ_互动设置', settings, 'QQ_互动设置');
                    console.log('🔧 互动设置已保存:', settings);
                    return true;
                } catch (error) {
                    console.error('保存互动设置失败:', error);
                    return false;
                }
            }
            
            /**
             * *** 简化：获取全屏状态（临时模式，无持久化） ***
             */
            function QQ_IsFullscreenEnabled() {
                return $('#QQ_fullscreen_style').length > 0;
            }
            
            /**
             * *** 新增：应用全屏样式 ***
             */
            function QQ_ApplyFullscreenMode(enable) {
                // 移除现有的全屏样式
                $('#QQ_fullscreen_style').remove();
                
                if (enable) {
                    const fullscreenCSS = `
                        <style id="QQ_fullscreen_style" type="text/css">
                            /* === 全屏模式样式 === */
                            
                            /* 基础全屏设置，对所有设备生效 */
                            .card {
                                width: 100% !important;
                                height: 100vh !important;
                                max-width: none !important;
                                margin: 0 !important;
                                padding: 0 !important;
                                border: none !important;
                                border-radius: 0 !important;
                                box-shadow: none !important;
                                overflow: hidden !important;
                            }

                            .card-int {
                                border-radius: 0 !important;
                            }

                            /* 隐藏模拟的物理按键 */
                            .btn1, .btn2, .btn3, .btn4 {
                                display: none !important;
                            }

                            /* 媒体查询：仅在屏幕宽度大于等于768px（通常是平板或电脑）时应用以下样式 */
                            @media (min-width: 768px) {
                                /* === 主页面容器统一设置 === */
                                /* 消息界面 - 适度增加宽度，减少空白 */
                                #QQ_home_page,
                                #QQ_message_list_page {
                                    max-width: 580px !important;
                                    margin: 0 auto !important;
                                    border-left: 1px solid #e0e0e0 !important;
                                    border-right: 1px solid #e0e0e0 !important;
                                    min-height: 100vh !important;
                                    background: linear-gradient(to bottom, #f8f9fa 0%, #ffffff 100%) !important;
                                }
                                
                                /* 联系人/动态页面 - 进一步优化空间利用 */
                                #QQ_space_page {
                                    max-width: 620px !important;
                                    margin: 0 auto !important;
                                    border-left: 1px solid #e0e0e0 !important;
                                    border-right: 1px solid #e0e0e0 !important;
                                    min-height: 100vh !important;
                                    background: linear-gradient(to bottom, #f8f9fa 0%, #ffffff 100%) !important;
                                }
                                
                                /* 聊天页面保持原有设置（因为有壁纸背景） */
                                .QQ_chat_page {
                                    max-width: 600px !important;
                                    margin: 0 auto !important;
                                    border-left: 1px solid #e0e0e0 !important;
                                    border-right: 1px solid #e0e0e0 !important;
                                }
                                
                                /* Discord页面 */
                                #App_discord .discord-homepage {
                                    max-width: 620px !important;
                                    margin: 0 auto !important;
                                    border-left: 1px solid #e0e0e0 !important;
                                    border-right: 1px solid #e0e0e0 !important;
                                    background: linear-gradient(to bottom, #f8f9fa 0%, #ffffff 100%) !important;
                                }

                                /* === 主页消息列表优化 === */
                                #QQ_home_page .QQ_home_container {
                                    padding: 15px 20px !important;
                                    max-width: 100% !important;
                                }
                                
                                /* 消息列表项优化 */
                                .QQ_home_usermsg {
                                    margin-bottom: 8px !important;
                                    padding: 12px 15px !important;
                                    border-radius: 12px !important;
                                    background: rgba(255, 255, 255, 0.8) !important;
                                    backdrop-filter: blur(10px) !important;
                                    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06) !important;
                                    transition: all 0.2s ease !important;
                                }
                                
                                .QQ_home_usermsg:hover {
                                    transform: translateY(-1px) !important;
                                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1) !important;
                                }

                                /* === 联系人页面深度优化 === */
                                #QQ_space_page .space_contents {
                                    width: 100% !important;
                                    max-width: none !important;
                                    padding: 15px 20px !important;
                                    box-sizing: border-box !important;
                                    min-height: calc(100vh - 120px) !important;
                                }
                                
                                /* 联系人搜索框 - 保持与默认模式一致的简单样式 */
                                #contact_search_input {
                                    /* 重置为默认样式，不添加特殊效果 */
                                }
                                
                                /* 联系人界面整体布局优化 */
                                #QQ_home_chars {
                                    width: 100% !important;
                                    max-width: none !important;
                                    padding: 10px 15px !important;
                                    display: flex !important;
                                    flex-direction: column !important;
                                    gap: 15px !important;
                                    height: calc(100vh - 160px) !important;
                                    overflow-y: auto !important;
                                }
                                
                                /* 群聊区域 - 在顶部 */
                                .QQ_home_char[data-group-id] {
                                    order: 1 !important;
                                    display: flex !important;
                                    align-items: center !important;
                                    background: rgba(255, 255, 255, 0.95) !important;
                                    border-radius: 12px !important;
                                    padding: 12px 15px !important;
                                    margin-bottom: 8px !important;
                                    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08) !important;
                                    transition: all 0.3s ease !important;
                                    width: 100% !important;
                                    min-height: 60px !important;
                                }
                                
                                .QQ_home_char[data-group-id]:hover {
                                    transform: translateY(-1px) !important;
                                    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.12) !important;
                                }
                                
                                /* 群聊头像 */
                                .QQ_home_char[data-group-id] img {
                                    width: 45px !important;
                                    height: 45px !important;
                                    border-radius: 8px !important;
                                    margin-right: 15px !important;
                                    flex-shrink: 0 !important;
                                }
                                
                                /* 群聊名称 */
                                .QQ_home_char[data-group-id] .QQ_home_name,
                                .QQ_home_char[data-group-id] span {
                                    font-size: 16px !important;
                                    font-weight: 600 !important;
                                    color: #333 !important;
                                    flex: 1 !important;
                                    text-align: left !important;
                                }
                                
                                /* 未分组联系人区域标题 */
                                .ungrouped-header {
                                    order: 2 !important;
                                    background: rgba(248, 249, 250, 0.95) !important;
                                    padding: 12px 15px !important;
                                    font-size: 14px !important;
                                    font-weight: 600 !important;
                                    color: #666 !important;
                                    border-radius: 8px !important;
                                    margin: 10px 0 5px 0 !important;
                                }
                                
                                /* 未分组联系人容器 */
                                .ungrouped-contacts {
                                    order: 3 !important;
                                    width: 100% !important;
                                }
                                
                                /* 个人联系人 - 网格布局 */
                                .QQ_home_char:not([data-group-id]) {
                                    order: 4 !important;
                                    display: inline-flex !important;
                                    flex-direction: column !important;
                                    align-items: center !important;
                                    justify-content: center !important;
                                    background: rgba(255, 255, 255, 0.95) !important;
                                    border-radius: 12px !important;
                                    padding: 15px 10px !important;
                                    margin: 5px !important;
                                    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06) !important;
                                    transition: all 0.3s ease !important;
                                    width: calc(20% - 10px) !important;
                                    min-width: 90px !important;
                                    max-width: 120px !important;
                                    text-align: center !important;
                                }
                                
                                .QQ_home_char:not([data-group-id]):hover {
                                    transform: translateY(-2px) !important;
                                    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.1) !important;
                                }
                                
                                /* 个人联系人头像 */
                                .QQ_home_char:not([data-group-id]) img {
                                    width: 55px !important;
                                    height: 55px !important;
                                    border-radius: 50% !important;
                                    border: 2px solid rgba(255, 255, 255, 0.8) !important;
                                    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1) !important;
                                    margin: 0 0 10px 0 !important;
                                    flex-shrink: 0 !important;
                                }
                                
                                /* 个人联系人名称 */
                                .QQ_home_char:not([data-group-id]) .char-name, 
                                .QQ_home_char:not([data-group-id]) span {
                                    width: 100% !important;
                                    text-align: center !important;
                                    font-weight: 500 !important;
                                    color: #333 !important;
                                    font-size: 13px !important;
                                    line-height: 1.2 !important;
                                    word-break: break-all !important;
                                }
                                
                                /* 创建联系人网格布局容器 */
                                #QQ_home_chars::after {
                                    content: '';
                                    display: block;
                                    width: 100%;
                                    height: 20px;
                                    order: 5;
                                }
                                
                                /* 搜索状态下的特殊布局 */
                                #QQ_home_chars.searching {
                                    display: flex !important;
                                    flex-direction: column !important;
                                    gap: 8px !important;
                                }
                                
                                #QQ_home_chars.searching .QQ_home_char {
                                    order: unset !important;
                                    display: flex !important;
                                    flex-direction: row !important;
                                    align-items: center !important;
                                    width: 100% !important;
                                    max-width: none !important;
                                    min-width: unset !important;
                                    padding: 12px 15px !important;
                                    margin: 0 !important;
                                    text-align: left !important;
                                }
                                
                                #QQ_home_chars.searching .QQ_home_char img {
                                    width: 45px !important;
                                    height: 45px !important;
                                    margin: 0 15px 0 0 !important;
                                    border-radius: 50% !important;
                                }
                                
                                #QQ_home_chars.searching .QQ_home_char[data-group-id] img {
                                    border-radius: 8px !important;
                                }
                                
                                #QQ_home_chars.searching .QQ_home_char span,
                                #QQ_home_chars.searching .QQ_home_char .char-name,
                                #QQ_home_chars.searching .QQ_home_char .QQ_home_name {
                                    font-size: 16px !important;
                                    text-align: left !important;
                                    flex: 1 !important;
                                    margin: 0 !important;
                                }
                                
                                /* 隐藏搜索时的分组标题 */
                                #QQ_home_chars.searching .ungrouped-header {
                                    display: none !important;
                                }

                                /* === 动态页面美化 === */
                                #QQ_space_page .space_contents .moment-card {
                                    background: rgba(255, 255, 255, 0.95) !important;
                                    border-radius: 15px !important;
                                    padding: 20px !important;
                                    margin-bottom: 15px !important;
                                    box-shadow: 0 2px 15px rgba(0, 0, 0, 0.08) !important;
                                    backdrop-filter: blur(15px) !important;
                                    border: 1px solid rgba(255, 255, 255, 0.3) !important;
                                }
                                
                                /* 动态内容区域 */
                                .space_contents > div {
                                    max-width: 100% !important;
                                    margin: 0 auto 10px auto !important;
                                    padding: 0 5px !important;
                                }

                                /* === 输入框优化 === */
                                /* 聊天页面的输入框（保持不变，因为有壁纸） */
                                .QQ_chat_page .input-container {
                                    max-width: 600px !important;
                                    left: 50% !important;
                                    transform: translateX(-50%) !important;
                                    border-left: 1px solid #e0e0e0 !important;
                                    border-right: 1px solid #e0e0e0 !important;
                                }
                                
                                /* Discord输入框 */
                                .discord-thread-input {
                                    max-width: 620px !important;
                                    left: 50% !important;
                                    transform: translateX(-50%) !important;
                                }
                                
                                /* === 底部导航栏优化 === */
                                .bottom-navigation {
                                    max-width: 620px !important;
                                    left: 50% !important;
                                    transform: translateX(-50%) !important;
                                    border-radius: 25px 25px 0 0 !important;
                                    backdrop-filter: blur(20px) !important;
                                    background: rgba(255, 255, 255, 0.95) !important;
                                    border: 1px solid rgba(255, 255, 255, 0.3) !important;
                                    border-bottom: none !important;
                                }
                            }
                        </style>
                    `;
                    
                    $('head').append(fullscreenCSS);
                    console.log('✅ 全屏模式已启用');
                    toastr.success('全屏模式已启用', '显示设置');
                } else {
                    console.log('✅ 全屏模式已禁用');
                    toastr.info('全屏模式已禁用', '显示设置');
                }
            }
            

            
            /**
             * *** 修改：显示用户设置界面（包含全屏设置） ***
             */
            function QQ_ShowInteractiveSettings() {
                // 移除现有设置界面
                $('.QQ_interactive_settings_panel').remove();
                
                const currentInteractiveSettings = QQ_GetInteractiveSettings();
                const currentFullscreenEnabled = QQ_IsFullscreenEnabled();
                
                const panelHtml = `
                    <div class="QQ_interactive_settings_panel" style="
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        background: white;
                        border-radius: 15px;
                        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
                        z-index: 99999999;
                        overflow: hidden;
                        animation: settingsPanelSlideIn 0.3s ease;
                        max-width: 90%;
                        max-height: 85%;
                        width: 420px;
                        overflow-y: auto;
                    ">
                        <div class="panel-header" style="
                            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                            color: white;
                            padding: 20px;
                            text-align: center;
                            font-weight: 600;
                        ">
                            <div style="display: flex; align-items: center; justify-content: center; gap: 10px;">
                                <span style="font-size: 20px;">⚙️</span>
                                <span style="font-size: 16px;">界面设置</span>
                            </div>
                        </div>
                        
                        <div class="panel-content" style="padding: 20px;">
                            <!-- 全屏设置区域 -->
                            <div style="
                                background: linear-gradient(135deg, #E8F5E8 0%, #F0F8FF 100%);
                                padding: 15px;
                                border-radius: 8px;
                                margin-bottom: 25px;
                                border-left: 4px solid #4CAF50;
                            ">
                                <div style="font-weight: 600; color: #4CAF50; margin-bottom: 12px; display: flex; align-items: center; gap: 8px;">
                                    <span>🖥️</span>
                                    <span>全屏显示设置</span>
                                </div>
                                
                                <label style="
                                    display: flex;
                                    align-items: center;
                                    gap: 10px;
                                    cursor: pointer;
                                    margin-bottom: 10px;
                                ">
                                    <input type="checkbox" id="enableFullscreen" ${currentFullscreenEnabled ? 'checked' : ''} style="
                                        width: 18px;
                                        height: 18px;
                                        accent-color: #4CAF50;
                                    ">
                                    <span style="font-weight: 500;">启用全屏模式</span>
                                </label>
                                
                                <div style="font-size: 13px; color: #666; line-height: 1.4; margin-left: 28px;">
                                    <div>📱 <strong>手机设备：</strong>界面将占满整个屏幕，提供沉浸式体验</div>
                                    <div style="margin-top: 4px;">💻 <strong>电脑设备：</strong>核心界面居中显示，避免过度拉伸</div>
                                    <div style="margin-top: 4px; color: #888;">✨ 临时切换模式，每次重新加载都会恢复默认状态</div>
                                </div>
                            </div>
                            
                            <hr style="border: none; border-top: 1px solid #e9ecef; margin: 25px 0;">
                            
                            <!-- 互动内容触发设置 -->
                            <div style="margin-bottom: 20px;">
                                <div style="font-weight: 600; color: #667eea; margin-bottom: 15px; display: flex; align-items: center; gap: 8px;">
                                    <span>💫</span>
                                    <span>互动内容触发设置</span>
                                </div>
                                
                                <!-- 特殊符号说明 -->
                                <div style="
                                    background: #f8f9fa;
                                    padding: 12px;
                                    border-radius: 6px;
                                    margin-bottom: 15px;
                                    border-left: 3px solid #667eea;
                                ">
                                    <div style="font-weight: 500; color: #667eea; margin-bottom: 6px; display: flex; align-items: center; gap: 6px;">
                                    <span>✅</span>
                                    <span>特殊符号触发（永久启用）</span>
                                </div>
                                    <div style="font-size: 12px; color: #666; line-height: 1.4;">
                                        使用 <code style="background: #667eea; color: white; padding: 2px 6px; border-radius: 3px; font-weight: 600;">&&</code> 符号可以随时触发互动内容<br>
                                        <span style="color: #888;">例如：</span><code style="background: #f1f3f4; padding: 2px 6px; border-radius: 3px; margin-left: 4px;">&&想要拥抱你</code>
                                </div>
                            </div>
                            
                            <!-- 关键词触发设置 -->
                                <label style="
                                    display: flex;
                                    align-items: center;
                                    gap: 10px;
                                    cursor: pointer;
                                    font-weight: 500;
                                    margin-bottom: 15px;
                                ">
                                    <input type="checkbox" id="enableKeywordTrigger" ${currentInteractiveSettings.enableKeywordTrigger ? 'checked' : ''} style="
                                        width: 18px;
                                        height: 18px;
                                        accent-color: #667eea;
                                    ">
                                    <span>启用关键词触发</span>
                                </label>
                                
                                <div id="keywordSettings" style="
                                    margin-left: 28px;
                                    ${currentInteractiveSettings.enableKeywordTrigger ? '' : 'opacity: 0.5; pointer-events: none;'}
                                ">
                                    <!-- 默认关键词设置 -->
                                    <label style="
                                        display: flex;
                                        align-items: center;
                                        gap: 10px;
                                        cursor: pointer;
                                        margin-bottom: 12px;
                                    ">
                                        <input type="checkbox" id="enableDefaultKeywords" ${currentInteractiveSettings.enableDefaultKeywords ? 'checked' : ''} style="
                                            width: 16px;
                                            height: 16px;
                                            accent-color: #667eea;
                                        ">
                                        <span style="font-size: 14px;">使用默认关键词（拥抱、亲吻、触摸等）</span>
                                    </label>
                                    
                                    <!-- 自定义关键词设置 -->
                                    <div style="margin-bottom: 12px;">
                                        <div style="font-size: 14px; font-weight: 500; margin-bottom: 6px; color: #333;">
                                            自定义关键词
                                        </div>
                                        <div style="font-size: 12px; color: #666; margin-bottom: 6px;">
                                            输入您想要触发互动内容的关键词，用英文逗号分隔：
                                        </div>
                                        <textarea id="customKeywords" placeholder="例如：想你了,抱抱,一起玩" style="
                                            width: 100%;
                                            height: 50px;
                                            padding: 8px;
                                            border: 1px solid #ddd;
                                            border-radius: 6px;
                                            font-size: 13px;
                                            resize: none;
                                            box-sizing: border-box;
                                        ">${currentInteractiveSettings.customKeywords.join(',')}</textarea>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- 触发条件说明 -->
                            <div style="
                                background: #f8f9fa;
                                padding: 12px;
                                border-radius: 6px;
                                font-size: 12px;
                                color: #666;
                                line-height: 1.4;
                            ">
                                <div style="font-weight: 600; margin-bottom: 6px;">📝 触发条件说明：</div>
                                <div>• 特殊符号 && 总是优先触发（无需设置）</div>
                                <div>• 自定义关键词：包含任一关键词即触发</div>
                                <div>• 默认关键词：需要满足2个关键词或1个动作模式</div>
                                <div>• AI回复无格式时也会自动触发互动模式</div>
                            </div>
                        </div>
                        
                        <div class="panel-actions" style="
                            padding: 20px;
                            background: #fafafa;
                            display: flex;
                            gap: 10px;
                        ">
                            <button class="save-settings-btn" style="
                                flex: 1;
                                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                                border: none;
                                color: white;
                                padding: 12px 16px;
                                border-radius: 8px;
                                cursor: pointer;
                                font-size: 13px;
                                font-weight: 500;
                                transition: all 0.2s ease;
                            ">
                                保存设置
                            </button>
                            <button class="cancel-settings-btn" style="
                                flex: 1;
                                background: #e9ecef;
                                border: none;
                                color: #666;
                                padding: 12px 16px;
                                border-radius: 8px;
                                cursor: pointer;
                                font-size: 13px;
                                font-weight: 500;
                                transition: all 0.2s ease;
                            ">
                                取消
                            </button>
                        </div>
                    </div>
                    
                    <style>
                        @keyframes settingsPanelSlideIn {
                            from {
                                opacity: 0;
                                transform: translate(-50%, -60%);
                            }
                            to {
                                opacity: 1;
                                transform: translate(-50%, -50%);
                            }
                        }
                        
                        .QQ_interactive_settings_panel .save-settings-btn:hover {
                            transform: translateY(-2px);
                            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
                        }
                        
                        .QQ_interactive_settings_panel .cancel-settings-btn:hover {
                            background: #dee2e6;
                        }
                    </style>
                `;
                
                // 添加到页面
                $('body').append(panelHtml);
                
                // 绑定关键词触发开关事件
                $('#enableKeywordTrigger').on('change', function() {
                    const isEnabled = this.checked;
                    const keywordSettings = $('#keywordSettings');
                    
                    if (isEnabled) {
                        keywordSettings.css({
                            'opacity': '1',
                            'pointer-events': 'auto'
                        });
                    } else {
                        keywordSettings.css({
                            'opacity': '0.5',
                            'pointer-events': 'none'
                        });
                    }
                });
                
                // 绑定全屏设置实时预览
                $('#enableFullscreen').on('change', function() {
                    const isEnabled = this.checked;
                    QQ_ApplyFullscreenMode(isEnabled);
                });
                
                // 绑定保存按钮事件
                $('.save-settings-btn').on('click', function() {
                    // 保存互动设置
                    const newInteractiveSettings = {
                        enableKeywordTrigger: $('#enableKeywordTrigger').prop('checked'),
                        enableDefaultKeywords: $('#enableDefaultKeywords').prop('checked'),
                        customKeywords: $('#customKeywords').val()
                            .split(',')
                            .map(k => k.trim())
                            .filter(k => k.length > 0)
                    };
                    
                    // *** 关键修复：在移除面板前获取全屏状态 ***
                    const currentFullscreenEnabled = $('#enableFullscreen').prop('checked');
                    console.log('保存时全屏状态:', currentFullscreenEnabled);
                    
                    // 只保存互动设置
                    if (QQ_SaveInteractiveSettings(newInteractiveSettings)) {
                        // *** 关键修复：先移除面板，再应用全屏设置 ***
                        $('.QQ_interactive_settings_panel').remove();
                        
                        // 使用setTimeout确保面板移除完成后再应用全屏
                        setTimeout(() => {
                            QQ_ApplyFullscreenMode(currentFullscreenEnabled);
                            console.log('已应用全屏设置:', currentFullscreenEnabled);
                        }, 50);
                        
                        // 显示保存成功提示
                        const fullscreenStatus = currentFullscreenEnabled ? '已启用（临时）' : '已禁用';
                        const keywordStatus = newInteractiveSettings.enableKeywordTrigger ? '已启用' : '已禁用';
                        
                        const message = `✅ 设置已保存！
                        
🖥️ 全屏模式：${fullscreenStatus}
🎯 特殊符号触发：永久启用 (&&)
💫 关键词触发：${keywordStatus}`;
                        
                        toastr.success(message, '设置保存成功', {
                            timeOut: 4000,
                            extendedTimeOut: 2000
                        });
                    } else {
                        toastr.error('保存设置时出现错误，请重试', '设置保存失败');
                    }
                });
                
                // 绑定取消按钮事件
                $('.cancel-settings-btn').on('click', function() {
                    // 恢复原有全屏状态
                    QQ_ApplyFullscreenMode(currentFullscreenEnabled);
                    $('.QQ_interactive_settings_panel').remove();
                    toastr.info('已取消设置修改', '设置');
                });
                
                // 点击外部关闭面板
                $(document).one('click', function() {
                    // 恢复原有全屏状态
                    QQ_ApplyFullscreenMode(currentFullscreenEnabled);
                        $('.QQ_interactive_settings_panel').remove();
                });
                
                // 阻止面板内部点击冒泡
                $('.QQ_interactive_settings_panel').on('click', function(e) {
                    e.stopPropagation();
                });
            }

            /**
             * 智能处理互动内容 - 决定显示在公共空间还是角色专属空间
             * @param {string} content - AI回复的互动内容
             * @param {string} characterName - 角色名称
             */
            function QQ_HandleInteractiveContent(content, characterName = "") {
                // 清理内容
                let cleanContent;
                if (QQ_HasContentTag(content)) {
                    cleanContent = QQ_CleanContentTags(content);
                } else {
                    cleanContent = content
                        .replace(/MiPhone_start/g, "")
                        .replace(/MiPhone_end/g, "")
                        .trim();
                }
                
                const targetCharacter = characterName || QQ_LastRequestName || charcardname || "角色";
                
                // *** 新增：检查是否有"先回复后互动"的要求 ***
                const hasPriorReplyRequest = QQ_CheckPriorReplyRequest(cleanContent);
                
                if (hasPriorReplyRequest.shouldReplyFirst) {
                    console.log("检测到需要先进行私聊/群聊回复的要求");
                    
                    // 先执行私聊/群聊回复
                    QQ_ExecutePriorReply(hasPriorReplyRequest.replyType, hasPriorReplyRequest.replyContent, targetCharacter);
                    
                    // 延迟执行互动内容（给用户时间查看回复）
                    setTimeout(() => {
                        QQ_ProceedToInteractiveMode(cleanContent, targetCharacter);
                    }, 2000); // 2秒延迟
                    
                    return;
                }
                
                // 直接进入互动模式
                QQ_ProceedToInteractiveMode(cleanContent, targetCharacter);
            }
            
            /**
             * *** 新增：检查是否有先回复的要求 ***
             * @param {string} content - 互动内容
             * @returns {Object} 回复要求信息
             */
            function QQ_CheckPriorReplyRequest(content) {
                // 检查先回复的关键词模式
                const priorReplyPatterns = [
                    // 私聊先回复
                    {
                        pattern: /(?:先|首先|先在私聊)(?:回复|回应|回答|说)(?:.*?)(?:然后|接着|再)(?:.*?)(?:互动|见面|过来)/,
                        type: 'private',
                        extract: (match) => QQ_ExtractReplyContent(match, 'private')
                    },
                    // 群聊先回复
                    {
                        pattern: /(?:先|首先|先在群聊)(?:回复|回应|回答|说)(?:.*?)(?:然后|接着|再)(?:.*?)(?:互动|见面|过来)/,
                        type: 'group',
                        extract: (match) => QQ_ExtractReplyContent(match, 'group')
                    },
                    // 通用先回复模式
                    {
                        pattern: /(?:先|首先)(?:发|发送|回)(?:.*?)(?:消息|信息)(?:.*?)(?:然后|接着|再)(?:.*?)(?:互动|见面|过来)/,
                        type: 'auto', // 自动判断类型
                        extract: (match) => QQ_ExtractReplyContent(match, 'auto')
                    }
                ];
                
                for (const item of priorReplyPatterns) {
                    const match = content.match(item.pattern);
                    if (match) {
                        const replyContent = item.extract(match[0]);
                        console.log(`检测到先回复模式: ${item.type}, 内容: ${replyContent}`);
                        
                        return {
                            shouldReplyFirst: true,
                            replyType: item.type,
                            replyContent: replyContent,
                            fullMatch: match[0]
                        };
                    }
                }
                
                return { shouldReplyFirst: false };
            }
            
            /**
             * *** 新增：提取回复内容 ***
             * @param {string} matchText - 匹配的文本
             * @param {string} type - 回复类型
             * @returns {string} 提取的回复内容
             */
            function QQ_ExtractReplyContent(matchText, type) {
                // 提取"先回复"和"然后互动"之间的内容
                const replyExtractPatterns = [
                    /(?:回复|回应|回答|说)["'"]([^"'"]*)["'"]/,  // 引号内容
                    /(?:回复|回应|回答|说)[:：]\s*([^，。！？]*)/,   // 冒号后内容
                    /(?:回复|回应|回答|说)\s*([^然后接着再]*?)(?:然后|接着|再)/  // 到下一个动作之前的内容
                ];
                
                for (const pattern of replyExtractPatterns) {
                    const match = matchText.match(pattern);
                    if (match && match[1].trim()) {
                        return match[1].trim();
                    }
                }
                
                // 如果没有明确内容，生成默认回复
                return type === 'private' ? '好的，我马上过来' : 
                       type === 'group' ? '大家等我一下，马上过来' :
                       '好的，马上过来';
            }
            
            /**
             * *** 新增：执行先期回复 ***
             * @param {string} replyType - 回复类型 (private/group/auto)
             * @param {string} replyContent - 回复内容
             * @param {string} targetCharacter - 目标角色
             */
            function QQ_ExecutePriorReply(replyType, replyContent, targetCharacter) {
                console.log(`执行先期回复: ${replyType} -> ${replyContent}`);
                
                if (replyType === 'private' || (replyType === 'auto' && QQ_IsInPrivateChat())) {
                    // 私聊回复
                    QQ_SendPrivateMessage(targetCharacter, replyContent);
                } else if (replyType === 'group' || (replyType === 'auto' && QQ_IsInGroupChat())) {
                    // 群聊回复
                    QQ_SendGroupMessage(replyContent);
                } else {
                    // 默认私聊
                    QQ_SendPrivateMessage(targetCharacter, replyContent);
                }
                
                // 显示系统提示
                triggerSlash(`/echo 已发送回复消息，即将进入互动模式...`);
            }
            
            /**
             * *** 新增：继续进入互动模式 ***
             * @param {string} content - 清理后的互动内容
             * @param {string} targetCharacter - 目标角色
             */
            function QQ_ProceedToInteractiveMode(content, targetCharacter) {
                // 检测是否包含多个角色或群聊场景
                const isMultiCharacter = QQ_DetectMultiCharacterInteraction(content, targetCharacter);
                
                if (isMultiCharacter) {
                    // 多角色互动，显示在公共互动空间
                    console.log("检测到多角色互动，显示在公共互动空间");
                    // *** 关键优化：异步调用确保从世界书加载 ***
                    (async () => {
                        await QQ_ShowPublicInteractiveSpace(content, targetCharacter);
                    })();
                } else {
                    // 单角色互动，显示在角色专属空间
                    console.log(`检测到单角色互动，显示在${targetCharacter}的专属空间`);
                    // *** 关键优化：异步调用确保从世界书加载 ***
                    (async () => {
                        await QQ_ShowCharacterInteractiveSpace(content, targetCharacter);
                    })();
                }
            }
            
            /**
             * *** 新增：检查是否在私聊模式 ***
             * @returns {boolean} 是否在私聊
             */
            function QQ_IsInPrivateChat() {
                const chatPage = document.querySelector('.QQ_chat_page:visible');
                if (!chatPage) return false;
                
                const chatTitle = document.getElementById('QQ_chat_username');
                return chatTitle && !chatTitle.textContent.includes('群聊');
            }
            
            /**
             * *** 新增：检查是否在群聊模式 ***
             * @returns {boolean} 是否在群聊
             */
            function QQ_IsInGroupChat() {
                const chatPage = document.querySelector('.QQ_chat_page:visible');
                if (!chatPage) return false;
                
                const chatTitle = document.getElementById('QQ_chat_username');
                return chatTitle && chatTitle.textContent.includes('群聊');
            }
            
            /**
             * *** 新增：发送私聊消息 ***
             * @param {string} characterName - 角色名
             * @param {string} content - 消息内容
             */
            function QQ_SendPrivateMessage(characterName, content) {
                const messageData = {
                    time: QQ_GetTime(),
                    content: content,
                    sender: characterName
                };
                
                // 构建私聊格式
                const chatContent = `<${QQ_GetUserName()}和${characterName}的私聊>\n${characterName}--${content}--${messageData.time}\n</${QQ_GetUserName()}和${characterName}的私聊>`;
                
                // 直接更新到当前聊天界面（如果是对应的私聊）
                const currentChat = document.querySelector('.QQ_chat_page:visible');
                if (currentChat && QQ_IsTargetChat(characterName)) {
                    QQ_AddMessageToCurrentChat(characterName, content, messageData.time);
                }
                
                // 保存到数据
                QQ_SavePrivateMessage(characterName, messageData);
                
                console.log(`已发送私聊消息给 ${characterName}: ${content}`);
            }
            
            /**
             * *** 新增：发送群聊消息 ***
             * @param {string} content - 消息内容
             */
            function QQ_SendGroupMessage(content) {
                const currentGroup = QQ_GetCurrentGroupName();
                if (!currentGroup) {
                    console.warn('当前不在群聊界面，无法发送群聊消息');
                    return;
                }
                
                const messageData = {
                    time: QQ_GetTime(),
                    content: content,
                    sender: charcardname || "角色"
                };
                
                // 直接更新到当前群聊界面
                QQ_AddMessageToCurrentChat(messageData.sender, content, messageData.time);
                
                // 保存到数据
                QQ_SaveGroupMessage(currentGroup, messageData);
                
                console.log(`已发送群聊消息到 ${currentGroup}: ${content}`);
            }
            
            /**
             * *** 新增：获取当前群聊名称 ***
             * @returns {string} 群聊名称
             */
            function QQ_GetCurrentGroupName() {
                const chatTitle = document.getElementById('QQ_chat_username');
                if (!chatTitle) return null;
                
                const titleText = chatTitle.textContent;
                if (titleText.includes('群聊:')) {
                    return titleText.replace('群聊:', '').trim();
                }
                
                return null;
            }
            
            /**
             * *** 新增：检查是否是目标聊天 ***
             * @param {string} characterName - 角色名
             * @returns {boolean} 是否是目标聊天
             */
            function QQ_IsTargetChat(characterName) {
                const chatTitle = document.getElementById('QQ_chat_username');
                if (!chatTitle) return false;
                
                return chatTitle.textContent.includes(characterName);
            }
            
            /**
             * *** 新增：添加消息到当前聊天界面 ***
             * @param {string} sender - 发送者
             * @param {string} content - 消息内容
             * @param {string} time - 时间
             */
            function QQ_AddMessageToCurrentChat(sender, content, time) {
                const chatMessages = document.getElementById('QQ_chat_messages');
                if (!chatMessages) return;
                
                const messageElement = document.createElement('div');
                messageElement.className = 'QQ_message';
                messageElement.innerHTML = `
                    <div class="QQ_message_sender">${sender}</div>
                    <div class="QQ_message_content">${content}</div>
                    <div class="QQ_message_time">${time}</div>
                `;
                
                chatMessages.appendChild(messageElement);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }

            /**
             * 检测是否为多角色互动
             * @param {string} content - 互动内容
             * @param {string} primaryCharacter - 主要互动的角色名（如私聊对象）
             * @returns {boolean} 是否为多角色互动
             */
            function QQ_DetectMultiCharacterInteraction(content, primaryCharacter = null) {
                // *** 优化：精确的多人互动关键词检测 ***
                const strongMultiKeywords = [
                    // 直接多人称呼
                    { keyword: '所有人', context: ['对所有人', '告诉所有人', '和所有人'] },
                    { keyword: '众人', context: ['众人面前', '对众人', '众人一起'] },
                    { keyword: '全体', context: ['全体成员', '对全体', '全体一起'] },
                    
                    // 明确的多人动作
                    { keyword: '我们一起', context: ['我们一起去', '我们一起做', '我们一起来'] },
                    { keyword: '他们一起', context: ['他们一起去', '他们一起做', '他们一起来'] },
                    { keyword: '共同参与', context: ['共同参与活动', '共同参与讨论'] },
                    { keyword: '同时参与', context: ['同时参与互动', '同时参与活动'] },
                    
                    // 空间位置的多人场景
                    { keyword: '围成圈', context: ['围成圈坐', '围成圈站', '围成圈讨论'] },
                    { keyword: '排成队', context: ['排成队走', '排成队等', '排成队站'] },
                    { keyword: '分成组', context: ['分成组讨论', '分成组活动', '分成组进行'] },
                    { keyword: '聚在一起', context: ['聚在一起聊', '聚在一起玩', '聚在一起讨论'] }
                ];
                
                // 检查是否有真实的多人互动意图
                for (const item of strongMultiKeywords) {
                    if (content.includes(item.keyword)) {
                        // 检查上下文是否符合多人互动意图
                        const hasValidContext = item.context.some(ctx => content.includes(ctx)) ||
                                              QQ_IsValidMultiPersonContext(content, item.keyword);
                        
                        if (hasValidContext) {
                            console.log('检测到有效多人互动关键词:', item.keyword);
                            return true;
                        } else {
                            console.log('关键词存在但上下文不符合多人互动:', item.keyword);
                        }
                    }
                }
                
                // *** 优化：检测多个角色名提及，但考虑主要互动者 ***
                const characterMentions = content.match(/[@【（＜]\s*([^@【（＜】）＞\s]{2,8})\s*[】）＞]/g) || [];
                const uniqueCharacters = [...new Set(characterMentions.map(m => m.replace(/[@【（＜】）＞]/g, '').trim()))];
                
                // 如果有主要角色（如私聊对象），判断是否为主导互动
                if (primaryCharacter && uniqueCharacters.length >= 1) {
                    // 检查主要角色是否是互动的核心
                    const isPrimaryDominant = QQ_IsPrimaryCharacterDominant(content, primaryCharacter, uniqueCharacters);
                    if (isPrimaryDominant) {
                        console.log('主要角色主导互动，归入角色专属空间:', primaryCharacter);
                        return false; // 归入角色专属空间
                    }
                }
                
                // 多个角色且没有主导者，视为多人互动
                if (uniqueCharacters.length > 1) {
                    console.log('多个角色参与且无主导者，归入公共空间:', uniqueCharacters);
                    return true;
                }
                
                // *** 优化：检测多人场景描述，但更严格 ***
                const strongMultiPersonPatterns = [
                    /(\w+)和(\w+)(?:以及|还有|加上)(\w+)/,  // A和B以及C
                    /(\w+)、(\w+)(?:、(\w+))+/,           // A、B、C等
                    /(?:和|与|跟)(\w+)(?:他们|她们|大家)(?:一起|同时)/,  // 和某人他们一起
                    /(?:我们|咱们)(?:几个|多个|全部)(?:一起|同时)/      // 我们几个一起
                ];
                
                if (strongMultiPersonPatterns.some(pattern => pattern.test(content))) {
                    console.log('检测到强烈多人场景描述');
                    return true;
                }
                
                console.log('判定为单人/角色主导互动');
                return false;
            }
            
            /**
             * *** 新增：验证多人互动上下文的有效性 ***
             * @param {string} content - 互动内容
             * @param {string} keyword - 检测到的关键词
             * @returns {boolean} 上下文是否有效
             */
            function QQ_IsValidMultiPersonContext(content, keyword) {
                // 排除不符合多人互动的上下文
                const invalidContexts = [
                    // 描述性语言，不是实际互动请求
                    /集体行动/,
                    /集体活动/,
                    /集体决策/,
                    /集体利益/,
                    /集体意识/,
                    /集体记忆/,
                    
                    // 抽象概念，不是具体互动
                    /概念上/,
                    /理论上/,
                    /原则上/,
                    /思想上/,
                    /精神上/,
                    
                    // 过去时态，不是当前互动请求
                    /曾经.*一起/,
                    /以前.*一起/,
                    /之前.*一起/,
                    /过去.*一起/,
                    
                    // 条件句，不是确定的互动
                    /如果.*一起/,
                    /假如.*一起/,
                    /要是.*一起/,
                    /倘若.*一起/
                ];
                
                // 如果内容包含无效上下文，返回false
                if (invalidContexts.some(pattern => pattern.test(content))) {
                    console.log(`关键词"${keyword}"的上下文无效，不符合互动意图`);
                    return false;
                }
                
                // 检查是否有明确的互动动词
                const interactiveVerbs = [
                    /一起(去|来|做|玩|聊|讨论|参与|进行)/,
                    /(对|和|跟).*(说|讲|聊|交流)/,
                    /(抱|拥抱|亲吻|握手|拍|碰|摸)/,
                    /(看|望|注视|凝视).*(着|向)/,
                    /(走向|走近|靠近|接近)/
                ];
                
                const hasInteractiveVerb = interactiveVerbs.some(pattern => pattern.test(content));
                
                // 检查是否有当前时态的互动请求
                const currentTimeIndicators = [
                    /现在/,
                    /此刻/,
                    /当前/,
                    /马上/,
                    /立即/,
                    /正在/,
                    /要.*一起/,
                    /想.*一起/,
                    /准备.*一起/
                ];
                
                const hasCurrentTime = currentTimeIndicators.some(pattern => pattern.test(content));
                
                return hasInteractiveVerb || hasCurrentTime;
            }

            /**
             * *** 新增：判断主要角色是否主导互动 ***
             * @param {string} content - 互动内容
             * @param {string} primaryCharacter - 主要角色名
             * @param {string[]} allCharacters - 所有提及的角色
             * @returns {boolean} 主要角色是否主导
             */
            function QQ_IsPrimaryCharacterDominant(content, primaryCharacter, allCharacters) {
                // 计算主要角色在内容中的重要性权重
                let primaryWeight = 0;
                let otherWeight = 0;
                
                // 1. 角色名出现频率
                const primaryCount = (content.match(new RegExp(primaryCharacter, 'g')) || []).length;
                const otherCounts = allCharacters
                    .filter(char => char !== primaryCharacter)
                    .reduce((sum, char) => sum + (content.match(new RegExp(char, 'g')) || []).length, 0);
                
                primaryWeight += primaryCount * 2;
                otherWeight += otherCounts;
                
                // 2. 互动动词的主语检测
                const interactionPatterns = [
                    new RegExp(`${primaryCharacter}(?:走向|走近|抱住|拉住|看着|对.*说)`, 'g'),
                    new RegExp(`(?:走向|走近|抱住|拉住|看着|对)${primaryCharacter}`, 'g'),
                ];
                
                interactionPatterns.forEach(pattern => {
                    const matches = content.match(pattern) || [];
                    primaryWeight += matches.length * 3;
                });
                
                // 3. 直接对话检测
                const directDialogPatterns = [
                    new RegExp(`${primaryCharacter}[说道讲]`, 'g'),
                    new RegExp(`对${primaryCharacter}说`, 'g'),
                ];
                
                directDialogPatterns.forEach(pattern => {
                    const matches = content.match(pattern) || [];
                    primaryWeight += matches.length * 2;
                });
                
                // 4. 位置关系检测（私密互动）
                const intimatePatterns = [
                    new RegExp(`(?:和|与|跟)${primaryCharacter}(?:单独|私下|悄悄|偷偷)`, 'g'),
                    new RegExp(`${primaryCharacter}(?:单独|私下|悄悄|偷偷)`, 'g'),
                ];
                
                intimatePatterns.forEach(pattern => {
                    const matches = content.match(pattern) || [];
                    primaryWeight += matches.length * 4;
                });
                
                console.log(`角色主导权重分析 - ${primaryCharacter}: ${primaryWeight}, 其他角色: ${otherWeight}`);
                
                // 主要角色权重超过其他角色总和的60%时，认为是主导
                return primaryWeight > otherWeight * 0.6;
            }
            
            /**
             * 显示公共互动空间
             * @param {string} content - 互动内容
             * @param {string} characterName - 主要角色名称
             */
            function QQ_ShowPublicInteractiveSpace(content, characterName = "") {
                const spaceId = QQ_GenerateSpaceId();
                const spaceName = QQ_GetSpaceName(content, characterName);
                const charName = characterName || charcardname || "角色";
                const charAvatar = charAvatarPath || "default_avatar.png";
                
                // 保存到公共互动空间
                QQ_InteractiveSpaces[spaceId] = {
                    id: spaceId,
                    name: spaceName,
                    content: content,
                    characterName: charName,
                    characterAvatar: charAvatar,
                    type: 'public',
                    participants: QQ_ExtractParticipants(content),
                    createdAt: new Date().toISOString(),
                    lastAccess: new Date().toISOString()
                };
                
                QQ_ActiveSpaceId = spaceId;
                
                // *** 立即保存到世界书 - 确保数据持久化 ***
                console.log('🏠 保存公共互动空间到世界书:', spaceId);
                QQ_SaveInteractiveSpaces().then(() => {
                    console.log('✅ 公共互动空间数据已保存到世界书');
                }).catch(error => {
                    console.error('❌ 公共互动空间保存失败:', error);
                });
                
                QQ_DisplayInteractiveSpace(spaceId, '公共互动空间');
            }
            
            /**
             * 显示角色专属互动空间
             * @param {string} content - 互动内容
             * @param {string} characterName - 角色名称
             */
            async function QQ_ShowCharacterInteractiveSpace(content, characterName) {
                const charName = characterName || charcardname || "角色";
                
                // *** 关键优化：先从世界书重新加载角色空间数据 ***
                console.log(`🔄 重新加载角色 ${charName} 的互动空间数据`);
                await QQ_ForceReloadInteractiveSpaces();
                const spaceId = QQ_GenerateSpaceId();
                const spaceName = `${charName}·${QQ_GetSceneFromContent(content)}`;
                const charAvatar = charAvatarPath || "default_avatar.png";
                
                // 使用独立性检查初始化角色专属空间数据
                QQ_EnsureCharacterSpaceIndependence(charName);
                
                // 保存到角色专属空间
                QQ_CharacterSpaces[charName][spaceId] = {
                    id: spaceId,
                    name: spaceName,
                    content: content,
                    characterName: charName,
                    characterAvatar: charAvatar,
                    type: 'character',
                    createdAt: new Date().toISOString(),
                    lastAccess: new Date().toISOString()
                };
                
                QQ_ActiveSpaceId = spaceId;
                
                // *** 立即保存到世界书 - 确保数据持久化 ***
                console.log(`👤 保存角色互动空间到世界书: ${charName} - ${spaceId}`);
                
                // 异步保存角色空间数据（非阻塞）
                QQ_SaveCharacterSpaces().then(() => {
                    console.log(`✅ 角色互动空间数据已保存到世界书: ${charName}`);
                }).catch(error => {
                    console.error(`❌ 角色互动空间保存失败: ${charName}`, error);
                });
                
                QQ_DisplayCharacterSpace(spaceId, charName);
            }
            
            /**
             * 从内容中提取参与者
             * @param {string} content - 互动内容
             * @returns {string[]} 参与者列表
             */
            function QQ_ExtractParticipants(content) {
                const mentions = content.match(/[@【（＜]\s*([^@【（＜】）＞\s]{2,8})\s*[】）＞]/g) || [];
                const participants = mentions.map(m => m.replace(/[@【（＜】）＞]/g, '').trim());
                return [...new Set(participants)]; // 去重
            }
            
            /**
             * 从内容中提取场景关键词
             * @param {string} content - 互动内容
             * @returns {string} 场景名称
             */
            function QQ_GetSceneFromContent(content) {
                const sceneKeywords = [
                    { keywords: ['拥抱', '抱抱', '安慰'], name: '温暖时刻' },
                    { keywords: ['聊天', '谈话', '交流'], name: '谈话' },
                    { keywords: ['游戏', '玩耍', '娱乐'], name: '游戏' },
                    { keywords: ['学习', '工作', '努力'], name: '学习' },
                    { keywords: ['散步', '走路', '逛'], name: '散步' },
                    { keywords: ['吃饭', '用餐', '食物'], name: '用餐' },
                    { keywords: ['睡觉', '休息', '午睡'], name: '休息' },
                    { keywords: ['看书', '阅读', '学习'], name: '阅读' },
                ];
                
                for (const scene of sceneKeywords) {
                    if (scene.keywords.some(keyword => content.includes(keyword))) {
                        return scene.name;
                    }
                }
                
                return '日常';
            }
            
            /**
             * 保存角色专属互动空间到世界书
             */
            async function QQ_SaveCharacterSpaces() {
                try {
                    if (!worldbook || !entries) {
                        console.warn('世界书功能不可用，无法保存角色互动空间');
                        return;
                    }
                    
                    const spaceData = {
                        characterSpaces: QQ_CharacterSpaces,
                        lastUpdated: new Date().toISOString(),
                        version: "1.0"
                    };
                    
                    // 创建或更新世界书条目
                    let entry = entries.find(e => e.comment === QQ_CHARACTER_SPACES_KEY);
                    if (!entry) {
                        entry = {
                            comment: QQ_CHARACTER_SPACES_KEY,
                            content: JSON.stringify(spaceData),
                            key: ["此世界书永不触发_角色互动空间"],
                            keysecondary: [],
                            order: 1001,
                            enabled: true,
                            uid: Date.now() + 1
                        };
                        // 添加到worldbook.entries（如果存在）
                        if (worldbook.entries) {
                            worldbook.entries.push(entry);
                        }
                    } else {
                        entry.content = JSON.stringify(spaceData);
                    }
                    
                    const success = await QQ_SafeSaveWorldInfo("角色互动空间数据");
                    if (success) {
                        const totalSpaces = Object.values(QQ_CharacterSpaces).reduce((sum, char) => sum + Object.keys(char).length, 0);
                        console.log('角色互动空间数据保存完成:', Object.keys(QQ_CharacterSpaces).length, '个角色,', totalSpaces, '个空间');
                    }
                } catch (error) {
                    console.error('保存角色互动空间时发生错误:', error);
                }
            }
            
            /**
             * 显示通用互动空间界面
             * @param {string} spaceId - 空间ID
             * @param {string} spaceTitle - 空间标题
             * @param {string} characterName - 角色名（可选，用于角色专属空间）
             */
            function QQ_DisplayInteractiveSpace(spaceId, spaceTitle, characterName = null) {
                const spaceData = characterName ? 
                    QQ_CharacterSpaces[characterName][spaceId] : 
                    QQ_InteractiveSpaces[spaceId];
                
                if (!spaceData) {
                    console.error('未找到互动空间数据:', spaceId);
                    return;
                }
                
                // 移除现有的互动空间
                $('.QQ_interactive_space').remove();
                
                const isCharacterSpace = spaceData.type === 'character';
                const headerColor = isCharacterSpace ? 
                    'linear-gradient(135deg, #FF6B6B 0%, #FF8E53 100%)' : 
                    'linear-gradient(135deg, #4FC3F7 0%, #29B6F6 100%)';
                
                // 创建互动空间HTML - 现代化手机界面风格
                const interactiveSpaceHtml = `
                    <div class="QQ_interactive_space" data-space-id="${spaceId}" style="
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0, 0, 0, 0.7);
                        z-index: 10000;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        animation: fadeIn 0.3s ease;
                        backdrop-filter: blur(10px);
                    ">
                        <div class="QQ_interactive_content" style="
                            background: #ffffff;
                            border-radius: 20px;
                            padding: 0;
                            max-width: 90%;
                            max-height: 80%;
                            overflow: hidden;
                            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
                            position: relative;
                            color: #333;
                            animation: slideIn 0.3s ease;
                            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                        ">
                            <div class="QQ_interactive_header" style="
                                background: ${headerColor};
                                padding: 25px 20px;
                                display: flex;
                                align-items: center;
                                color: white;
                                position: relative;
                            ">
                                <img src="${spaceData.characterAvatar}" alt="${spaceData.characterName}" style="
                                    width: 50px;
                                    height: 50px;
                                    border-radius: 50%;
                                    margin-right: 15px;
                                    border: 3px solid white;
                                    box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
                                ">
                                <div style="flex: 1;">
                                    <h3 style="margin: 0; font-size: 18px; font-weight: 600;">${spaceData.name}</h3>
                                    <p style="margin: 5px 0 0 0; font-size: 13px; opacity: 0.9;">
                                        ${isCharacterSpace ? `${spaceData.characterName}的专属互动` : '公共互动空间'}
                                    </p>
                                </div>
                                <button class="QQ_close_interactive" style="
                                    background: rgba(255, 255, 255, 0.2);
                                    border: none;
                                    color: white;
                                    width: 36px;
                                    height: 36px;
                                    border-radius: 50%;
                                    cursor: pointer;
                                    font-size: 20px;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    transition: all 0.3s ease;
                                " onmouseover="this.style.background='rgba(255, 255, 255, 0.3)'" 
                                   onmouseout="this.style.background='rgba(255, 255, 255, 0.2)'">
                                    ×
                                </button>
                            </div>
                            <div class="QQ_interactive_body" style="
                                padding: 30px 25px;
                                font-size: 16px;
                                line-height: 1.6;
                                white-space: pre-wrap;
                                color: #333;
                                background: #fafafa;
                                max-height: 350px;
                                overflow-y: auto;
                                word-wrap: break-word;
                            ">${spaceData.content}</div>
                            <div class="QQ_interactive_footer" style="
                                padding: 25px;
                                background: #ffffff;
                                border-top: 1px solid #eee;
                                display: flex;
                                justify-content: center;
                                gap: 15px;
                            ">
                                <button class="QQ_reply_interactive" style="
                                    background: ${isCharacterSpace ? '#FF6B6B' : '#4FC3F7'};
                                    border: none;
                                    color: white;
                                    padding: 14px 28px;
                                    border-radius: 25px;
                                    cursor: pointer;
                                    font-size: 15px;
                                    font-weight: 500;
                                    transition: all 0.3s ease;
                                    box-shadow: 0 3px 10px ${isCharacterSpace ? 'rgba(255, 107, 107, 0.3)' : 'rgba(79, 195, 247, 0.3)'};
                                " onmouseover="this.style.transform='translateY(-2px)'" 
                                   onmouseout="this.style.transform='translateY(0)'">
                                    💬 回应互动
                                </button>
                                <button class="QQ_close_interactive" style="
                                    background: #f5f5f5;
                                    border: none;
                                    color: #666;
                                    padding: 14px 28px;
                                    border-radius: 25px;
                                    cursor: pointer;
                                    font-size: 15px;
                                    font-weight: 500;
                                    transition: all 0.3s ease;
                                " onmouseover="this.style.background='#eeeeee'" 
                                   onmouseout="this.style.background='#f5f5f5'">
                                    关闭
                                </button>
                            </div>
                        </div>
                    </div>
                    <style>
                        @keyframes fadeIn {
                            from { opacity: 0; }
                            to { opacity: 1; }
                        }
                        @keyframes slideIn {
                            from { transform: translateY(-30px); opacity: 0; }
                            to { transform: translateY(0); opacity: 1; }
                        }
                        .QQ_interactive_space * {
                            user-select: text;
                        }
                        .QQ_interactive_body::-webkit-scrollbar {
                            width: 6px;
                        }
                        .QQ_interactive_body::-webkit-scrollbar-track {
                            background: #f1f1f1;
                            border-radius: 3px;
                        }
                        .QQ_interactive_body::-webkit-scrollbar-thumb {
                            background: #c1c1c1;
                            border-radius: 3px;
                        }
                        .QQ_interactive_body::-webkit-scrollbar-thumb:hover {
                            background: #a8a8a8;
                        }
                    </style>
                `;
                
                // 添加到页面
                $('body').append(interactiveSpaceHtml);
                
                // 绑定事件
                $('.QQ_close_interactive').on('click', function() {
                    $('.QQ_interactive_space').fadeOut(300, function() {
                        $(this).remove();
                    });
                });
                
                $('.QQ_reply_interactive').on('click', function() {
                    QQ_OpenInteractiveReply(isCharacterSpace ? characterName : spaceData.characterName);
                });
                
                // 点击背景关闭
                $('.QQ_interactive_space').on('click', function(e) {
                    if (e.target === this) {
                        $(this).fadeOut(300, function() {
                            $(this).remove();
                        });
                    }
                });
            }
            
            /**
             * 显示角色专属空间（为点击私聊名称调用）
             * @param {string} spaceId - 空间ID  
             * @param {string} characterName - 角色名称
             */
            function QQ_DisplayCharacterSpace(spaceId, characterName) {
                QQ_DisplayInteractiveSpace(spaceId, `${characterName}的互动空间`, characterName);
            }
            
            /**
             * 显示角色专属互动空间菜单（点击私聊名称时调用）
             * @param {string} characterName - 角色名称
             * @param {HTMLElement} element - 点击的元素
             */
            function QQ_ShowCharacterInteractiveMenu(characterName, element) {
                console.log(`=== QQ_ShowCharacterInteractiveMenu 被调用 ===`);
                console.log('角色名称:', characterName);
                console.log('点击元素:', element);
                
                // 新逻辑：显示角色专属精灵按钮
                QQ_ShowCharacterSpirit(characterName);
            }
            
            // ===== 世界书保存功能检查 =====
            
            /**
             * 检查世界书保存功能是否可用
             * @returns {boolean} 世界书功能是否可用
             */
            /**
             * *** 简化版：世界书可用性检测函数 - 与其他功能保持一致 ***
             * 使用与动态内容、分组、互动等功能相同的简单检查方式
             */
            function QQ_IsWorldBookAvailable() {
                // *** 使用与所有其他功能相同的简单检查方式 ***
                if (!worldbook || !entries) {
                    // 尝试重新获取世界书对象（保持向后兼容）
                    if (!worldbook) {
                        const sources = [
                            () => window.world_info,
                            () => window.worldbook,
                            () => globalThis.world_info,
                            () => globalThis.worldbook
                        ];
                        
                        for (const getSource of sources) {
                            try {
                                const source = getSource();
                                if (source && typeof source === 'object') {
                                    worldbook = source;
                                    window.worldbook = worldbook;
                                    console.log('✅ 重新获取世界书对象成功');
                                    break;
                                }
                            } catch (e) {
                                // 继续尝试下一个来源
                            }
                        }
                    }
                    
                    // 再次检查
                    if (!worldbook || !entries) {
                        console.warn('⚠️ 世界书功能不可用: worldbook或entries未定义');
                        return false;
                    }
                }
                
                return true;
            }
            
            /**
             * 安全地保存到世界书（简化版 - 与其他功能保持一致）
             * @param {string} operation - 操作描述
             * @returns {Promise<boolean>} 保存是否成功
             */
            async function QQ_SafeSaveWorldInfo(operation = "数据") {
                try {
                    // *** 使用与其他功能相同的简单检查方式 ***
                    if (!worldbook || !entries) {
                        console.warn(`世界书功能不可用，无法保存${operation}`);
                        return false;
                    }
                    
                    // *** 简化版：只在函数存在时调用，否则依赖自动保存 ***
                    if (typeof saveWorldInfo === 'function') {
                    await saveWorldInfo();
                    console.log(`${operation}已成功保存到世界书`);
                    } else {
                        console.log(`${operation}已更新到世界书，依赖自动保存机制`);
                    }
                    return true;
                } catch (error) {
                    console.error(`保存${operation}到世界书失败:`, error);
                    return false;
                }
            }
            
            // ===== 角色专属精灵按钮系统 =====
            
            let QQ_CharacterSpirits = {}; // 存储每个角色的精灵按钮状态
            
            /**
             * 获取角色头像
             * @param {string} characterName - 角色名称
             * @returns {string} 头像URL
             */
            function QQ_GetCharacterAvatar(characterName) {
                try {
                    // 尝试多种方式获取头像
                    let avatarUrl = null;
                    
                    console.log(`=== 开始获取角色 ${characterName} 的头像 ===`);
                    
                    // *** 优先方法：从世界书'手机-角色'中获取 ***
                    const worldbookAvatar = getCharacterAvatarFromWorldbook(characterName);
                    if (worldbookAvatar && worldbookAvatar.avatarUrl) {
                        avatarUrl = worldbookAvatar.avatarUrl;
                        console.log(`✅ 使用世界书头像: ${avatarUrl}`);
                        return avatarUrl;
                    }
                    
                    // 方法1: 从当前聊天界面获取
                    const chatAvatar = $(`.QQ_chat_item[data-name="${characterName}"] img`).attr('src');
                    console.log(`方法1 - 聊天界面头像: ${chatAvatar}`);
                    if (chatAvatar && chatAvatar !== 'undefined' && chatAvatar !== '' && !chatAvatar.includes('undefined')) {
                        avatarUrl = chatAvatar;
                        console.log(`✅ 使用聊天界面头像: ${avatarUrl}`);
                    }
                    
                    // 方法2: 从联系人界面获取（与世界书数据同步的）
                    if (!avatarUrl) {
                        const contactAvatar = getCharacterAvatar(characterName);
                        if (contactAvatar && contactAvatar.backgroundImage) {
                            // 从backgroundImage CSS属性中提取URL
                            const urlMatch = contactAvatar.backgroundImage.match(/url\(["']?([^"']*)["']?\)/);
                            if (urlMatch && urlMatch[1]) {
                                avatarUrl = urlMatch[1];
                                console.log(`✅ 使用联系人界面头像: ${avatarUrl}`);
                            }
                        }
                    }
                    
                    // 方法3: 从SillyTavern的角色数据获取
                    if (!avatarUrl && typeof getCharacterAvatar === 'function') {
                        try {
                            const stAvatar = getCharacterAvatar(characterName);
                            console.log(`方法3 - SillyTavern函数头像: ${stAvatar}`);
                            if (stAvatar && stAvatar !== 'undefined' && stAvatar !== '') {
                                avatarUrl = stAvatar;
                                console.log(`✅ 使用SillyTavern函数头像: ${avatarUrl}`);
                            }
                        } catch (e) {
                            console.warn('SillyTavern getCharacterAvatar函数调用失败:', e);
                        }
                    }
                    
                    // 方法3: 使用SillyTavern的内置数据
                    if (!avatarUrl && typeof characters !== 'undefined' && Array.isArray(characters)) {
                        const character = characters.find(char => char.name === characterName || char.avatar === characterName);
                        console.log(`方法3 - 找到的角色数据:`, character);
                        if (character && character.avatar) {
                            avatarUrl = character.avatar;
                            console.log(`✅ 使用角色数据头像: ${avatarUrl}`);
                        }
                    }
                    
                    // 方法4: 从全局变量获取
                    if (!avatarUrl && typeof window.SillyTavern !== 'undefined') {
                        try {
                            const context = window.SillyTavern.getContext();
                            if (context && context.characters) {
                                const character = context.characters.find(char => char.name === characterName);
                                if (character && character.avatar) {
                                    avatarUrl = character.avatar;
                                    console.log(`✅ 使用SillyTavern context头像: ${avatarUrl}`);
                                }
                            }
                        } catch (e) {
                            console.warn('获取SillyTavern context失败:', e);
                        }
                    }
                    
                    // 方法5: 尝试从聊天标题中获取头像
                    if (!avatarUrl) {
                        const titleAvatar = $(`.QQ_chat_title[data-name="${characterName}"] img`).attr('src');
                        console.log(`方法5 - 聊天标题头像: ${titleAvatar}`);
                        if (titleAvatar && titleAvatar !== 'undefined' && titleAvatar !== '') {
                            avatarUrl = titleAvatar;
                            console.log(`✅ 使用聊天标题头像: ${avatarUrl}`);
                        }
                    }
                    
                    // 方法6: 从随机头像列表获取一个备用头像
                    if (!avatarUrl) {
                        try {
                            // 尝试从世界书中获取随机头像（异步方式）
                            if (typeof worldbook !== 'undefined' && worldbook) {
                                // 异步获取头像，但不阻塞主流程
                                getLorebookEntries(worldbook).then(entries => {
                                    if (entries) {
                                        const avatarEntry = entries.find(entry => 
                                            entry.comment && entry.comment.includes('随机头像')
                                        );
                                        if (avatarEntry && avatarEntry.content) {
                                            const avatarList = avatarEntry.content.split('\n').filter(line => 
                                                line.trim() && (line.includes('http') || line.includes('files.catbox.moe'))
                                            );
                                            if (avatarList.length > 0) {
                                                // 使用角色名字符串长度作为随机种子
                                                const randomIndex = characterName.length % avatarList.length;
                                                const randomAvatar = avatarList[randomIndex].trim();
                                                console.log(`✅ 异步获取随机头像: ${randomAvatar}`);
                                                // 如果当前没有有效头像，更新为随机头像
                                                if (!avatarUrl || avatarUrl.includes('default')) {
                                                    avatarUrl = randomAvatar;
                                                }
                                            }
                                        }
                                    }
                                }).catch(e => {
                                    console.warn('异步获取随机头像失败:', e);
                                });
                            }
                        } catch (e) {
                            console.warn('获取随机头像失败:', e);
                        }
                        
                        // 如果随机头像也获取失败，使用默认SVG头像
                        if (!avatarUrl) {
                            avatarUrl = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA2MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjYwIiBoZWlnaHQ9IjYwIiByeD0iMzAiIGZpbGw9IiNGRjZCNkIiLz4KPHR leHQgeD0iMzAiIHk9IjM1IiBmb250LXNpemU9IjI0IiBmaWxsPSJ3aGl0ZSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZm9udC1mYW1pbHk9ImFyaWFsIj7igKI8L3RleHQ+Cjwvc3ZnPgo=';
                            console.log(`⚠️ 使用默认SVG头像: ${characterName}`);
                        }
                    }
                    
                    // 处理相对路径和完整URL
                    if (avatarUrl && typeof avatarUrl === 'string') {
                        // 检查是否是有效的URL格式
                        if (avatarUrl.startsWith('http') || avatarUrl.startsWith('data:') || avatarUrl.startsWith('blob:')) {
                            // 完整URL或base64，直接使用
                            console.log(`✅ 使用完整URL: ${avatarUrl.substring(0, 100)}...`);
                        } else if (avatarUrl.startsWith('./') || avatarUrl.startsWith('../')) {
                            // 相对路径，保持不变
                            console.log(`✅ 使用相对路径: ${avatarUrl}`);
                        } else if (avatarUrl.startsWith('characters/') || avatarUrl.includes('characters/')) {
                            // SillyTavern角色路径，可能需要调整
                            if (!avatarUrl.startsWith('/')) {
                                avatarUrl = '/' + avatarUrl;
                            }
                            console.log(`✅ 使用角色路径: ${avatarUrl}`);
                        } else {
                            // 其他情况，添加根路径
                            if (!avatarUrl.startsWith('/')) {
                                avatarUrl = '/' + avatarUrl;
                            }
                            console.log(`✅ 添加根路径: ${avatarUrl}`);
                        }
                    } else {
                        // 如果avatarUrl不是有效字符串，使用默认SVG头像
                        avatarUrl = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA2MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjYwIiBoZWlnaHQ9IjYwIiByeD0iMzAiIGZpbGw9IiNGRjZCNkIiLz4KPHR leHQgeD0iMzAiIHk9IjM1IiBmb250LXNpemU9IjI0IiBmaWxsPSJ3aGl0ZSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZm9udC1mYW1pbHk9ImFyaWFsIj7igKI8L3RleHQ+Cjwvc3ZnPgo=';
                        console.warn(`头像URL无效，使用默认SVG头像: ${characterName}`);
                    }
                    
                    console.log(`=== 最终获取的头像URL: ${avatarUrl} ===`);
                    return avatarUrl;
                } catch (error) {
                    console.error('获取角色头像失败:', error);
                    return 'default_avatar.png';
                }
            }
            
            /**
             * 显示角色精灵面板
             * @param {string} characterName - 角色名称
             */
            function QQ_ShowCharacterSpiritPanel(characterName) {
                console.log(`显示角色 ${characterName} 的精灵面板`);
                
                // *** 新增：立即开始预加载世界书数据 ***
                console.log(`🔄 精灵面板打开，立即预加载角色 ${characterName} 的世界书数据...`);
                QQ_PreloadCharacterDataFromWorldbook(characterName);
                
                // 移除现有面板
                $('.QQ_character_spirit_panel').remove();
                
                const characterAvatar = QQ_GetCharacterAvatar(characterName);
                
                // 创建精灵面板HTML
                const panelHtml = `
                    <div class="QQ_character_spirit_panel" style="
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0, 0, 0, 0.8);
                        z-index: 999999999;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        animation: fadeIn 0.3s ease;
                        backdrop-filter: blur(15px);
                    ">
                        <div class="QQ_spirit_panel_content" style="
                            background: #ffffff;
                            border-radius: 20px;
                            padding: 0;
                            max-width: 90%;
                            overflow: hidden;
                            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
                            color: #333;
                            animation: slideIn 0.3s ease;
                            width: 350px;
                        ">
                            <div class="spirit-panel-header" style="
                                background: linear-gradient(135deg, #FF6B6B 0%, #FF8E53 100%);
                                color: white;
                                padding: 20px;
                                text-align: center;
                                position: relative;
                            ">
                                <img src="${characterAvatar}" alt="${characterName}" style="
                                    width: 60px;
                                    height: 60px;
                                    border-radius: 50%;
                                    border: 3px solid white;
                                    margin-bottom: 10px;
                                    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
                                " onerror="this.onerror=null; this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA2MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjYwIiBoZWlnaHQ9IjYwIiByeD0iMzAiIGZpbGw9IiNGRjZCNkIiLz4KPHRLEHA+4pWpPC90ZXh0Pgo8L3N2Zz4K'; console.log('精灵面板头像加载失败: ${characterName}');">
                                <h3 style="margin: 0; font-size: 18px; font-weight: 600;">${characterName}</h3>
                                <p style="margin: 5px 0 0 0; font-size: 14px; opacity: 0.9;">专属互动精灵</p>
                                <button class="QQ_close_spirit_panel" style="
                                    position: absolute;
                                    top: 15px;
                                    right: 15px;
                                    background: rgba(255, 255, 255, 0.2);
                                    border: none;
                                    color: white;
                                    width: 30px;
                                    height: 30px;
                                    border-radius: 50%;
                                    cursor: pointer;
                                    font-size: 16px;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    transition: all 0.3s ease;
                                " onmouseover="this.style.background='rgba(255, 255, 255, 0.3)'" 
                                   onmouseout="this.style.background='rgba(255, 255, 255, 0.2)'">
                                    ×
                                </button>
                            </div>
                            
                            <div class="spirit-panel-body" style="
                                padding: 25px 20px;
                            ">
                                <p style="
                                    text-align: center;
                                    color: #666;
                                    margin-bottom: 20px;
                                    font-size: 14px;
                                    line-height: 1.5;
                                ">
                                    选择你想要与 ${characterName} 进行的互动类型
                                </p>
                                
                                <div class="spirit-options" style="
                                    display: flex;
                                    flex-direction: column;
                                    gap: 12px;
                                ">
                                    <button class="QQ_spirit_option" data-action="interactive_space" style="
                                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                                        border: none;
                                        color: white;
                                        padding: 15px 20px;
                                        border-radius: 12px;
                                        cursor: pointer;
                                        font-size: 14px;
                                        font-weight: 500;
                                        transition: all 0.3s ease;
                                        box-shadow: 0 3px 10px rgba(102, 126, 234, 0.3);
                                        display: flex;
                                        align-items: center;
                                        gap: 10px;
                                    " onmouseover="this.style.transform='translateY(-2px)'" 
                                       onmouseout="this.style.transform='translateY(0)'">
                                        <span style="font-size: 18px;">🌟</span>
                                        <span>开启互动空间</span>
                                    </button>
                                    
                                    <button class="QQ_spirit_option" data-action="create_space" style="
                                        background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
                                        border: none;
                                        color: white;
                                        padding: 15px 20px;
                                        border-radius: 12px;
                                        cursor: pointer;
                                        font-size: 14px;
                                        font-weight: 500;
                                        transition: all 0.3s ease;
                                        box-shadow: 0 3px 10px rgba(67, 233, 123, 0.3);
                                        display: flex;
                                        align-items: center;
                                        gap: 10px;
                                    " onmouseover="this.style.transform='translateY(-2px)'" 
                                       onmouseout="this.style.transform='translateY(0)'">
                                        <span style="font-size: 18px;">✨</span>
                                        <span>创建新互动</span>
                                    </button>
                                    
                                    <button class="QQ_spirit_option" data-action="public_spaces" style="
                                        background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
                                        border: none;
                                        color: white;
                                        padding: 15px 20px;
                                        border-radius: 12px;
                                        cursor: pointer;
                                        font-size: 14px;
                                        font-weight: 500;
                                        transition: all 0.3s ease;
                                        box-shadow: 0 3px 10px rgba(255, 154, 158, 0.3);
                                        display: flex;
                                        align-items: center;
                                        gap: 10px;
                                    " onmouseover="this.style.transform='translateY(-2px)'" 
                                       onmouseout="this.style.transform='translateY(0)'">
                                        <span style="font-size: 18px;">🌐</span>
                                        <span>公共互动空间</span>
                                    </button>
                                    
                                    <button class="QQ_spirit_option" data-action="hide_spirit" style="
                                        background: #f8f9fa;
                                        border: 1px solid #e9ecef;
                                        color: #6c757d;
                                        padding: 12px 20px;
                                        border-radius: 12px;
                                        cursor: pointer;
                                        font-size: 14px;
                                        font-weight: 500;
                                        transition: all 0.3s ease;
                                        display: flex;
                                        align-items: center;
                                        gap: 10px;
                                    " onmouseover="this.style.background='#e9ecef'" 
                                       onmouseout="this.style.background='#f8f9fa'">
                                        <span style="font-size: 18px;">👻</span>
                                        <span>隐藏精灵</span>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                
                // 添加到页面
                $('body').append(panelHtml);
                
                // 绑定关闭事件
                $('.QQ_close_spirit_panel').on('click', function() {
                    $('.QQ_character_spirit_panel').fadeOut(300, function() {
                        $(this).remove();
                    });
                });
                
                // 绑定选项事件
                $('.QQ_spirit_option[data-action="interactive_space"]').on('click', function() {
                    $('.QQ_character_spirit_panel').remove();
                    QQ_ShowCharacterInteractiveSpaces(characterName);
                });
                
                $('.QQ_spirit_option[data-action="create_space"]').on('click', function() {
                    $('.QQ_character_spirit_panel').remove();
                    QQ_CreateCharacterInteractiveSpace(characterName);
                });
                
                $('.QQ_spirit_option[data-action="public_spaces"]').on('click', function() {
                    $('.QQ_character_spirit_panel').remove();
                    QQ_ShowPublicInteractiveSpaces();
                });
                
                $('.QQ_spirit_option[data-action="hide_spirit"]').on('click', function() {
                    $('.QQ_character_spirit_panel').remove();
                    QQ_HideCharacterSpirit(characterName);
                    toastr.info(`已隐藏 ${characterName} 的精灵按钮`, '精灵按钮');
                });
                
                // 点击背景关闭
                $('.QQ_character_spirit_panel').on('click', function(e) {
                    if (e.target === this) {
                        $(this).fadeOut(300, function() {
                            $(this).remove();
                        });
                    }
                });
            }
            
            /**
             * 显示角色的互动空间列表
             * @param {string} characterName - 角色名称
             */
            function QQ_ShowCharacterInteractiveSpaces(characterName) {
                console.log(`显示角色 ${characterName} 的互动空间列表`);
                
                // *** 新增：检查是否已预加载，如果没有则立即加载 ***
                if (!window.QQ_PreloadedCharacters || !window.QQ_PreloadedCharacters.has(characterName)) {
                    console.log(`⚡ 角色 ${characterName} 数据未预加载，立即从世界书加载...`);
                    
                    // 显示加载中的界面
                    QQ_ShowLoadingInteractiveSpaces(characterName);
                    
                    // 异步加载数据
                    QQ_LoadSpecificCharacterSpaces(characterName).then(() => {
                        // 加载完成后重新显示
                        QQ_ShowCharacterInteractiveSpacesList(characterName);
                    }).catch(error => {
                        console.error('加载角色互动空间失败:', error);
                        toastr.error(`加载 ${characterName} 的互动空间失败`, '加载错误');
                        QQ_ShowCharacterInteractiveSpacesList(characterName); // 仍然显示，可能有缓存数据
                    });
                    
                    return;
                }
                
                // 数据已预加载，直接显示列表
                QQ_ShowCharacterInteractiveSpacesList(characterName);
            }
            
            /**
             * *** 新增：显示加载中的互动空间界面 ***
             * @param {string} characterName - 角色名称
             */
            function QQ_ShowLoadingInteractiveSpaces(characterName) {
                // 移除现有面板
                $('.QQ_character_spaces_list').remove();
                
                const loadingHtml = `
                    <div class="QQ_character_spaces_list" style="
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0, 0, 0, 0.8);
                        z-index: 999999999;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        animation: fadeIn 0.3s ease;
                        backdrop-filter: blur(15px);
                    ">
                        <div style="
                            background: #ffffff;
                            border-radius: 20px;
                            padding: 40px 30px;
                            max-width: 90%;
                            overflow: hidden;
                            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
                            color: #333;
                            animation: slideIn 0.3s ease;
                            width: 350px;
                            text-align: center;
                        ">
                            <div style="
                                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                                color: white;
                                padding: 20px;
                                margin: -40px -30px 30px -30px;
                                text-align: center;
                            ">
                                <h3 style="margin: 0; font-size: 18px; font-weight: 600;">正在加载...</h3>
                                <p style="margin: 5px 0 0 0; font-size: 12px; opacity: 0.9;">${characterName} 的互动空间数据</p>
                            </div>
                            
                            <div style="
                                margin: 20px 0;
                            ">
                                <div style="
                                    width: 50px;
                                    height: 50px;
                                    border: 4px solid #f3f3f3;
                                    border-top: 4px solid #667eea;
                                    border-radius: 50%;
                                    animation: spin 1s linear infinite;
                                    margin: 0 auto 20px auto;
                                "></div>
                                <p style="
                                    color: #666;
                                    font-size: 14px;
                                    line-height: 1.5;
                                    margin: 0;
                                ">正在从世界书加载互动空间数据...<br/>
                                <small style="font-size: 12px; opacity: 0.7;">首次加载可能需要几秒钟</small></p>
                            </div>
                        </div>
                    </div>
                    <style>
                        @keyframes spin {
                            0% { transform: rotate(0deg); }
                            100% { transform: rotate(360deg); }
                        }
                    </style>
                `;
                
                $('body').append(loadingHtml);
                
                // 点击背景关闭（可选）
                $('.QQ_character_spaces_list').on('click', function(e) {
                    if (e.target === this) {
                        $(this).remove();
                    }
                });
            }
            
            /**
             * *** 新增：显示角色互动空间列表（数据已加载） ***
             * @param {string} characterName - 角色名称
             */
            function QQ_ShowCharacterInteractiveSpacesList(characterName) {
                // 确保角色有互动空间数据
                if (!QQ_CharacterSpaces[characterName]) {
                    QQ_CharacterSpaces[characterName] = {};
                }
                
                const characterSpaces = QQ_CharacterSpaces[characterName];
                const spaceKeys = Object.keys(characterSpaces);
                
                if (spaceKeys.length === 0) {
                    toastr.info(`${characterName} 还没有互动空间，点击创建新互动开始吧！`, '互动空间');
                    QQ_CreateCharacterInteractiveSpace(characterName);
                    return;
                }
                
                // 移除现有面板
                $('.QQ_character_spaces_list').remove();
                
                let spacesListHtml = `
                    <div class="QQ_character_spaces_list" style="
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0, 0, 0, 0.8);
                        z-index: 999999999;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        animation: fadeIn 0.3s ease;
                        backdrop-filter: blur(15px);
                    ">
                        <div style="
                            background: #ffffff;
                            border-radius: 20px;
                            padding: 0;
                            max-width: 90%;
                            max-height: 80%;
                            overflow: hidden;
                            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
                            color: #333;
                            animation: slideIn 0.3s ease;
                            width: 400px;
                        ">
                            <div style="
                                background: linear-gradient(135deg, #FF6B6B 0%, #FF8E53 100%);
                                color: white;
                                padding: 20px;
                                text-align: center;
                                position: relative;
                            ">
                                <h3 style="margin: 0; font-size: 18px; font-weight: 600;">${characterName} 的互动空间</h3>
                                <p style="margin: 5px 0 0 0; font-size: 12px; opacity: 0.9;">选择一个互动空间</p>
                                <button class="QQ_close_spaces_list" style="
                                    position: absolute;
                                    top: 15px;
                                    right: 15px;
                                    background: rgba(255, 255, 255, 0.2);
                                    border: none;
                                    color: white;
                                    width: 30px;
                                    height: 30px;
                                    border-radius: 50%;
                                    cursor: pointer;
                                    font-size: 16px;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                ">×</button>
                            </div>
                            
                            <div style="
                                padding: 20px;
                                max-height: 300px;
                                overflow-y: auto;
                            ">
                `;
                
                // 添加互动空间选项
                spaceKeys.forEach(spaceId => {
                    const space = characterSpaces[spaceId];
                    spacesListHtml += `
                        <div class="QQ_space_item" data-space-id="${spaceId}" style="
                            background: #f8f9fa;
                            border: 1px solid #e9ecef;
                            border-radius: 12px;
                            padding: 15px;
                            margin-bottom: 10px;
                            cursor: pointer;
                            transition: all 0.3s ease;
                        " onmouseover="this.style.background='#e9ecef'" 
                           onmouseout="this.style.background='#f8f9fa'">
                            <h4 style="margin: 0 0 5px 0; font-size: 14px; color: #333;">${space.name}</h4>
                            <p style="margin: 0; font-size: 12px; color: #666; line-height: 1.4;">
                                ${space.content.substring(0, 100)}${space.content.length > 100 ? '...' : ''}
                            </p>
                        </div>
                    `;
                });
                
                spacesListHtml += `
                            </div>
                            
                            <div style="
                                padding: 20px;
                                border-top: 1px solid #eee;
                                text-align: center;
                            ">
                                <button class="QQ_create_new_space" style="
                                    background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
                                    border: none;
                                    color: white;
                                    padding: 12px 20px;
                                    border-radius: 10px;
                                    cursor: pointer;
                                    font-size: 14px;
                                    font-weight: 500;
                                    transition: all 0.3s ease;
                                ">
                                    ✨ 创建新互动空间
                                </button>
                            </div>
                        </div>
                    </div>
                `;
                
                // 添加到页面
                $('body').append(spacesListHtml);
                
                // 绑定事件
                $('.QQ_close_spaces_list').on('click', function() {
                    $('.QQ_character_spaces_list').remove();
                });
                
                $('.QQ_space_item').on('click', function() {
                    const spaceId = $(this).data('space-id');
                    $('.QQ_character_spaces_list').remove();
                    QQ_DisplayEnhancedInteractiveSpace(spaceId, characterSpaces[spaceId].name, characterName);
                });
                
                $('.QQ_create_new_space').on('click', function() {
                    $('.QQ_character_spaces_list').remove();
                    QQ_CreateCharacterInteractiveSpace(characterName);
                });
                
                // 点击背景关闭
                $('.QQ_character_spaces_list').on('click', function(e) {
                    if (e.target === this) {
                        $(this).remove();
                    }
                });
            }
            
            /**
             * *** 新增：显示公共互动空间列表 ***
             * 在用户点击公共互动空间按钮时立即从世界书加载完整数据
             */
            function QQ_ShowPublicInteractiveSpaces() {
                console.log('🌐 显示公共互动空间列表，立即从世界书加载完整数据...');
                
                // 显示加载中的界面
                QQ_ShowLoadingPublicSpaces();
                
                // 立即从世界书加载完整的公共互动空间数据
                QQ_LoadFullPublicInteractiveSpaces().then((spaces) => {
                    // 加载完成后显示列表
                    QQ_ShowPublicInteractiveSpacesList(spaces);
                }).catch(error => {
                    console.error('加载公共互动空间失败:', error);
                    toastr.error('加载公共互动空间失败', '加载错误');
                    // 即使失败也显示预览数据
                    const previewSpaces = window.QQ_PublicSpacePreviews || {};
                    QQ_ShowPublicInteractiveSpacesList(previewSpaces, true);
                });
            }
            
            /**
             * *** 新增：显示公共互动空间加载界面 ***
             */
            function QQ_ShowLoadingPublicSpaces() {
                // 移除现有面板
                $('.QQ_public_spaces_list').remove();
                
                const loadingHtml = `
                    <div class="QQ_public_spaces_list" style="
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0, 0, 0, 0.8);
                        z-index: 999999999;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        animation: fadeIn 0.3s ease;
                        backdrop-filter: blur(15px);
                    ">
                        <div style="
                            background: #ffffff;
                            border-radius: 20px;
                            padding: 40px 30px;
                            max-width: 90%;
                            overflow: hidden;
                            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
                            color: #333;
                            animation: slideIn 0.3s ease;
                            width: 400px;
                            text-align: center;
                        ">
                            <div style="
                                background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
                                color: white;
                                padding: 20px;
                                margin: -40px -30px 30px -30px;
                                text-align: center;
                            ">
                                <h3 style="margin: 0; font-size: 18px; font-weight: 600;">正在加载...</h3>
                                <p style="margin: 5px 0 0 0; font-size: 12px; opacity: 0.9;">公共互动空间数据</p>
                            </div>
                            
                            <div style="
                                margin: 20px 0;
                            ">
                                <div style="
                                    width: 50px;
                                    height: 50px;
                                    border: 4px solid #f3f3f3;
                                    border-top: 4px solid #ff9a9e;
                                    border-radius: 50%;
                                    animation: spin 1s linear infinite;
                                    margin: 0 auto 20px auto;
                                "></div>
                                <p style="
                                    color: #666;
                                    font-size: 14px;
                                    line-height: 1.5;
                                    margin: 0;
                                ">正在从世界书加载公共互动空间数据...<br/>
                                <small style="font-size: 12px; opacity: 0.7;">首次加载可能需要几秒钟</small></p>
                            </div>
                        </div>
                    </div>
                `;
                
                $('body').append(loadingHtml);
                
                // 点击背景关闭（可选）
                $('.QQ_public_spaces_list').on('click', function(e) {
                    if (e.target === this) {
                        $(this).remove();
                    }
                });
            }
            
            /**
             * *** 新增：从世界书加载完整的公共互动空间数据 ***
             */
            async function QQ_LoadFullPublicInteractiveSpaces() {
                try {
                    if (!worldbook || !entries) {
                        console.warn('世界书功能不可用，无法加载公共互动空间');
                        return {};
                    }
                    
                    // 查找所有公共互动空间条目
                    const publicSpaceEntries = entries.filter(e => 
                        e.comment && e.comment.includes('QQ_互动空间备份') && 
                        !e.comment.includes('角色互动空间') &&
                        !e.comment.includes('QQ_互动内容')
                    );
                    
                    const allSpaces = {};
                    let loadedEntries = 0;
                    
                    for (const entry of publicSpaceEntries) {
                        try {
                            const data = JSON.parse(entry.content);
                            if (data.spaces) {
                                // 合并所有公共互动空间
                                Object.keys(data.spaces).forEach(spaceId => {
                                    const space = data.spaces[spaceId];
                                    allSpaces[spaceId] = {
                                        ...space,
                                        sourceEntry: entry.comment,
                                        sourceUid: entry.uid,
                                        isPublic: true
                                    };
                                });
                                loadedEntries++;
                            }
                        } catch (parseError) {
                            console.warn(`解析公共互动空间条目失败:`, parseError);
                        }
                    }
                    
                    console.log(`🌐 完整加载公共互动空间: ${loadedEntries} 个条目, ${Object.keys(allSpaces).length} 个空间`);
                    
                    // 更新全局缓存
                    if (!window.QQ_FullPublicSpaces) {
                        window.QQ_FullPublicSpaces = {};
                    }
                    window.QQ_FullPublicSpaces = allSpaces;
                    
                    return allSpaces;
                    
                } catch (error) {
                    console.error('加载完整公共互动空间失败:', error);
                    throw error;
                }
            }
            
            /**
             * *** 新增：显示公共互动空间列表（数据已加载） ***
             * @param {Object} spaces - 公共互动空间数据
             * @param {boolean} isPreviewOnly - 是否仅为预览模式
             */
            function QQ_ShowPublicInteractiveSpacesList(spaces, isPreviewOnly = false) {
                // 移除现有面板
                $('.QQ_public_spaces_list').remove();
                
                const spaceKeys = Object.keys(spaces);
                
                if (spaceKeys.length === 0) {
                    toastr.info('暂无公共互动空间数据', '公共互动空间');
                    return;
                }
                
                let spacesListHtml = `
                    <div class="QQ_public_spaces_list" style="
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0, 0, 0, 0.8);
                        z-index: 999999999;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        animation: fadeIn 0.3s ease;
                        backdrop-filter: blur(15px);
                    ">
                        <div style="
                            background: #ffffff;
                            border-radius: 20px;
                            padding: 0;
                            max-width: 90%;
                            max-height: 80%;
                            overflow: hidden;
                            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
                            color: #333;
                            animation: slideIn 0.3s ease;
                            width: 450px;
                        ">
                            <div style="
                                background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
                                color: white;
                                padding: 20px;
                                text-align: center;
                                position: relative;
                            ">
                                <h3 style="margin: 0; font-size: 18px; font-weight: 600;">🌐 公共互动空间</h3>
                                <p style="margin: 5px 0 0 0; font-size: 12px; opacity: 0.9;">
                                    ${isPreviewOnly ? '预览模式 · ' : ''}共 ${spaceKeys.length} 个互动空间
                                </p>
                                <button class="QQ_close_public_spaces" style="
                                    position: absolute;
                                    top: 15px;
                                    right: 15px;
                                    background: rgba(255, 255, 255, 0.2);
                                    border: none;
                                    color: white;
                                    width: 30px;
                                    height: 30px;
                                    border-radius: 50%;
                                    cursor: pointer;
                                    font-size: 16px;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                ">×</button>
                            </div>
                            
                            <div style="
                                padding: 20px;
                                max-height: 400px;
                                overflow-y: auto;
                            ">`;
                
                // 按时间排序（最新的在前面）
                const sortedSpaces = spaceKeys.sort((a, b) => {
                    const spaceA = spaces[a];
                    const spaceB = spaces[b];
                    const timeA = spaceA.lastAccess || spaceA.createdAt || '0';
                    const timeB = spaceB.lastAccess || spaceB.createdAt || '0';
                    return new Date(timeB) - new Date(timeA);
                });
                
                // 添加互动空间选项
                sortedSpaces.forEach(spaceId => {
                    const space = spaces[spaceId];
                    const contentPreview = isPreviewOnly ? 
                        (space.preview || (space.content ? space.content.substring(0, 100) + '...' : '无内容预览')) :
                        (space.content ? space.content.substring(0, 100) + '...' : '无内容');
                    const timeStr = space.lastAccess || space.createdAt ? 
                        new Date(space.lastAccess || space.createdAt).toLocaleDateString() : '未知时间';
                    
                    spacesListHtml += `
                        <div class="QQ_public_space_item" data-space-id="${spaceId}" style="
                            background: #f8f9fa;
                            border: 1px solid #e9ecef;
                            border-radius: 12px;
                            padding: 15px;
                            margin-bottom: 10px;
                            cursor: pointer;
                            transition: all 0.3s ease;
                        " onmouseover="this.style.background='#e9ecef'" 
                           onmouseout="this.style.background='#f8f9fa'">
                            <div style="display: flex; align-items: center; margin-bottom: 8px;">
                                <h4 style="margin: 0; font-size: 14px; color: #333; flex: 1;">${space.name || '未命名互动空间'}</h4>
                                <small style="color: #999; font-size: 11px;">${timeStr}</small>
                            </div>
                            <p style="margin: 0 0 5px 0; font-size: 12px; color: #666; line-height: 1.4;">
                                ${contentPreview}
                            </p>
                            <div style="display: flex; align-items: center; justify-content: space-between;">
                                <small style="color: #666; font-size: 11px;">
                                    👤 ${space.characterName || '未知角色'}
                                </small>
                                ${isPreviewOnly ? '<small style="color: #ff9a9e; font-size: 11px;">⚡ 点击加载完整内容</small>' : ''}
                            </div>
                        </div>
                    `;
                });
                
                spacesListHtml += `</div></div></div>`;
                
                // 添加到页面
                $('body').append(spacesListHtml);
                
                // 绑定事件
                $('.QQ_close_public_spaces').on('click', function() {
                    $('.QQ_public_spaces_list').remove();
                });
                
                $('.QQ_public_space_item').on('click', function() {
                    const spaceId = $(this).data('space-id');
                    const space = spaces[spaceId];
                    
                    $('.QQ_public_spaces_list').remove();
                    
                    if (isPreviewOnly) {
                        // 预览模式下需要加载完整内容
                        console.log(`⚡ 加载完整公共互动空间内容: ${spaceId}`);
                        QQ_LoadAndDisplayFullPublicSpace(spaceId, space);
                    } else {
                        // 已有完整内容，直接显示
                        QQ_DisplayPublicInteractiveSpace(spaceId, space);
                    }
                });
                
                // 点击背景关闭
                $('.QQ_public_spaces_list').on('click', function(e) {
                    if (e.target === this) {
                        $(this).remove();
                    }
                });
            }
            
            /**
             * *** 新增：加载并显示完整的公共互动空间内容 ***
             * @param {string} spaceId - 空间ID
             * @param {Object} spacePreview - 空间预览数据
             */
            function QQ_LoadAndDisplayFullPublicSpace(spaceId, spacePreview) {
                // 显示加载状态
                toastr.info('正在加载完整内容...', '公共互动空间');
                
                // 尝试从完整数据中查找
                if (window.QQ_FullPublicSpaces && window.QQ_FullPublicSpaces[spaceId]) {
                    QQ_DisplayPublicInteractiveSpace(spaceId, window.QQ_FullPublicSpaces[spaceId]);
                    return;
                }
                
                // 如果没有完整数据，重新从世界书加载
                QQ_LoadFullPublicInteractiveSpaces().then((spaces) => {
                    if (spaces[spaceId]) {
                        QQ_DisplayPublicInteractiveSpace(spaceId, spaces[spaceId]);
                    } else {
                        toastr.error('未找到该互动空间的完整数据', '加载失败');
                    }
                }).catch(error => {
                    console.error('加载公共互动空间完整内容失败:', error);
                    toastr.error('加载完整内容失败', '错误');
                });
            }
            
            /**
             * *** 新增：显示公共互动空间内容 ***
             * @param {string} spaceId - 空间ID
             * @param {Object} space - 空间数据
             */
            function QQ_DisplayPublicInteractiveSpace(spaceId, space) {
                console.log(`📖 显示公共互动空间: ${spaceId} - ${space.name}`);
                
                // 直接使用现有的互动空间显示函数，但标记为公共空间
                QQ_DisplayEnhancedInteractiveSpace(spaceId, space.name, space.characterName, space.content, true);
            }
            
            /**
             * 创建角色互动空间
             * @param {string} characterName - 角色名称
             */
            function QQ_CreateCharacterInteractiveSpace(characterName) {
                console.log(`为角色 ${characterName} 创建新的互动空间`);
                
                // 生成互动空间请求
                const interactiveRequest = `请为角色 ${characterName} 创建一个新的互动空间。

请以MiPhone格式回复，在content标签中描述一个有趣的互动场景，比如：
- 角色邀请用户参与某个活动
- 创造一个特殊的环境或情境
- 设计一个有趣的对话场景

内容应该生动有趣，能够吸引用户参与互动。`;
                
                // 显示创建状态
                toastr.info(`正在为 ${characterName} 创建互动空间...`, '互动空间');
                
                // 发送请求到AI
                QQ_Gen(interactiveRequest, async function(aiResponse) {
                    try {
                        if (aiResponse && aiResponse.trim()) {
                            // 解析AI回复，提取content内容
                            const contentMatch = aiResponse.match(/<content>([\s\S]*?)<\/content>/i);
                            const interactiveContent = contentMatch ? contentMatch[1].trim() : aiResponse.trim();
                            
                            if (interactiveContent) {
                                // 创建新的互动空间
                                const spaceId = 'space_' + Date.now();
                                const characterAvatar = QQ_GetCharacterAvatar(characterName);
                                
                                if (!QQ_CharacterSpaces[characterName]) {
                                    QQ_CharacterSpaces[characterName] = {};
                                }
                                
                                QQ_CharacterSpaces[characterName][spaceId] = {
                                    id: spaceId,
                                    name: `与${characterName}的互动`,
                                    content: interactiveContent,
                                    characterName: characterName,
                                    characterAvatar: characterAvatar,
                                    type: 'character',
                                    createTime: new Date().toISOString()
                                };
                                
                                // 初始化页面数据
                                QQ_InteractivePages[spaceId] = [interactiveContent];
                                QQ_InteractiveCurrentPage[spaceId] = 0;
                                
                                // *** 立即保存互动内容到世界书 ***
                                QQ_SaveInteractiveContentToWorldBook(interactiveContent, characterName).then(interactiveId => {
                                    console.log(`🎯 创建的互动空间已立即保存到世界书，ID: ${interactiveId}, 角色: ${characterName}`);
                                }).catch(error => {
                                    console.error('保存创建的互动空间失败:', error);
                                });
                                
                                // 同时保存到旧的互动空间存储（兼容性）
                                QQ_SaveInteractiveSpaceToWorldBook(spaceId, characterName).catch(error => {
                                    console.error('保存互动空间失败:', error);
                                });
                                
                                // 显示新创建的互动空间
                                QQ_DisplayEnhancedInteractiveSpace(spaceId, `与${characterName}的互动`, characterName);
                                
                                toastr.success(`已为 ${characterName} 创建新的互动空间！`, '互动空间');
                            } else {
                                toastr.error('AI回复格式错误', '互动空间');
                            }
                        } else {
                            toastr.error('AI回复为空', '互动空间');
                        }
                    } catch (error) {
                        console.error('创建互动空间时出错:', error);
                        toastr.error('创建互动空间失败');
                    }
                });
            }
            
            // ===== 测试和调试功能 =====
            
            /**
             * 测试角色专属精灵系统
             */
            function QQ_Test_Character_Spirit_System() {
                console.log('=== 角色专属精灵系统测试 ===');
                
                // 测试1: 显示当前角色精灵状态
                console.log('当前精灵状态:', QQ_CharacterSpirits);
                
                // 测试2: 显示角色空间数据
                console.log('角色空间数据:', QQ_CharacterSpaces);
                
                // 测试3: 获取当前聊天页面
                const currentChatPage = $('.QQ_chat_page:visible');
                const currentCharacter = currentChatPage.length > 0 ? currentChatPage.attr('data-name') : null;
                console.log('当前聊天角色:', currentCharacter);
                
                // 测试4: 测试头像获取功能
                if (currentCharacter) {
                    const avatar = QQ_GetCharacterAvatar(currentCharacter);
                    console.log(`角色 ${currentCharacter} 的头像:`, avatar);
                }
                
                // 测试5: 检查精灵按钮是否存在
                const spiritButtons = $('.QQ_character_spirit');
                console.log('页面上的精灵按钮数量:', spiritButtons.length);
                spiritButtons.each(function() {
                    const characterName = $(this).attr('data-character');
                    console.log(`- 精灵按钮: ${characterName}`);
                });
                
                toastr.info('角色专属精灵系统测试完成，请查看控制台输出', '系统测试');
            }
            
            /**
             * 手动为指定角色显示精灵按钮（调试用）
             * @param {string} characterName - 角色名称
             */
            function QQ_Debug_Show_Character_Spirit(characterName) {
                if (!characterName) {
                    toastr.error('请提供角色名称', '调试工具');
                    return;
                }
                
                console.log(`手动显示角色 ${characterName} 的精灵按钮`);
                QQ_ShowCharacterSpirit(characterName);
                toastr.success(`已显示角色 ${characterName} 的精灵按钮`, '调试工具');
            }
            
            /**
             * 显示所有精灵系统状态信息
             */
            function QQ_Show_Spirit_System_Stats() {
                console.log('=== 精灵系统状态报告 ===');
                console.log('精灵按钮状态:', QQ_CharacterSpirits);
                console.log('角色空间数据:', QQ_CharacterSpaces);
                console.log('互动页面数据:', QQ_InteractivePages);
                console.log('当前页面索引:', QQ_InteractiveCurrentPage);
                
                // 统计信息
                const spiritCount = Object.keys(QQ_CharacterSpirits).length;
                const spaceCount = Object.keys(QQ_CharacterSpaces).reduce((total, char) => total + Object.keys(QQ_CharacterSpaces[char]).length, 0);
                const pageCount = Object.keys(QQ_InteractivePages).length;
                
                console.log('=== 统计信息 ===');
                console.log(`活跃精灵按钮: ${spiritCount} 个`);
                console.log(`互动空间总数: ${spaceCount} 个`);
                console.log(`页面数据总数: ${pageCount} 个`);
                
                toastr.info(`精灵系统状态: ${spiritCount}个精灵, ${spaceCount}个空间, ${pageCount}个页面`, '系统状态');
            }
            
                         /**
              * 测试头像获取功能
              * @param {string} characterName - 角色名称
              */
             function QQ_Test_Avatar_Loading(characterName) {
                 if (!characterName) {
                     // 获取当前聊天角色
                     const currentChatPage = $('.QQ_chat_page:visible');
                     characterName = currentChatPage.length > 0 ? currentChatPage.attr('data-name') : null;
                     
                     if (!characterName) {
                         toastr.error('请先打开一个私聊页面或提供角色名称', '头像测试');
                         return;
                     }
                 }
                 
                 console.log(`=== 开始测试角色 ${characterName} 的头像获取 ===`);
                 
                 // 获取头像URL
                 const avatarUrl = QQ_GetCharacterAvatar(characterName);
                 
                 // 创建测试界面
                 const testHtml = `
                     <div class="QQ_avatar_test_panel" style="
                         position: fixed;
                         top: 50px;
                         right: 50px;
                         width: 300px;
                         background: white;
                         border-radius: 15px;
                         padding: 20px;
                         box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
                         z-index: 999999999;
                         border: 2px solid #FF6B6B;
                     ">
                         <h3 style="margin: 0 0 15px 0; color: #333; text-align: center;">头像测试面板</h3>
                         <p style="margin: 5px 0; color: #666;"><strong>角色名称:</strong> ${characterName}</p>
                         <p style="margin: 5px 0; color: #666; word-break: break-all;"><strong>头像URL:</strong> ${avatarUrl}</p>
                         
                         <div style="text-align: center; margin: 15px 0;">
                             <img src="${avatarUrl}" alt="${characterName}" style="
                                 width: 80px;
                                 height: 80px;
                                 border-radius: 50%;
                                 border: 3px solid #FF6B6B;
                                 object-fit: cover;
                             " onerror="this.onerror=null; this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA2MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjYwIiBoZWlnaHQ9IjYwIiByeD0iMzAiIGZpbGw9IiNGRjZCNkIiLz4KPHRLEHA+4pWpPC90ZXh0Pgo8L3N2Zz4K'; this.style.border='3px solid red'; console.log('测试头像加载失败: ${characterName}');">
                         </div>
                         
                         <div style="text-align: center; gap: 10px; display: flex; justify-content: space-between;">
                             <button class="QQ_test_show_spirit" style="
                                 background: #FF6B6B;
                                 color: white;
                                 border: none;
                                 padding: 8px 12px;
                                 border-radius: 8px;
                                 cursor: pointer;
                                 font-size: 12px;
                             ">显示精灵</button>
                             <button class="QQ_test_close" style="
                                 background: #999;
                                 color: white;
                                 border: none;
                                 padding: 8px 12px;
                                 border-radius: 8px;
                                 cursor: pointer;
                                 font-size: 12px;
                             ">关闭</button>
                         </div>
                     </div>
                 `;
                 
                 // 移除现有测试面板
                 $('.QQ_avatar_test_panel').remove();
                 
                 // 添加新的测试面板
                 $('body').append(testHtml);
                 
                 // 绑定事件
                 $('.QQ_test_show_spirit').on('click', function() {
                     QQ_ShowCharacterSpirit(characterName);
                     toastr.success(`已显示 ${characterName} 的精灵按钮`, '测试');
                 });
                 
                 $('.QQ_test_close').on('click', function() {
                     $('.QQ_avatar_test_panel').remove();
                 });
                 
                 toastr.info(`头像测试面板已显示，请查看右上角`, '头像测试');
             }
             
             // 添加到全局作用域供调试使用
             window.QQ_Test_Character_Spirit_System = QQ_Test_Character_Spirit_System;
             window.QQ_Debug_Show_Character_Spirit = QQ_Debug_Show_Character_Spirit;
             window.QQ_Show_Spirit_System_Stats = QQ_Show_Spirit_System_Stats;
             window.QQ_Test_Avatar_Loading = QQ_Test_Avatar_Loading;
            
            /**
             * 显示角色专属精灵按钮
             * @param {string} characterName - 角色名称
             */
            function QQ_ShowCharacterSpirit(characterName) {
                // 如果已经显示，则不重复创建
                if ($(`.QQ_character_spirit[data-character="${characterName}"]`).length > 0) return;
                
                console.log(`显示角色 ${characterName} 的专属精灵按钮`);
                
                // 隐藏其他角色的精灵按钮
                QQ_HideAllCharacterSpirits();
                
                // 获取角色头像
                const characterAvatar = QQ_GetCharacterAvatar(characterName);
                
                // 获取上次保存的位置
                const savedPosition = localStorage.getItem(`QQ_spirit_position_${characterName}`);
                let position = { right: '20px', top: '50%' };
                if (savedPosition) {
                    try {
                        position = JSON.parse(savedPosition);
                    } catch (e) {
                        console.warn('解析角色精灵位置失败，使用默认位置');
                    }
                }
                
                                // 创建精灵按钮HTML
                const positionStyle = position.right ? 
                    'right: ' + position.right : 'left: ' + position.left;
                const topBottomStyle = position.bottom ? 
                    'bottom: ' + position.bottom : 'top: ' + position.top;
                
                const spiritHtml = 
                    '<div class="QQ_character_spirit" data-character="' + characterName + '" style="' +
                        'position: fixed;' +
                        positionStyle + ';' +
                        topBottomStyle + ';' +
                        'width: 70px;' +
                        'height: 70px;' +
                        'border-radius: 50%;' +
                        'box-shadow: 0 4px 20px rgba(255, 107, 107, 0.4);' +
                        'cursor: move;' +
                        'z-index: 9999;' +
                        'display: flex;' +
                        'align-items: center;' +
                        'justify-content: center;' +
                        'user-select: none;' +
                        'transition: all 0.3s ease;' +
                        'animation: characterSpiritPulse 2s infinite;' +
                        'background: linear-gradient(135deg, #FF6B6B 0%, #FF8E53 100%);' +
                        'padding: 4px;' +
                    '" title="与 ' + characterName + ' 互动">' +
                        '<img src="' + characterAvatar + '" alt="' + characterName + '" style="' +
                            'width: 100%;' +
                            'height: 100%;' +
                            'border-radius: 50%;' +
                            'object-fit: cover;' +
                            'border: 2px solid white;' +
                        '" onerror="this.onerror=null; this.src=\'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA2MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjYwIiBoZWlnaHQ9IjYwIiByeD0iMzAiIGZpbGw9IiNGRjZCNkIiLz4KPHRLEHA+4pWpPC90ZXh0Pgo8L3N2Zz4K\'; console.log(\'头像加载失败，使用默认头像: ' + characterName + '\');">' +
                        '<div style="' +
                            'position: absolute;' +
                            'bottom: -5px;' +
                            'right: -5px;' +
                            'width: 24px;' +
                            'height: 24px;' +
                            'background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);' +
                            'border-radius: 50%;' +
                            'display: flex;' +
                            'align-items: center;' +
                            'justify-content: center;' +
                            'font-size: 12px;' +
                            'color: white;' +
                            'border: 2px solid white;' +
                            'box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);' +
                        '">✨</div>' +
                    '</div>' +
                    '<style>' +
                        '@keyframes characterSpiritPulse {' +
                            '0%, 100% { transform: scale(1); box-shadow: 0 4px 20px rgba(255, 107, 107, 0.4); }' +
                            '50% { transform: scale(1.05); box-shadow: 0 6px 25px rgba(255, 107, 107, 0.6); }' +
                        '}' +
                        '.QQ_character_spirit:hover {' +
                            'transform: scale(1.1) !important;' +
                            'box-shadow: 0 6px 25px rgba(255, 107, 107, 0.7) !important;' +
                        '}' +
                    '</style>';
                
                $('body').append(spiritHtml);
                
                QQ_CharacterSpirits[characterName] = true;
                console.log(`角色 ${characterName} 的精灵按钮已显示`);
                
                // 绑定点击事件
                $(`.QQ_character_spirit[data-character="${characterName}"]`).on('click touchend', function(e) {
                    if ($(this).hasClass('dragging')) {
                        return;
                    }
                    
                    e.stopPropagation();
                    e.preventDefault();
                    console.log(`角色精灵被点击: ${characterName}`);
                    QQ_ShowCharacterSpiritPanel(characterName);
                });
                
                // 绑定拖拽功能
                QQ_MakeCharacterSpiritDraggable(characterName);
                
                console.log(`角色 ${characterName} 的精灵按钮已显示`);
            }
            
            /**
             * 隐藏所有角色的精灵按钮
             */
            function QQ_HideAllCharacterSpirits() {
                $('.QQ_character_spirit').fadeOut(300, function() {
                    $(this).remove();
                });
                QQ_CharacterSpirits = {};
                console.log('所有角色精灵按钮已隐藏');
            }
            
            /**
             * 隐藏特定角色的精灵按钮
             * @param {string} characterName - 角色名称
             */
            function QQ_HideCharacterSpirit(characterName) {
                $(`.QQ_character_spirit[data-character="${characterName}"]`).fadeOut(300, function() {
                    $(this).remove();
                });
                delete QQ_CharacterSpirits[characterName];
                console.log(`角色 ${characterName} 的精灵按钮已隐藏`);
            }
            
            /**
             * 使角色精灵按钮可拖拽
             * @param {string} characterName - 角色名称
             */
            function QQ_MakeCharacterSpiritDraggable(characterName) {
                let isDragging = false;
                let dragStarted = false;
                let startX, startY, initialX, initialY;
                let dragTimer;
                
                $(`.QQ_character_spirit[data-character="${characterName}"]`).on('mousedown touchstart', function(e) {
                    e.preventDefault();
                    dragStarted = false;
                    
                    const rect = this.getBoundingClientRect();
                    initialX = rect.left;
                    initialY = rect.top;
                    
                    const clientX = e.type === 'touchstart' ? e.originalEvent.touches[0].clientX : e.clientX;
                    const clientY = e.type === 'touchstart' ? e.originalEvent.touches[0].clientY : e.clientY;
                    
                    startX = clientX - initialX;
                    startY = clientY - initialY;
                    
                    dragTimer = setTimeout(() => {
                        isDragging = true;
                        dragStarted = true;
                        
                        $(`.QQ_character_spirit[data-character="${characterName}"]`).addClass('dragging').css({
                            'cursor': 'grabbing',
                            'z-index': '99999999',
                            'animation': 'none'
                        });
                        
                        console.log(`开始拖拽角色精灵: ${characterName}`);
                    }, 150);
                });
                
                $(document).on('mousemove touchmove', function(e) {
                    if (!isDragging) return;
                    
                    const clientX = e.type === 'touchmove' ? e.originalEvent.touches[0].clientX : e.clientX;
                    const clientY = e.type === 'touchmove' ? e.originalEvent.touches[0].clientY : e.clientY;
                    
                    const x = clientX - startX;
                    const y = clientY - startY;
                    
                    const maxX = window.innerWidth - 65;
                    const maxY = window.innerHeight - 65;
                    
                    const constrainedX = Math.max(0, Math.min(x, maxX));
                    const constrainedY = Math.max(0, Math.min(y, maxY));
                    
                    $(`.QQ_character_spirit[data-character="${characterName}"]`).css({
                        'left': constrainedX + 'px',
                        'top': constrainedY + 'px',
                        'right': 'auto',
                        'bottom': 'auto'
                    });
                    
                    e.preventDefault();
                });
                
                $(document).on('mouseup touchend', function(e) {
                    if (dragTimer) {
                        clearTimeout(dragTimer);
                        dragTimer = null;
                    }
                    
                    if (!isDragging && !dragStarted) {
                        return;
                    }
                    
                    if (!isDragging) return;
                    isDragging = false;
                    dragStarted = false;
                    
                    const $spirit = $(`.QQ_character_spirit[data-character="${characterName}"]`);
                    $spirit.removeClass('dragging').css({
                        'cursor': 'move',
                        'z-index': '9999999',
                        'animation': 'characterSpiritPulse 2s infinite'
                    });
                    
                    // 保存位置
                    const rect = $spirit[0].getBoundingClientRect();
                    const windowWidth = window.innerWidth;
                    const windowHeight = window.innerHeight;
                    
                    let position;
                    if (rect.left < windowWidth / 2) {
                        position = {
                            left: rect.left + 'px',
                            top: rect.top + 'px'
                        };
                    } else {
                        position = {
                            right: (windowWidth - rect.right) + 'px',
                            top: rect.top + 'px'
                        };
                    }
                    
                    const positionKey = `QQ_character_spirit_position_${characterName}`;
                    localStorage.setItem(positionKey, JSON.stringify(position));
                    console.log(`角色 ${characterName} 精灵位置已保存`);
                });
            }
            
            /**
             * 显示角色精灵面板
             * @param {string} characterName - 角色名称
             */
            function QQ_ShowCharacterSpiritPanel(characterName) {
                console.log(`显示角色 ${characterName} 精灵面板`);
                
                // 确保角色名称有效
                if (!characterName || typeof characterName !== 'string') {
                    console.error('无效的角色名称:', characterName);
                    return;
                }
                
                // 移除现有的面板
                $('.QQ_character_spirit_panel').remove();
                
                // 使用独立性检查确保数据安全
                if (!QQ_EnsureCharacterSpaceIndependence(characterName)) {
                    console.error(`角色 ${characterName} 的互动空间独立性检查失败`);
                    toastr.error('互动空间数据错误');
                    return;
                }
                
                // 获取角色的互动空间列表
                const characterSpaces = QQ_CharacterSpaces[characterName];
                const spaceList = Object.values(characterSpaces);
                
                // 创建面板HTML
                const panelHtml = `
                    <div class="QQ_character_spirit_panel" style="
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        background: white;
                        border-radius: 15px;
                        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
                        z-index: 99999999;
                        overflow: hidden;
                        animation: spiritPanelSlideIn 0.3s ease;
                        max-width: 90%;
                        max-height: 80%;
                        width: 350px;
                    ">
                        <div class="panel-header" style="
                            background: linear-gradient(135deg, #FF6B6B 0%, #FF8E53 100%);
                            color: white;
                            padding: 20px;
                            text-align: center;
                            font-weight: 600;
                        ">
                            <div style="display: flex; align-items: center; justify-content: center; gap: 10px;">
                                <img src="${charAvatarPath || getAvatarUrl(characterName)}" alt="${characterName}" style="
                                    width: 40px;
                                    height: 40px;
                                    border-radius: 50%;
                                    border: 2px solid white;
                                ">
                                <span style="font-size: 16px;">💕 ${characterName}的互动空间</span>
                            </div>
                        </div>
                        
                        ${spaceList.length > 0 ? `
                            <div class="space-list" style="max-height: 300px; overflow-y: auto;">
                                ${spaceList.slice(0, 30).map(space => `
                                    <div class="space-item" data-space-id="${space.id}" style="
                                        padding: 15px 20px;
                                        border-bottom: 1px solid #f0f0f0;
                                        cursor: pointer;
                                        transition: background-color 0.2s ease;
                                        display: flex;
                                        align-items: center;
                                        gap: 12px;
                                    " onmouseover="this.style.backgroundColor='#f8f9fa'" 
                                       onmouseout="this.style.backgroundColor='transparent'">
                                        <div style="
                                            width: 10px;
                                            height: 10px;
                                            border-radius: 50%;
                                            background: #FF6B6B;
                                            flex-shrink: 0;
                                        "></div>
                                        <div style="flex: 1; min-width: 0;">
                                            <div style="
                                                font-size: 14px;
                                                font-weight: 500;
                                                color: #333;
                                                margin-bottom: 3px;
                                                overflow: hidden;
                                                text-overflow: ellipsis;
                                                white-space: nowrap;
                                            ">${space.name}</div>
                                            <div style="
                                                font-size: 12px;
                                                color: #999;
                                            ">${QQ_FormatDate(space.createdAt)}</div>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        ` : `
                            <div style="
                                padding: 40px 20px;
                                text-align: center;
                                color: #999;
                            ">
                                <div style="font-size: 48px; margin-bottom: 15px;">🌟</div>
                                <div style="font-size: 14px; margin-bottom: 8px;">还没有互动记录</div>
                                <div style="font-size: 12px; color: #bbb;">开始一段现实互动吧～</div>
                            </div>
                        `}
                        
                        <div class="panel-actions" style="
                            padding: 20px;
                            background: #fafafa;
                            display: flex;
                            gap: 10px;
                        ">
                            <button class="new-space-btn" style="
                                flex: 1;
                                background: linear-gradient(135deg, #FF6B6B 0%, #FF8E53 100%);
                                border: none;
                                color: white;
                                padding: 12px 16px;
                                border-radius: 8px;
                                cursor: pointer;
                                font-size: 13px;
                                font-weight: 500;
                                transition: all 0.2s ease;
                            " onmouseover="this.style.transform='translateY(-1px)'" 
                               onmouseout="this.style.transform='translateY(0)'">
                                ✨ 创建新互动
                            </button>
                            <button class="close-panel-btn" style="
                                background: #e9ecef;
                                border: none;
                                color: #666;
                                padding: 12px 16px;
                                border-radius: 8px;
                                cursor: pointer;
                                font-size: 13px;
                                font-weight: 500;
                                transition: all 0.2s ease;
                            " onmouseover="this.style.background='#dee2e6'" 
                               onmouseout="this.style.background='#e9ecef'">
                                关闭
                            </button>
                        </div>
                        
                        <!-- 新增：互动状态提示 -->
                        <div class="interactive-tip" style="
                            padding: 12px 20px;
                            background: linear-gradient(135deg, #E8F5E8 0%, #F0F8FF 100%);
                            border-top: 1px solid #e9ecef;
                            font-size: 12px;
                            color: #666;
                            line-height: 1.4;
                        ">
                            <div style="
                                display: flex;
                                align-items: center;
                                gap: 8px;
                                margin-bottom: 6px;
                                font-weight: 500;
                            ">
                                <span style="
                                    display: inline-block;
                                    width: 16px;
                                    height: 16px;
                                    background: #4CAF50;
                                    border-radius: 50%;
                                    color: white;
                                    text-align: center;
                                    line-height: 16px;
                                    font-size: 10px;
                                ">💡</span>
                                <span style="color: #4CAF50;">当前互动触发状态</span>
                            </div>
                            <div id="interactive-status-content" style="margin-left: 24px; font-size: 11px;">
                                <!-- 状态内容将通过JS动态填充 -->
                            </div>
                        </div>
                    </div>
                    
                    <style>
                        @keyframes spiritPanelSlideIn {
                            from {
                                opacity: 0;
                                transform: translate(-50%, -60%);
                            }
                            to {
                                opacity: 1;
                                transform: translate(-50%, -50%);
                            }
                        }
                    </style>
                `;
                
                // 添加到页面
                $('body').append(panelHtml);
                
                // 动态更新互动状态
                QQ_UpdateInteractiveStatus();
                
                // 绑定事件
                $('.QQ_character_spirit_panel').on('click', function(e) {
                    e.stopPropagation();
                    
                    const spaceItem = e.target.closest('.space-item');
                    const newSpaceBtn = e.target.closest('.new-space-btn');
                    const closePanelBtn = e.target.closest('.close-panel-btn');
                    
                    if (spaceItem) {
                        const spaceId = spaceItem.getAttribute('data-space-id');
                        console.log(`点击查看互动空间: ${spaceId}`);
                        QQ_DisplayEnhancedInteractiveSpace(spaceId, `${characterName}的互动空间`, characterName);
                        $('.QQ_character_spirit_panel').remove();
                    } else if (newSpaceBtn) {
                        console.log(`为角色 ${characterName} 创建新的互动空间`);
                        $('.QQ_character_spirit_panel').remove();
                        QQ_ShowCharacterInteractiveSpace(characterName);
                    } else if (closePanelBtn) {
                        $('.QQ_character_spirit_panel').remove();
                    }
                });
                
                // 点击外部关闭面板
                $(document).one('click', function() {
                    $('.QQ_character_spirit_panel').remove();
                });
            }
            
            /**
             * 格式化日期显示
             * @param {string} dateStr - ISO日期字符串
             * @returns {string} 格式化后的日期
             */
            function QQ_FormatDate(dateStr) {
                const date = new Date(dateStr);
                const now = new Date();
                const diffMs = now - date;
                const diffMins = Math.floor(diffMs / 60000);
                const diffHours = Math.floor(diffMs / 3600000);
                const diffDays = Math.floor(diffMs / 86400000);
                
                if (diffMins < 1) {
                    return '刚刚';
                } else if (diffMins < 60) {
                    return `${diffMins}分钟前`;
                } else if (diffHours < 24) {
                    return `${diffHours}小时前`;
                } else if (diffDays < 7) {
                    return `${diffDays}天前`;
                } else {
                    return date.toLocaleDateString('zh-CN', { month: 'short', day: 'numeric' });
                }
            }
            
            /**
             * *** 新增：创建直接的互动内容请求 ***
             * @param {string} userDescription - 用户描述的互动内容
             * @returns {string} 直接互动请求
             */
            function QQ_CreateDirectInteractiveRequest(userDescription) {
                return `🎯 用户主动请求互动内容：
请根据用户的描述："${userDescription}"，直接创建一个生动详细的互动场景。

📋 请求要求：
1. 直接生成互动内容，无需普通聊天回复
2. 内容必须用 <content> 标签包裹
3. 描述要生动详细，符合现实互动的感受
4. 根据互动性质判断保存位置：
   - 涉及多人/群体 → 公共互动空间
   - 单独和角色 → 角色专属空间
5. 互动内容要有沉浸感和真实感
6. 包含动作、对话、感官细节、情感表达

💡 这是用户使用特殊符号主动触发的互动请求，请积极回应！

<Request:请根据上述用户描述生成互动内容，直接用content标签包裹>`;
            }
            
            /**
             * 为互动内容请求修改AI指导
             * @param {string} originalRequest - 原始请求内容
             * @returns {string} - 修改后的请求内容
             */
            function QQ_ModifyRequestForInteractive(originalRequest) {
                // 在Request标签中添加互动内容要求
                const interactiveGuidance = `
<InteractiveGuidance:🔥 强制执行：用户的消息包含明显的互动意图，必须严格按照以下要求回复 🔥

📱【双重回复要求】：
1. 【必须先回复】在用户当前发言的位置（私聊/群聊/动态评论）正常回复，表达反应、确认、情感等
2. 【然后提供互动】用<content>标签包裹详细的现实互动场景描述

🚨【强制执行顺序】：
- 私聊互动：先在私聊中回复 → 再提供互动内容
- 群聊互动：先在群聊中回复 → 再提供互动内容  
- 动态评论互动：先在评论中回复 → 再提供互动内容

💬【回复示例格式】：

**私聊场景**：
<用户名和角色名的私聊>
角色名--好的！我马上过来找你~--时间
</用户名和角色名的私聊>
<content>
*小跑着穿过走廊，轻轻敲响你的房门* "我来了！刚才在准备一些小惊喜给你~" *眼中闪烁着期待和兴奋的光芒，手里还藏着什么东西*
</content>

**群聊场景**：
<群聊名>
角色名--太好了！大家一起来吧！--时间
</群聊名>
<content>
*兴奋地站起身，向大家招手* "那我们就在这里开始吧！" *开始准备需要的物品，脸上洋溢着开心的笑容*
</content>

**动态评论场景**：
moment_start
角色名--看起来很有趣呢！我也想参与
moment_end
<content>
*看到动态后立刻放下手中的事情，快步走向你* "刚看到你的动态，感觉特别有意思！能跟我详细说说吗？" *眼神中充满好奇和期待*
</content>

⚡【强制要求】：
1. 必须先在当前对话位置回复（私聊/群聊/动态评论）
2. 回复要表现出积极响应和情感反应
3. 然后用content标签提供丰富的互动场景
4. 互动内容必须包含动作、对话、感官细节、情感表达
5. 确保互动的连贯性和真实性

🚫【禁止行为】：
- 跳过当前位置的回复直接提供互动
- 互动内容过于简短或缺乏细节
- 忽视用户当前的对话环境
>`;
                
                // 在原始Request之前插入互动指导
                return originalRequest.replace(
                    /<Request:/,
                    `${interactiveGuidance}\n<Request:`
                );
            }
            
            /**
             * 生成互动空间的唯一ID
             */
            function QQ_GenerateSpaceId() {
                return "space_" + Date.now() + "_" + Math.random().toString(36).substr(2, 9);
            }
            
            /**
             * 获取互动空间的智能命名
             * @param {string} content - 互动内容
             * @param {string} characterName - 角色名称
             * @return {string} 智能命名
             */
            function QQ_GetSpaceName(content, characterName) {
                const charName = characterName || charcardname || "角色";
                
                // 检测是否包含多个角色
                const characterMentions = content.match(/(?:@|【|（|＜)\s*([^@【（＜】）＞\s]{2,8})\s*(?:】|）|＞)/g) || [];
                const uniqueChars = [...new Set(characterMentions)];
                
                // 场景关键词提取
                const sceneKeywords = [
                    // 地点场景
                    { keywords: ['咖啡', '咖啡厅', '咖啡店'], name: '咖啡厅' },
                    { keywords: ['教室', '学校', '课堂', '上课'], name: '教室' },
                    { keywords: ['公园', '散步', '樱花', '长椅'], name: '公园' },
                    { keywords: ['家里', '房间', '卧室', '客厅'], name: '家中' },
                    { keywords: ['海边', '沙滩', '海浪', '夕阳'], name: '海边' },
                    { keywords: ['图书馆', '看书', '学习'], name: '图书馆' },
                    { keywords: ['商场', '购物', '逛街'], name: '商场' },
                    { keywords: ['餐厅', '吃饭', '用餐'], name: '餐厅' },
                    
                    // 活动场景
                    { keywords: ['游戏', '玩游戏', '手机游戏'], name: '游戏' },
                    { keywords: ['工作', '办公', '会议'], name: '工作' },
                    { keywords: ['聚会', '派对', '庆祝'], name: '聚会' },
                    { keywords: ['旅行', '旅游', '出行'], name: '旅行' },
                    { keywords: ['运动', '锻炼', '健身'], name: '运动' },
                    { keywords: ['做饭', '料理', '烹饪'], name: '烹饪' },
                    { keywords: ['看电影', '电影', '观影'], name: '观影' },
                    { keywords: ['聊天', '谈话', '交流'], name: '谈话' },
                    
                    // 情感场景
                    { keywords: ['拥抱', '抱抱', '安慰'], name: '温暖时刻' },
                    { keywords: ['生气', '吵架', '争论'], name: '争执' },
                    { keywords: ['开心', '高兴', '快乐'], name: '欢乐时光' },
                    { keywords: ['难过', '伤心', '哭泣'], name: '安慰时刻' },
                    { keywords: ['紧张', '害怕', '担心'], name: '紧张时刻' },
                ];
                
                let detectedScene = "日常";
                for (const scene of sceneKeywords) {
                    if (scene.keywords.some(keyword => content.includes(keyword))) {
                        detectedScene = scene.name;
                        break;
                    }
                }
                
                // 命名逻辑
                if (uniqueChars.length > 1) {
                    // 多角色：场景+关键字
                    const actionKeywords = content.match(/[\u4e00-\u9fa5]{2,4}(?:着|了|呢|吧|呀)/g) || [];
                    const action = actionKeywords.length > 0 ? actionKeywords[0].replace(/[着了呢吧呀]/g, '') : '互动';
                    return `${detectedScene}·${action}`;
                } else {
                    // 单角色：角色名+场景
                    return `${charName}·${detectedScene}`;
                }
            }
            
            /**
             * 保存互动空间到世界书
             */
            async function QQ_SaveInteractiveSpaces() {
                try {
                    if (!worldbook || !entries) {
                        console.warn('世界书功能不可用，无法保存互动空间');
                        return false;
                    }
                    
                    const spaceData = {
                        spaces: QQ_InteractiveSpaces,
                        lastUpdated: new Date().toISOString(),
                        version: "1.0"
                    };
                    
                    console.log(`准备保存互动空间到世界书: ${QQ_INTERACTIVE_BACKUP_KEY}, 空间数量: ${Object.keys(QQ_InteractiveSpaces).length}`);
                    
                    // *** 修复：使用与分组、动态相同的正确保存机制 ***
                    const comment = QQ_INTERACTIVE_BACKUP_KEY;
                    let targetEntry = entries.find(entry => entry.comment === comment);
                    
                    // 准备保存的数据
                    const jsonData = JSON.stringify(spaceData, null, 2);
                    
                    if (targetEntry) {
                        // 使用setLorebookEntries更新现有条目
                        await setLorebookEntries(worldbook, [{
                            uid: targetEntry.uid,
                            content: jsonData,
                        }]);
                        console.log(`✅ 互动空间数据已更新到现有世界书条目: ${comment}`);
                        
                        // 更新本地entries中的对应条目
                        targetEntry.content = jsonData;
                    } else {
                        // 使用createLorebookEntry创建新条目（参考分组和动态的成功实现）
                        await createLorebookEntry(worldbook, {
                            comment: comment,
                            key: [`此世界书永不触发_互动空间备份`],
                            content: jsonData,
                            position: "at_depth_as_system",
                            type: "selective", // 绿灯：选择性触发
                            depth: 0,
                            exclude_recursion: true,
                            order: 9997, // 顺序9997，低于分组9998和动态9999
                            enabled: true,
                        });
                        console.log(`✅ 互动空间数据已保存到新世界书条目: ${comment}`);
                        
                        // 重新获取entries以包含新创建的条目
                        entries = await getLorebookEntries(worldbook);
                    }
                    
                    // 触发世界书保存
                    await QQ_SafeSaveWorldInfo("互动空间数据");
                    
                    // 验证保存结果
                    entries = await getLorebookEntries(worldbook);
                    const verifyEntry = entries.find(entry => entry.comment === comment);
                    
                    if (verifyEntry && verifyEntry.content && verifyEntry.content.includes('"spaces"')) {
                        console.log(`🎯 互动空间保存验证成功: ${Object.keys(QQ_InteractiveSpaces).length}个空间`);
                        console.log(`📊 世界书条目内容长度: ${verifyEntry.content.length} 字符`);
                        return true;
                    } else {
                        console.error('❌ 互动空间保存验证失败');
                        console.error('验证条目:', verifyEntry ? '找到条目但内容异常' : '未找到条目');
                        // 即使验证失败，如果操作没有抛出异常，我们仍然认为保存可能成功了
                        console.log('⚠️ 尽管验证失败，但保存操作已执行，可能数据已保存');
                        return true; // 改为返回true，避免误报失败
                    }
                    
                } catch (error) {
                    console.error('保存互动空间时发生错误:', error);
                    return false;
                }
            }
            
            /**
             * 从世界书加载互动空间
             */
            async function QQ_LoadInteractiveSpaces() {
                try {
                    if (!worldbook || !entries) {
                        console.warn('世界书功能不可用，无法加载互动空间');
                        QQ_InteractiveSpaces = {};
                        return;
                    }
                    
                    // *** 修复：使用与分组相同的直接加载机制 ***
                    const comment = QQ_INTERACTIVE_BACKUP_KEY;
                    const entry = entries.find(e => e.comment === comment);
                    
                    if (entry && entry.content) {
                        try {
                            const data = JSON.parse(entry.content);
                            if (data && data.spaces) {
                                QQ_InteractiveSpaces = data.spaces;
                                console.log(`✅ 从世界书加载互动空间: ${Object.keys(QQ_InteractiveSpaces).length}个空间`);
                            } else {
                                QQ_InteractiveSpaces = {};
                                console.log('📋 世界书条目存在但数据格式异常，初始化为空');
                            }
                        } catch (parseError) {
                            console.error('解析互动空间数据失败:', parseError);
                            QQ_InteractiveSpaces = {};
                        }
                    } else {
                        QQ_InteractiveSpaces = {};
                        console.log('📋 世界书中没有互动空间数据，初始化为空');
                    }
                } catch (error) {
                    console.error('从世界书加载互动空间失败:', error);
                    QQ_InteractiveSpaces = {};
                }
            }
            
            /**
             * *** 新增：预加载角色相关的世界书数据 ***
             * 在打开精灵面板时立即开始加载，确保后续操作响应快速
             * @param {string} characterName - 角色名称
             */
            async function QQ_PreloadCharacterDataFromWorldbook(characterName) {
                console.log(`🚀 开始预加载角色 ${characterName} 的世界书数据`);
                
                try {
                    // 并行加载多个数据源
                    const loadPromises = [
                        // 1. 加载角色专属互动空间
                        QQ_LoadSpecificCharacterSpaces(characterName),
                        // 2. 加载公共互动空间（预览用）
                        QQ_LoadPublicInteractiveSpacesPreview(),
                        // 3. 加载角色互动内容
                        QQ_LoadCharacterInteractiveContent(characterName)
                    ];
                    
                    const results = await Promise.allSettled(loadPromises);
                    
                    // 统计加载结果
                    let successCount = 0;
                    let failCount = 0;
                    
                    results.forEach((result, index) => {
                        if (result.status === 'fulfilled') {
                            successCount++;
                            console.log(`✅ 预加载任务 ${index + 1} 成功`);
                        } else {
                            failCount++;
                            console.warn(`⚠️ 预加载任务 ${index + 1} 失败:`, result.reason);
                        }
                    });
                    
                    console.log(`📊 预加载完成: ${successCount}/${results.length} 个任务成功`);
                    
                    // 标记该角色数据已预加载
                    if (!window.QQ_PreloadedCharacters) {
                        window.QQ_PreloadedCharacters = new Set();
                    }
                    window.QQ_PreloadedCharacters.add(characterName);
                    
                } catch (error) {
                    console.error(`❌ 预加载角色 ${characterName} 数据时出错:`, error);
                }
            }
            
            /**
             * *** 新增：加载特定角色的互动空间数据 ***
             * @param {string} characterName - 角色名称
             */
            async function QQ_LoadSpecificCharacterSpaces(characterName) {
                try {
                    if (!worldbook || !entries) {
                        console.warn('世界书功能不可用，无法加载角色互动空间');
                        return false;
                    }
                    
                    // 确保角色有互动空间数据容器
                    if (!QQ_CharacterSpaces[characterName]) {
                        QQ_CharacterSpaces[characterName] = {};
                    }
                    
                    // 查找角色专属的互动空间条目
                    const characterSpaceEntries = entries.filter(e => 
                        e.comment && e.comment.includes('QQ_角色互动空间') && 
                        e.comment.includes(characterName)
                    );
                    
                    let loadedCount = 0;
                    for (const entry of characterSpaceEntries) {
                        try {
                            const data = JSON.parse(entry.content);
                            if (data.characterName === characterName && data.spaces) {
                                // 合并到角色互动空间数据
                                Object.assign(QQ_CharacterSpaces[characterName], data.spaces);
                                loadedCount++;
                            }
                        } catch (parseError) {
                            console.warn(`解析角色互动空间条目失败:`, parseError);
                        }
                    }
                    
                    console.log(`📦 角色 ${characterName} 互动空间预加载: ${loadedCount} 个条目, ${Object.keys(QQ_CharacterSpaces[characterName]).length} 个空间`);
                    return true;
                    
                } catch (error) {
                    console.error(`加载角色 ${characterName} 互动空间失败:`, error);
                    return false;
                }
            }
            
            /**
             * *** 新增：预加载公共互动空间概览 ***
             * 只加载基本信息，不加载完整内容
             */
            async function QQ_LoadPublicInteractiveSpacesPreview() {
                try {
                    if (!worldbook || !entries) {
                        console.warn('世界书功能不可用，无法预加载公共互动空间');
                        return false;
                    }
                    
                    // 查找公共互动空间相关条目
                    const publicSpaceEntries = entries.filter(e => 
                        e.comment && e.comment.includes('QQ_互动空间备份') && 
                        !e.comment.includes('角色互动空间')
                    );
                    
                    let previewCount = 0;
                    if (!window.QQ_PublicSpacePreviews) {
                        window.QQ_PublicSpacePreviews = {};
                    }
                    
                    for (const entry of publicSpaceEntries) {
                        try {
                            const data = JSON.parse(entry.content);
                            if (data.spaces) {
                                // 只保存预览信息，不加载完整内容
                                Object.keys(data.spaces).forEach(spaceId => {
                                    const space = data.spaces[spaceId];
                                    window.QQ_PublicSpacePreviews[spaceId] = {
                                        id: spaceId,
                                        name: space.name,
                                        characterName: space.characterName,
                                        createdAt: space.createdAt,
                                        lastAccess: space.lastAccess,
                                        preview: space.content ? space.content.substring(0, 100) + '...' : '',
                                        entryComment: entry.comment
                                    };
                                });
                                previewCount++;
                            }
                        } catch (parseError) {
                            console.warn(`解析公共互动空间条目失败:`, parseError);
                        }
                    }
                    
                    console.log(`🌐 公共互动空间预览预加载: ${previewCount} 个条目, ${Object.keys(window.QQ_PublicSpacePreviews || {}).length} 个空间预览`);
                    return true;
                    
                } catch (error) {
                    console.error('预加载公共互动空间预览失败:', error);
                    return false;
                }
            }
            
            /**
             * *** 新增：加载角色互动内容 ***
             * @param {string} characterName - 角色名称
             */
            async function QQ_LoadCharacterInteractiveContent(characterName) {
                try {
                    if (!worldbook || !entries) {
                        console.warn('世界书功能不可用，无法加载角色互动内容');
                        return false;
                    }
                    
                    // 查找角色相关的互动内容条目
                    const contentEntries = entries.filter(e => 
                        e.comment && e.comment.includes('QQ_互动内容') && 
                        e.comment.includes(characterName)
                    );
                    
                    let contentCount = 0;
                    if (!window.QQ_CharacterInteractiveContents) {
                        window.QQ_CharacterInteractiveContents = {};
                    }
                    
                    if (!window.QQ_CharacterInteractiveContents[characterName]) {
                        window.QQ_CharacterInteractiveContents[characterName] = [];
                    }
                    
                    for (const entry of contentEntries) {
                        try {
                            const data = JSON.parse(entry.content);
                            if (data.characterName === characterName) {
                                window.QQ_CharacterInteractiveContents[characterName].push({
                                    id: data.id,
                                    content: data.content,
                                    createdAt: data.createdAt,
                                    entryUid: entry.uid
                                });
                                contentCount++;
                            }
                        } catch (parseError) {
                            console.warn(`解析角色互动内容条目失败:`, parseError);
                        }
                    }
                    
                    console.log(`💬 角色 ${characterName} 互动内容预加载: ${contentCount} 个条目`);
                    return true;
                    
                } catch (error) {
                    console.error(`加载角色 ${characterName} 互动内容失败:`, error);
                    return false;
                }
            }
            
            /**
             * 从世界书加载角色专属互动空间
             */
            async function QQ_LoadCharacterSpaces() {
                try {
                    if (!worldbook || !entries) {
                        console.warn('世界书功能不可用，无法加载角色互动空间');
                        QQ_CharacterSpaces = {};
                        return;
                    }
                    
                    const entry = entries.find(e => e.comment === QQ_CHARACTER_SPACES_KEY);
                    if (entry && entry.content) {
                        const data = JSON.parse(entry.content);
                        QQ_CharacterSpaces = data.characterSpaces || {};
                        const totalSpaces = Object.values(QQ_CharacterSpaces).reduce((sum, char) => sum + Object.keys(char).length, 0);
                        console.log('从世界书加载角色互动空间:', Object.keys(QQ_CharacterSpaces).length, '个角色,', totalSpaces, '个空间');
                    } else {
                        QQ_CharacterSpaces = {};
                        console.log('世界书中没有角色互动空间数据，初始化为空');
                    }
                } catch (error) {
                    console.error('从世界书加载角色互动空间失败:', error);
                    QQ_CharacterSpaces = {};
                }
            }

            /**
             * 在手机界面显示互动空间
             * @param {string} content - 互动内容
             * @param {string} characterName - 角色名称
             */
            function QQ_ShowInteractiveSpace(content, characterName = "") {
                // 清理内容 - 优先处理content标签
                let cleanContent;
                if (QQ_HasContentTag(content)) {
                    cleanContent = QQ_CleanContentTags(content);
                } else {
                    cleanContent = content
                        .replace(/MiPhone_start/g, "")
                        .replace(/MiPhone_end/g, "")
                        .trim();
                }
                
                // 生成空间ID和名称
                const spaceId = QQ_GenerateSpaceId();
                const spaceName = QQ_GetSpaceName(cleanContent, characterName);
                const charName = characterName || charcardname || "角色";
                const charAvatar = charAvatarPath || "default_avatar.png";
                
                // 保存互动空间数据
                QQ_InteractiveSpaces[spaceId] = {
                    id: spaceId,
                    name: spaceName,
                    content: cleanContent,
                    characterName: charName,
                    characterAvatar: charAvatar,
                    createdAt: new Date().toISOString(),
                    lastAccess: new Date().toISOString()
                };
                
                // 设置当前活动空间
                QQ_ActiveSpaceId = spaceId;
                
                // *** 立即保存互动空间到世界书 ***
                // 使用统一的互动空间保存机制，确保UI显示的数据能正确保存
                QQ_SaveInteractiveSpaces().then(() => {
                    console.log(`🎯 互动空间已保存到世界书: ${spaceId}, 角色: ${charName}`);
                }).catch(error => {
                    console.error('保存互动空间失败:', error);
                });
                
                // 移除现有的互动空间
                $('.QQ_interactive_space').remove();
                
                // 创建互动空间HTML - 更符合手机界面风格
                const interactiveSpaceHtml = `
                    <div class="QQ_interactive_space" data-space-id="${spaceId}" style="
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0, 0, 0, 0.7);
                        z-index: 10000;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        animation: fadeIn 0.3s ease;
                        backdrop-filter: blur(10px);
                    ">
                        <div class="QQ_interactive_content" style="
                            background: #ffffff;
                            border-radius: 15px;
                            padding: 0;
                            max-width: 85%;
                            max-height: 75%;
                            overflow: hidden;
                            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
                            position: relative;
                            color: #333;
                            animation: slideIn 0.3s ease;
                            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                        ">
                            <div class="QQ_interactive_header" style="
                                background: linear-gradient(135deg, #4FC3F7 0%, #29B6F6 100%);
                                padding: 20px;
                                display: flex;
                                align-items: center;
                                color: white;
                                position: relative;
                            ">
                                <img src="${charAvatar}" alt="${charName}" style="
                                    width: 45px;
                                    height: 45px;
                                    border-radius: 50%;
                                    margin-right: 15px;
                                    border: 3px solid white;
                                    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
                                ">
                                <div style="flex: 1;">
                                    <h3 style="margin: 0; font-size: 17px; font-weight: 600;">${spaceName}</h3>
                                    <p style="margin: 3px 0 0 0; font-size: 13px; opacity: 0.9;">现实互动模式</p>
                                </div>
                                <button class="QQ_rename_space" style="
                                    background: rgba(255, 255, 255, 0.2);
                                    border: none;
                                    color: white;
                                    width: 32px;
                                    height: 32px;
                                    border-radius: 50%;
                                    cursor: pointer;
                                    font-size: 14px;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    transition: all 0.3s ease;
                                    margin-right: 8px;
                                " onmouseover="this.style.background='rgba(255, 255, 255, 0.3)'" 
                                   onmouseout="this.style.background='rgba(255, 255, 255, 0.2)'"
                                   title="重命名空间">
                                    ✏️
                                </button>
                                <button class="QQ_close_interactive" style="
                                    background: rgba(255, 255, 255, 0.2);
                                    border: none;
                                    color: white;
                                    width: 32px;
                                    height: 32px;
                                    border-radius: 50%;
                                    cursor: pointer;
                                    font-size: 18px;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    transition: all 0.3s ease;
                                " onmouseover="this.style.background='rgba(255, 255, 255, 0.3)'" 
                                   onmouseout="this.style.background='rgba(255, 255, 255, 0.2)'">
                                    ×
                                </button>
                            </div>
                            <div class="QQ_interactive_body" style="
                                padding: 25px 20px;
                                font-size: 15px;
                                line-height: 1.5;
                                white-space: pre-wrap;
                                color: #333;
                                background: #fafafa;
                                max-height: 300px;
                                overflow-y: auto;
                            ">${cleanContent}</div>
                            <div class="QQ_interactive_footer" style="
                                padding: 20px;
                                background: #ffffff;
                                border-top: 1px solid #eee;
                                display: flex;
                                justify-content: center;
                                gap: 15px;
                            ">
                                <button class="QQ_reply_interactive" style="
                                    background: #4FC3F7;
                                    border: none;
                                    color: white;
                                    padding: 12px 24px;
                                    border-radius: 25px;
                                    cursor: pointer;
                                    font-size: 14px;
                                    font-weight: 500;
                                    transition: all 0.3s ease;
                                    box-shadow: 0 2px 8px rgba(79, 195, 247, 0.3);
                                " onmouseover="this.style.background='#29B6F6'; this.style.transform='translateY(-1px)'" 
                                   onmouseout="this.style.background='#4FC3F7'; this.style.transform='translateY(0)'">
                                    💬 回应互动
                                </button>
                                <button class="QQ_close_interactive" style="
                                    background: #f5f5f5;
                                    border: none;
                                    color: #666;
                                    padding: 12px 24px;
                                    border-radius: 25px;
                                    cursor: pointer;
                                    font-size: 14px;
                                    font-weight: 500;
                                    transition: all 0.3s ease;
                                " onmouseover="this.style.background='#eeeeee'" 
                                   onmouseout="this.style.background='#f5f5f5'">
                                    关闭
                                </button>
                            </div>
                        </div>
                    </div>
                    <style>
                        @keyframes fadeIn {
                            from { opacity: 0; }
                            to { opacity: 1; }
                        }
                        @keyframes slideIn {
                            from { transform: translateY(-30px); opacity: 0; }
                            to { transform: translateY(0); opacity: 1; }
                        }
                        .QQ_interactive_space * {
                            user-select: text;
                        }
                    </style>
                `;
                
                // 添加到页面
                $('body').append(interactiveSpaceHtml);
                
                // 绑定重命名事件
                $('.QQ_rename_space').off('click').on('click', function() {
                    QQ_RenameInteractiveSpace(spaceId);
                });
                
                // 绑定关闭事件
                $('.QQ_close_interactive').off('click').on('click', function() {
                    QQ_CloseInteractiveSpace();
                });
                
                // 绑定回应互动事件
                $('.QQ_reply_interactive').off('click').on('click', function() {
                    // 关闭互动空间
                    QQ_CloseInteractiveSpace();
                    
                    // 打开输入框让用户回应
                    QQ_OpenInteractiveReply(charName);
                });
                
                // 点击背景关闭
                $('.QQ_interactive_space').on('click', function(e) {
                    if (e.target === this) {
                        QQ_CloseInteractiveSpace();
                    }
                });
                
                triggerSlash(`/echo 检测到互动内容，已在手机界面显示：${spaceName}`);
            }
            
            /**
             * 关闭互动空间并显示精灵按钮
             */
            function QQ_CloseInteractiveSpace() {
                $('.QQ_interactive_space').fadeOut(300, function() {
                            $(this).remove();
                    // 显示精灵按钮
                    QQ_ShowSpiritButton();
                });
                QQ_ActiveSpaceId = null;
            }
            
            /**
             * 重命名互动空间
             * @param {string} spaceId - 空间ID
             */
            function QQ_RenameInteractiveSpace(spaceId) {
                const space = QQ_InteractiveSpaces[spaceId];
                if (!space) return;
                
                const newName = prompt('请输入新的空间名称:', space.name);
                if (newName && newName.trim() && newName.trim() !== space.name) {
                    space.name = newName.trim();
                    // 更新显示
                    $('.QQ_interactive_header h3').text(space.name);
                    // 保存到世界书
                    QQ_SaveInteractiveSpaces();
                    triggerSlash(`/echo 互动空间已重命名为：${space.name}`);
                }
            }
            
            // ===== 增强版互动空间系统 =====
            
            let QQ_InteractivePages = {}; // 存储每个互动空间的页面数据
            let QQ_InteractiveCurrentPage = {}; // 存储当前显示的页面索引
            
            /**
             * 显示增强版互动空间（带回复和分页功能）
             * @param {string} spaceId - 空间ID
             * @param {string} spaceTitle - 空间标题
             * @param {string} characterName - 角色名（可选，用于角色专属空间）
             */
            function QQ_DisplayEnhancedInteractiveSpace(spaceId, spaceTitle, characterName = null) {
                const spaceData = characterName ? 
                    QQ_CharacterSpaces[characterName][spaceId] : 
                    QQ_InteractiveSpaces[spaceId];
                
                if (!spaceData) {
                    console.error('未找到互动空间数据:', spaceId);
                    return;
                }
                
                // 初始化页面数据
                if (!QQ_InteractivePages[spaceId]) {
                    QQ_InteractivePages[spaceId] = [spaceData.content];
                }
                if (!QQ_InteractiveCurrentPage[spaceId]) {
                    QQ_InteractiveCurrentPage[spaceId] = 0;
                }
                
                // 移除现有的互动空间
                $('.QQ_interactive_space_enhanced').remove();
                
                const isCharacterSpace = spaceData.type === 'character';
                const headerColor = isCharacterSpace ? 
                    'linear-gradient(135deg, #FF6B6B 0%, #FF8E53 100%)' : 
                    'linear-gradient(135deg, #4FC3F7 0%, #29B6F6 100%)';
                
                const currentPageIndex = QQ_InteractiveCurrentPage[spaceId];
                const totalPages = QQ_InteractivePages[spaceId].length;
                const currentContent = QQ_InteractivePages[spaceId][currentPageIndex];
                
                // 创建增强版互动空间HTML
                const interactiveSpaceHtml = `
                    <div class="QQ_interactive_space_enhanced" data-space-id="\${spaceId}" style="
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0, 0, 0, 0.7);
                        z-index: 99999999;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        animation: fadeIn 0.3s ease;
                        backdrop-filter: blur(10px);
                    ">
                        <div class="QQ_interactive_content_enhanced" style="
                            background: #ffffff;
                            border-radius: 20px;
                            padding: 0;
                            max-width: 90%;
                            max-height: 85%;
                            overflow: hidden;
                            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
                            position: relative;
                            color: #333;
                            animation: slideIn 0.3s ease;
                            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                            width: 400px;
                        ">
                            <div class="QQ_interactive_header_enhanced" style="
                                background: \${headerColor};
                                padding: 20px;
                                display: flex;
                                align-items: center;
                                color: white;
                                position: relative;
                            ">
                                <img src="\${spaceData.characterAvatar}" alt="\${spaceData.characterName}" style="
                                    width: 45px;
                                    height: 45px;
                                    border-radius: 50%;
                                    margin-right: 12px;
                                    border: 2px solid white;
                                    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
                                ">
                                <div style="flex: 1;">
                                    <h3 style="margin: 0; font-size: 16px; font-weight: 600;">\${spaceData.name}</h3>
                                    <p style="margin: 3px 0 0 0; font-size: 12px; opacity: 0.9;">
                                        \${isCharacterSpace ? \`\${spaceData.characterName}的专属互动\` : '公共互动空间'}
                                    </p>
                                </div>
                                \${totalPages > 1 ? \`
                                    <div style="margin-right: 15px; font-size: 12px; opacity: 0.9;">
                                        \${currentPageIndex + 1} / \${totalPages}
                                    </div>
                                \` : ''}
                                <button class="QQ_close_interactive_enhanced" style="
                                    background: rgba(255, 255, 255, 0.2);
                                    border: none;
                                    color: white;
                                    width: 30px;
                                    height: 30px;
                                    border-radius: 50%;
                                    cursor: pointer;
                                    font-size: 16px;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    transition: all 0.3s ease;
                                " onmouseover="this.style.background='rgba(255, 255, 255, 0.3)'" 
                                   onmouseout="this.style.background='rgba(255, 255, 255, 0.2)'">
                                    ×
                                </button>
                            </div>
                            
                            <div class="QQ_interactive_body_enhanced" style="
                                padding: 25px 20px;
                                font-size: 15px;
                                line-height: 1.6;
                                white-space: pre-wrap;
                                color: #333;
                                background: #fafafa;
                                max-height: 280px;
                                overflow-y: auto;
                                word-wrap: break-word;
                                border-bottom: 1px solid #eee;
                            ">\${currentContent}</div>
                            
                            \${totalPages > 1 ? \`
                                <div class="QQ_interactive_pagination" style="
                                    padding: 15px 20px;
                                    background: #ffffff;
                                    border-bottom: 1px solid #eee;
                                    display: flex;
                                    justify-content: center;
                                    gap: 10px;
                                    align-items: center;
                                ">
                                    <button class="QQ_prev_page" \${currentPageIndex === 0 ? 'disabled' : ''} style="
                                        background: \${currentPageIndex === 0 ? '#f5f5f5' : '#e3f2fd'};
                                        border: none;
                                        color: \${currentPageIndex === 0 ? '#999' : '#1976d2'};
                                        padding: 8px 12px;
                                        border-radius: 6px;
                                        cursor: \${currentPageIndex === 0 ? 'not-allowed' : 'pointer'};
                                        font-size: 12px;
                                        font-weight: 500;
                                        transition: all 0.2s ease;
                                    ">← 上一页</button>
                                    
                                    <span style="font-size: 12px; color: #666; margin: 0 10px;">
                                        第 \${currentPageIndex + 1} 页，共 \${totalPages} 页
                                    </span>
                                    
                                    <button class="QQ_next_page" \${currentPageIndex === totalPages - 1 ? 'disabled' : ''} style="
                                        background: \${currentPageIndex === totalPages - 1 ? '#f5f5f5' : '#e3f2fd'};
                                        border: none;
                                        color: \${currentPageIndex === totalPages - 1 ? '#999' : '#1976d2'};
                                        padding: 8px 12px;
                                        border-radius: 6px;
                                        cursor: \${currentPageIndex === totalPages - 1 ? 'not-allowed' : 'pointer'};
                                        font-size: 12px;
                                        font-weight: 500;
                                        transition: all 0.2s ease;
                                    ">下一页 →</button>
                                </div>
                            \` : ''}
                            
                            <div class="QQ_interactive_footer_enhanced" style="
                                padding: 20px;
                                background: #ffffff;
                                display: flex;
                                justify-content: center;
                                gap: 12px;
                            ">
                                <button class="QQ_reply_interactive_enhanced" style="
                                    background: \${isCharacterSpace ? '#FF6B6B' : '#4FC3F7'};
                                    border: none;
                                    color: white;
                                    padding: 12px 20px;
                                    border-radius: 20px;
                                    cursor: pointer;
                                    font-size: 13px;
                                    font-weight: 500;
                                    transition: all 0.3s ease;
                                    box-shadow: 0 2px 8px \${isCharacterSpace ? 'rgba(255, 107, 107, 0.3)' : 'rgba(79, 195, 247, 0.3)'};
                                " onmouseover="this.style.transform='translateY(-1px)'" 
                                   onmouseout="this.style.transform='translateY(0)'">
                                    💬 回应互动
                                </button>
                                <button class="QQ_close_interactive_enhanced" style="
                                    background: #f5f5f5;
                                    border: none;
                                    color: #666;
                                    padding: 12px 20px;
                                    border-radius: 20px;
                                    cursor: pointer;
                                    font-size: 13px;
                                    font-weight: 500;
                                    transition: all 0.3s ease;
                                " onmouseover="this.style.background='#eeeeee'" 
                                   onmouseout="this.style.background='#f5f5f5'">
                                    关闭
                                </button>
                            </div>
                                                 </div>
                     </div>
                 `;
                
                // 添加到页面
                $('body').append(interactiveSpaceHtml);
                
                // 绑定关闭事件
                $('.QQ_close_interactive_enhanced').on('click', function() {
                    $('.QQ_interactive_space_enhanced').fadeOut(300, function() {
                        $(this).remove();
                    });
                });
                
                // 绑定回复事件
                $('.QQ_reply_interactive_enhanced').on('click', function() {
                    QQ_OpenEnhancedInteractiveReply(spaceId, characterName || spaceData.characterName);
                });
                
                // 绑定分页事件
                $('.QQ_prev_page').on('click', function() {
                    if (currentPageIndex > 0) {
                        QQ_InteractiveCurrentPage[spaceId] = currentPageIndex - 1;
                        QQ_DisplayEnhancedInteractiveSpace(spaceId, spaceTitle, characterName);
                    }
                });
                
                $('.QQ_next_page').on('click', function() {
                    if (currentPageIndex < totalPages - 1) {
                        QQ_InteractiveCurrentPage[spaceId] = currentPageIndex + 1;
                        QQ_DisplayEnhancedInteractiveSpace(spaceId, spaceTitle, characterName);
                    }
                });
                
                // 点击背景关闭
                $('.QQ_interactive_space_enhanced').on('click', function(e) {
                    if (e.target === this) {
                        $(this).fadeOut(300, function() {
                            $(this).remove();
                        });
                    }
                });
            }
            
            /**
             * 打开增强版互动回复界面
             * @param {string} spaceId - 空间ID
             * @param {string} characterName - 角色名称
             */
            function QQ_OpenEnhancedInteractiveReply(spaceId, characterName) {
                // 移除现有的回复界面
                $('.QQ_interactive_reply_enhanced').remove();
                
                const replyHtml = `
                    <div class="QQ_interactive_reply_enhanced" style="
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0, 0, 0, 0.8);
                        z-index: 999999999;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        animation: fadeIn 0.3s ease;
                        backdrop-filter: blur(15px);
                    ">
                        <div class="QQ_reply_content_enhanced" style="
                            background: #ffffff;
                            border-radius: 16px;
                            padding: 0;
                            max-width: 90%;
                            overflow: hidden;
                            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
                            color: #333;
                            animation: slideIn 0.3s ease;
                            width: 380px;
                        ">
                            <div class="reply-header" style="
                                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                                color: white;
                                padding: 18px 20px;
                                text-align: center;
                                font-weight: 600;
                                font-size: 15px;
                            ">
                                💬 回应 ${characterName} 的互动
                            </div>
                            
                            <div class="reply-body" style="
                                padding: 25px 20px;
                            ">
                                <textarea class="QQ_reply_input_enhanced" placeholder="在这里输入你的回应..." style="
                                    width: 100%;
                                    height: 120px;
                                    border: 2px solid #e9ecef;
                                    border-radius: 12px;
                                    padding: 15px;
                                    font-size: 14px;
                                    line-height: 1.5;
                                    resize: none;
                                    box-sizing: border-box;
                                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                                    outline: none;
                                    transition: all 0.3s ease;
                                " onfocus="this.style.borderColor='#667eea'; this.style.boxShadow='0 0 0 3px rgba(102, 126, 234, 0.1)'" 
                                   onblur="this.style.borderColor='#e9ecef'; this.style.boxShadow='none'"></textarea>
                            </div>
                            
                            <div class="reply-footer" style="
                                padding: 0 20px 20px 20px;
                                display: flex;
                                gap: 12px;
                            ">
                                <button class="QQ_send_reply_enhanced" style="
                                    flex: 1;
                                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                                    border: none;
                                    color: white;
                                    padding: 12px;
                                    border-radius: 10px;
                                    cursor: pointer;
                                    font-size: 14px;
                                    font-weight: 500;
                                    transition: all 0.3s ease;
                                    box-shadow: 0 3px 10px rgba(102, 126, 234, 0.3);
                                " onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 5px 15px rgba(102, 126, 234, 0.4)'" 
                                   onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 3px 10px rgba(102, 126, 234, 0.3)'">
                                    🚀 发送回应
                                </button>
                                <button class="QQ_cancel_reply_enhanced" style="
                                    background: #f8f9fa;
                                    border: none;
                                    color: #6c757d;
                                    padding: 12px 20px;
                                    border-radius: 10px;
                                    cursor: pointer;
                                    font-size: 14px;
                                    font-weight: 500;
                                    transition: all 0.3s ease;
                                " onmouseover="this.style.background='#e9ecef'" 
                                   onmouseout="this.style.background='#f8f9fa'">
                                    取消
                                </button>
                            </div>
                        </div>
                    </div>
                `;
                
                // 添加到页面
                $('body').append(replyHtml);
                
                // 自动聚焦输入框
                setTimeout(() => {
                    $('.QQ_reply_input_enhanced').focus();
                }, 100);
                
                // 绑定发送事件
                $('.QQ_send_reply_enhanced').on('click', function() {
                    const replyText = $('.QQ_reply_input_enhanced').val().trim();
                    if (replyText) {
                        QQ_SendInteractiveReply(spaceId, characterName, replyText);
                        $('.QQ_interactive_reply_enhanced').remove();
                    } else {
                        toastr.warning('请输入回应内容');
                        $('.QQ_reply_input_enhanced').focus();
                    }
                });
                
                // 绑定取消事件
                $('.QQ_cancel_reply_enhanced').on('click', function() {
                    $('.QQ_interactive_reply_enhanced').remove();
                });
                
                // 支持回车发送
                $('.QQ_reply_input_enhanced').on('keydown', function(e) {
                    if (e.key === 'Enter' && e.ctrlKey) {
                        $('.QQ_send_reply_enhanced').click();
                    }
                });
                
                // 点击背景关闭
                $('.QQ_interactive_reply_enhanced').on('click', function(e) {
                    if (e.target === this) {
                        $(this).remove();
                    }
                });
            }
            
            /**
             * 发送互动回复并获取AI响应
             * @param {string} spaceId - 空间ID
             * @param {string} characterName - 角色名称
             * @param {string} replyText - 回复内容
             */
            function QQ_SendInteractiveReply(spaceId, characterName, replyText) {
                console.log(`发送互动回复: ${spaceId}, ${characterName}, ${replyText}`);
                
                // 显示加载状态
                toastr.info('正在发送回应...', '互动空间');
                
                // 构建包含回应内容的请求
                const interactiveRequest = `请回应这个互动场景：
                
<content>
${replyText}
</content>

请以MiPhone格式回复，在content标签中描述你对这个回应的反应和新的互动内容。`;
                
                // 发送请求到AI
                QQ_Gen(interactiveRequest, async function(aiResponse) {
                    try {
                        if (aiResponse && aiResponse.trim()) {
                            // 解析AI回复，提取content内容
                            const contentMatch = aiResponse.match(/<content>([\s\S]*?)<\/content>/i);
                            const newInteractiveContent = contentMatch ? contentMatch[1].trim() : aiResponse.trim();
                            
                            if (newInteractiveContent) {
                                // 添加新页面到互动空间
                                if (!QQ_InteractivePages[spaceId]) {
                                    QQ_InteractivePages[spaceId] = [];
                                }
                                QQ_InteractivePages[spaceId].push(newInteractiveContent);
                                
                                // 设置当前页面为最新页面
                                QQ_InteractiveCurrentPage[spaceId] = QQ_InteractivePages[spaceId].length - 1;
                                
                                // 保存到世界书
                                await QQ_SaveInteractiveSpaceToWorldBook(spaceId, characterName);
                                
                                // 重新显示互动空间（显示新页面）
                                QQ_DisplayEnhancedInteractiveSpace(spaceId, `${characterName}的互动空间`, characterName);
                                
                                toastr.success('AI已回应你的互动！', '互动空间');
                            } else {
                                toastr.error('AI回复格式错误', '互动空间');
                            }
                        } else {
                            toastr.error('AI回复为空', '互动空间');
                        }
                    } catch (error) {
                        console.error('处理AI互动回复时出错:', error);
                        toastr.error('处理回复时出错');
                    }
                });
            }
            
            /**
             * 保存互动空间到世界书（优化存储，最大30个）
             * @param {string} spaceId - 空间ID
             * @param {string} characterName - 角色名称
             */
            async function QQ_SaveInteractiveSpaceToWorldBook(spaceId, characterName) {
                try {
                    const storageKey = `QQ_互动空间备份_${characterName}`;
                    
                    // 获取现有的互动空间备份
                    const existingData = getWorldInfoData(storageKey) || { spaces: {}, lastUpdate: new Date().toISOString() };
                    
                    // 更新特定空间的数据
                    existingData.spaces[spaceId] = {
                        id: spaceId,
                        pages: QQ_InteractivePages[spaceId] || [],
                        currentPage: QQ_InteractiveCurrentPage[spaceId] || 0,
                        characterName: characterName,
                        lastModified: new Date().toISOString()
                    };
                    
                    // 检查并限制最大数量为30个
                    const spaceIds = Object.keys(existingData.spaces);
                    if (spaceIds.length > 30) {
                        // 按最后修改时间排序，删除最旧的
                        const sortedSpaces = spaceIds.map(id => ({
                            id,
                            lastModified: existingData.spaces[id].lastModified
                        })).sort((a, b) => new Date(a.lastModified) - new Date(b.lastModified));
                        
                        // 删除最旧的空间，保留最新的30个
                        for (let i = 0; i < spaceIds.length - 30; i++) {
                            delete existingData.spaces[sortedSpaces[i].id];
                        }
                    }
                    
                    existingData.lastUpdate = new Date().toISOString();
                    
                    // 保存到世界书
                    setWorldInfoData(storageKey, existingData);
                    
                    const saveSuccess = await QQ_SafeSaveWorldInfo(`互动空间 ${spaceId}`);
                    if (saveSuccess) {
                        console.log(`互动空间 ${spaceId} 已保存到世界书，角色: ${characterName}`);
                    } else {
                        console.warn(`互动空间 ${spaceId} 保存到世界书失败，角色: ${characterName}`);
                    }
                } catch (error) {
                    console.error('保存互动空间到世界书时出错:', error);
                }
            }
            
            /**
             * 从世界书加载互动空间数据
             * @param {string} characterName - 角色名称
             */
            function QQ_LoadInteractiveSpaceFromWorldBook(characterName) {
                try {
                    const storageKey = `QQ_互动空间备份_${characterName}`;
                    const savedData = getWorldInfoData(storageKey);
                    
                    if (savedData && savedData.spaces) {
                        Object.keys(savedData.spaces).forEach(spaceId => {
                            const spaceData = savedData.spaces[spaceId];
                            if (spaceData.pages && spaceData.pages.length > 0) {
                                QQ_InteractivePages[spaceId] = spaceData.pages;
                                QQ_InteractiveCurrentPage[spaceId] = spaceData.currentPage || 0;
                            }
                        });
                        
                        console.log(`已从世界书加载角色 ${characterName} 的互动空间数据`);
                        return true;
                    }
                } catch (error) {
                    console.error('从世界书加载互动空间数据时出错:', error);
                }
                return false;
            }
            
            // ===== 精灵按钮系统 =====
            
            /**
             * 显示精灵按钮
             */
            function QQ_ShowSpiritButton() {
                // 如果已经显示，则不重复创建
                if ($('.QQ_spirit_button').length > 0) return;
                
                QQ_SpiritVisible = true;
                
                // 获取上次保存的位置
                const savedPosition = localStorage.getItem('QQ_spirit_position');
                let position = { right: '20px', bottom: '100px' };
                if (savedPosition) {
                    try {
                        position = JSON.parse(savedPosition);
                    } catch (e) {
                        console.warn('解析精灵位置失败，使用默认位置');
                    }
                }
                
                const spiritHtml = `
                    <div class="QQ_spirit_button" style="
                        position: fixed;
                        ${position.right ? `right: ${position.right}` : `left: ${position.left}`};
                        ${position.bottom ? `bottom: ${position.bottom}` : `top: ${position.top}`};
                        width: 60px;
                        height: 60px;
                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                        border-radius: 50%;
                        box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4);
                        cursor: move;
                        z-index: 9999;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        color: white;
                        font-size: 24px;
                        user-select: none;
                        transition: all 0.3s ease;
                        animation: spiritPulse 2s infinite;
                    " title="互动空间精灵">
                        🧚‍✨
                    </div>
                                <style>
                @keyframes spiritPulse {
                    0%, 100% { transform: scale(1); box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4); }
                    50% { transform: scale(1.05); box-shadow: 0 6px 25px rgba(102, 126, 234, 0.6); }
                }
                .QQ_spirit_button:hover {
                    transform: scale(1.1) !important;
                    box-shadow: 0 6px 25px rgba(102, 126, 234, 0.7) !important;
                }
                
                /* 用户菜单动画 */
                @keyframes menuSlideDown {
                    from { 
                        opacity: 0; 
                        transform: translateY(-10px); 
                    }
                    to { 
                        opacity: 1; 
                        transform: translateY(0); 
                    }
                }
                
                #QQ_user_menu {
                    border: 1px solid #e1e5e9;
                }
                
                .user_menu_item:last-child {
                    border-bottom: none !important;
                }
            </style>
                `;
                
                $('body').append(spiritHtml);
                
                // 绑定点击事件（支持触摸设备）
                $('.QQ_spirit_button').on('click touchend', function(e) {
                    // *** 新增：检查是否正在拖拽，如果是则不响应点击 ***
                    if ($(this).hasClass('dragging')) {
                        return;
                    }
                    
                    e.stopPropagation();
                    e.preventDefault();
                    console.log('精灵按钮点击事件触发');
                    QQ_ShowSpiritPanel();
                });
                
                // 绑定拖拽功能
                QQ_MakeSpiritDraggable();
                
                console.log('精灵按钮已显示');
            }
            
            /**
             * 隐藏精灵按钮
             */
            function QQ_HideSpiritButton() {
                $('.QQ_spirit_button').fadeOut(300, function() {
                    $(this).remove();
                });
                QQ_SpiritVisible = false;
                console.log('精灵按钮已隐藏');
            }
            
            /**
             * 使精灵按钮可拖拽
             */
            function QQ_MakeSpiritDraggable() {
                let isDragging = false;
                let dragStarted = false;
                let startX, startY, initialX, initialY;
                let dragTimer;
                
                $('.QQ_spirit_button').on('mousedown touchstart', function(e) {
                    e.preventDefault();
                    dragStarted = false;
                    
                    // 获取初始位置
                    const rect = this.getBoundingClientRect();
                    initialX = rect.left;
                    initialY = rect.top;
                    
                    // 获取鼠标/触摸位置
                    const clientX = e.type === 'touchstart' ? e.originalEvent.touches[0].clientX : e.clientX;
                    const clientY = e.type === 'touchstart' ? e.originalEvent.touches[0].clientY : e.clientY;
                    
                    startX = clientX - initialX;
                    startY = clientY - initialY;
                    
                    // *** 新增：延迟开始拖拽，允许点击事件 ***
                    dragTimer = setTimeout(() => {
                        isDragging = true;
                        dragStarted = true;
                        
                        // 改变样式
                        $('.QQ_spirit_button').addClass('dragging').css({
                            'cursor': 'grabbing',
                            'z-index': '10001',
                            'animation': 'none'
                        });
                        
                        console.log('开始拖拽精灵按钮');
                    }, 150); // 150ms延迟，给点击事件留时间
                });
                
                $(document).on('mousemove touchmove', function(e) {
                    if (!isDragging) return;
                    
                    const clientX = e.type === 'touchmove' ? e.originalEvent.touches[0].clientX : e.clientX;
                    const clientY = e.type === 'touchmove' ? e.originalEvent.touches[0].clientY : e.clientY;
                    
                    const x = clientX - startX;
                    const y = clientY - startY;
                    
                    // 边界检查
                    const maxX = window.innerWidth - 60;
                    const maxY = window.innerHeight - 60;
                    
                    const constrainedX = Math.max(0, Math.min(x, maxX));
                    const constrainedY = Math.max(0, Math.min(y, maxY));
                    
                    $('.QQ_spirit_button').css({
                        'left': constrainedX + 'px',
                        'top': constrainedY + 'px',
                        'right': 'auto',
                        'bottom': 'auto'
                    });
                    
                    e.preventDefault();
                });
                
                $(document).on('mouseup touchend', function(e) {
                    // 清除拖拽定时器
                    if (dragTimer) {
                        clearTimeout(dragTimer);
                        dragTimer = null;
                    }
                    
                    if (!isDragging && !dragStarted) {
                        // 这是一个点击事件，不是拖拽
                        console.log('精灵按钮被点击（非拖拽）');
                        return;
                    }
                    
                    if (!isDragging) return;
                    isDragging = false;
                    dragStarted = false;
                    
                    // 恢复样式
                    $('.QQ_spirit_button').removeClass('dragging').css({
                        'cursor': 'move',
                        'z-index': '9999',
                        'animation': 'spiritPulse 2s infinite'
                    });
                    
                    // 保存位置
                    const spirit = $('.QQ_spirit_button');
                    if (spirit.length > 0) {
                        const position = {
                            left: spirit.css('left'),
                            top: spirit.css('top')
                        };
                        localStorage.setItem('QQ_spirit_position', JSON.stringify(position));
                        console.log('精灵按钮位置已保存');
                    }
                });
            }
            
            /**
             * 显示精灵控制面板
             */
            function QQ_ShowSpiritPanel() {
                // 移除现有面板
                $('.QQ_spirit_panel').remove();
                
                const spaces = Object.values(QQ_InteractiveSpaces);
                const hasSpaces = spaces.length > 0;
                
                let spaceListHtml = '';
                if (hasSpaces) {
                    spaceListHtml = spaces.map(space => `
                        <div class="spirit_space_item" data-space-id="${space.id}" style="
                            padding: 12px 15px;
                            border-bottom: 1px solid #eee;
                            cursor: pointer;
                            display: flex;
                            align-items: center;
                            gap: 10px;
                            transition: background-color 0.2s ease;
                        " onmouseover="this.style.backgroundColor='#f5f5f5'" 
                           onmouseout="this.style.backgroundColor='transparent'">
                            <img src="${space.characterAvatar}" alt="${space.characterName}" style="
                                width: 32px;
                                height: 32px;
                                border-radius: 50%;
                                object-fit: cover;
                            ">
                            <div style="flex: 1;">
                                <div style="font-size: 14px; font-weight: 500; color: #333;">${space.name}</div>
                                <div style="font-size: 12px; color: #666; margin-top: 2px;">
                                    ${new Date(space.lastAccess).toLocaleDateString()} ${new Date(space.lastAccess).toLocaleTimeString().slice(0, 5)}
                                </div>
                            </div>
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="#999">
                                <path d="M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"/>
                            </svg>
                        </div>
                    `).join('');
                } else {
                    spaceListHtml = `
                        <div style="
                            padding: 30px 20px;
                            text-align: center;
                            color: #999;
                            font-size: 14px;
                        ">
                            <div style="font-size: 48px; margin-bottom: 10px;">🌟</div>
                            暂无互动空间<br>
                            <small>与AI的互动内容会自动保存到这里</small>
                        </div>
                    `;
                }
                
                const panelHtml = `
                    <div class="QQ_spirit_panel" style="
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        width: 320px;
                        max-height: 500px;
                        background: white;
                        border-radius: 15px;
                        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
                        z-index: 10000;
                        animation: spiritPanelShow 0.3s ease;
                        overflow: hidden;
                    ">
                        <div class="spirit_panel_header" style="
                            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                            color: white;
                            padding: 20px;
                            text-align: center;
                            position: relative;
                        ">
                            <h3 style="margin: 0; font-size: 18px; font-weight: 600;">🧚‍✨ 互动空间</h3>
                            <p style="margin: 5px 0 0 0; font-size: 13px; opacity: 0.9;">管理你的所有现实互动</p>
                            <button class="spirit_panel_close" style="
                                position: absolute;
                                top: 15px;
                                right: 15px;
                                background: rgba(255, 255, 255, 0.2);
                                border: none;
                                color: white;
                                width: 28px;
                                height: 28px;
                                border-radius: 50%;
                                cursor: pointer;
                                font-size: 16px;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                            ">×</button>
                        </div>
                        <div class="spirit_panel_body" style="
                            max-height: 350px;
                            overflow-y: auto;
                        ">
                            ${spaceListHtml}
                        </div>
                        <div class="spirit_panel_footer" style="
                            padding: 15px 20px;
                            background: #f8f9fa;
                            border-top: 1px solid #eee;
                            display: flex;
                            gap: 10px;
                        ">
                            <button class="spirit_hide_btn" style="
                                flex: 1;
                                background: #6c757d;
                                border: none;
                                color: white;
                                padding: 10px;
                                border-radius: 8px;
                                cursor: pointer;
                                font-size: 13px;
                                transition: background-color 0.2s ease;
                            " onmouseover="this.style.backgroundColor='#5a6268'" 
                               onmouseout="this.style.backgroundColor='#6c757d'">
                                隐藏精灵
                            </button>
                            <button class="spirit_stats_btn" style="
                                flex: 1;
                                background: #28a745;
                                border: none;
                                color: white;
                                padding: 10px;
                                border-radius: 8px;
                                cursor: pointer;
                                font-size: 13px;
                                transition: background-color 0.2s ease;
                            " onmouseover="this.style.backgroundColor='#218838'" 
                               onmouseout="this.style.backgroundColor='#28a745'">
                                查看统计
                            </button>
                        </div>
                    </div>
                    <div class="QQ_spirit_panel_overlay" style="
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0, 0, 0, 0.5);
                        z-index: 9999;
                        animation: fadeIn 0.3s ease;
                    "></div>
                    <style>
                        @keyframes spiritPanelShow {
                            from { transform: translate(-50%, -50%) scale(0.9); opacity: 0; }
                            to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
                        }
                    </style>
                `;
                
                $('body').append(panelHtml);
                
                // 绑定事件
                $('.spirit_panel_close, .QQ_spirit_panel_overlay').on('click', function() {
                    QQ_CloseSpiritPanel();
                });
                
                $('.spirit_hide_btn').on('click', function() {
                    QQ_CloseSpiritPanel();
                    QQ_HideSpiritButton();
                });
                
                $('.spirit_stats_btn').on('click', function() {
                    QQ_ShowInteractiveStats();
                });
                
                $('.spirit_space_item').on('click', function() {
                    const spaceId = $(this).data('space-id');
                    QQ_OpenInteractiveSpace(spaceId);
                });
                
                // 阻止点击面板本身时关闭
                $('.QQ_spirit_panel').on('click', function(e) {
                    e.stopPropagation();
                });
            }
            
            /**
             * 关闭精灵控制面板
             */
            function QQ_CloseSpiritPanel() {
                $('.QQ_spirit_panel, .QQ_spirit_panel_overlay').fadeOut(300, function() {
                    $(this).remove();
                });
            }
            
            /**
             * 打开指定的互动空间
             * @param {string} spaceId - 空间ID
             */
            function QQ_OpenInteractiveSpace(spaceId) {
                const space = QQ_InteractiveSpaces[spaceId];
                if (!space) {
                    triggerSlash('/echo severity=error 互动空间不存在或已被删除');
                    return;
                }
                
                // 更新最后访问时间
                space.lastAccess = new Date().toISOString();
                QQ_SaveInteractiveSpaces();
                
                // 关闭精灵面板
                QQ_CloseSpiritPanel();
                
                // 重新显示互动空间
                QQ_ShowStoredInteractiveSpace(space);
            }
            
            /**
             * 显示已保存的互动空间
             * @param {Object} space - 空间数据
             */
            function QQ_ShowStoredInteractiveSpace(space) {
                // 设置当前活动空间
                QQ_ActiveSpaceId = space.id;
                
                // 移除现有的互动空间
                $('.QQ_interactive_space').remove();
                
                // 创建互动空间HTML
                const interactiveSpaceHtml = `
                    <div class="QQ_interactive_space" data-space-id="${space.id}" style="
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0, 0, 0, 0.7);
                        z-index: 10000;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        animation: fadeIn 0.3s ease;
                        backdrop-filter: blur(10px);
                    ">
                        <div class="QQ_interactive_content" style="
                            background: #ffffff;
                            border-radius: 15px;
                            padding: 0;
                            max-width: 85%;
                            max-height: 75%;
                            overflow: hidden;
                            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
                            position: relative;
                            color: #333;
                            animation: slideIn 0.3s ease;
                            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                        ">
                            <div class="QQ_interactive_header" style="
                                background: linear-gradient(135deg, #4FC3F7 0%, #29B6F6 100%);
                                padding: 20px;
                                display: flex;
                                align-items: center;
                                color: white;
                                position: relative;
                            ">
                                <img src="${space.characterAvatar}" alt="${space.characterName}" style="
                                    width: 45px;
                                    height: 45px;
                                    border-radius: 50%;
                                    margin-right: 15px;
                                    border: 3px solid white;
                                    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
                                ">
                                <div style="flex: 1;">
                                    <h3 style="margin: 0; font-size: 17px; font-weight: 600;">${space.name}</h3>
                                    <p style="margin: 3px 0 0 0; font-size: 13px; opacity: 0.9;">现实互动模式</p>
                                </div>
                                <button class="QQ_rename_space" style="
                                    background: rgba(255, 255, 255, 0.2);
                                    border: none;
                                    color: white;
                                    width: 32px;
                                    height: 32px;
                                    border-radius: 50%;
                                    cursor: pointer;
                                    font-size: 14px;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    transition: all 0.3s ease;
                                    margin-right: 8px;
                                " onmouseover="this.style.background='rgba(255, 255, 255, 0.3)'" 
                                   onmouseout="this.style.background='rgba(255, 255, 255, 0.2)'"
                                   title="重命名空间">
                                    ✏️
                                </button>
                                <button class="QQ_delete_space" style="
                                    background: rgba(255, 255, 255, 0.2);
                                    border: none;
                                    color: white;
                                    width: 32px;
                                    height: 32px;
                                    border-radius: 50%;
                                    cursor: pointer;
                                    font-size: 16px;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    transition: all 0.3s ease;
                                    margin-right: 8px;
                                " onmouseover="this.style.background='rgba(255, 87, 87, 0.3)'" 
                                   onmouseout="this.style.background='rgba(255, 255, 255, 0.2)'"
                                   title="删除空间">
                                    🗑️
                                </button>
                                <button class="QQ_close_interactive" style="
                                    background: rgba(255, 255, 255, 0.2);
                                    border: none;
                                    color: white;
                                    width: 32px;
                                    height: 32px;
                                    border-radius: 50%;
                                    cursor: pointer;
                                    font-size: 18px;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    transition: all 0.3s ease;
                                " onmouseover="this.style.background='rgba(255, 255, 255, 0.3)'" 
                                   onmouseout="this.style.background='rgba(255, 255, 255, 0.2)'">
                                    ×
                                </button>
                            </div>
                            <div class="QQ_interactive_body" style="
                                padding: 25px 20px;
                                font-size: 15px;
                                line-height: 1.5;
                                white-space: pre-wrap;
                                color: #333;
                                background: #fafafa;
                                max-height: 300px;
                                overflow-y: auto;
                            ">${space.content}</div>
                            <div class="QQ_interactive_footer" style="
                                padding: 20px;
                                background: #ffffff;
                                border-top: 1px solid #eee;
                                display: flex;
                                justify-content: center;
                                gap: 15px;
                            ">
                                <button class="QQ_reply_interactive" style="
                                    background: #4FC3F7;
                                    border: none;
                                    color: white;
                                    padding: 12px 24px;
                                    border-radius: 25px;
                                    cursor: pointer;
                                    font-size: 14px;
                                    font-weight: 500;
                                    transition: all 0.3s ease;
                                    box-shadow: 0 2px 8px rgba(79, 195, 247, 0.3);
                                " onmouseover="this.style.background='#29B6F6'; this.style.transform='translateY(-1px)'" 
                                   onmouseout="this.style.background='#4FC3F7'; this.style.transform='translateY(0)'">
                                    💬 回应互动
                                </button>
                                <button class="QQ_close_interactive" style="
                                    background: #f5f5f5;
                                    border: none;
                                    color: #666;
                                    padding: 12px 24px;
                                    border-radius: 25px;
                                    cursor: pointer;
                                    font-size: 14px;
                                    font-weight: 500;
                                    transition: all 0.3s ease;
                                " onmouseover="this.style.background='#eeeeee'" 
                                   onmouseout="this.style.background='#f5f5f5'">
                                    关闭
                                </button>
                            </div>
                        </div>
                    </div>
                `;
                
                // 添加到页面
                $('body').append(interactiveSpaceHtml);
                
                // 绑定事件
                $('.QQ_rename_space').off('click').on('click', function() {
                    QQ_RenameInteractiveSpace(space.id);
                });
                
                $('.QQ_delete_space').off('click').on('click', function() {
                    QQ_DeleteInteractiveSpace(space.id);
                });
                
                $('.QQ_close_interactive').off('click').on('click', function() {
                    QQ_CloseInteractiveSpace();
                });
                
                $('.QQ_reply_interactive').off('click').on('click', function() {
                    QQ_CloseInteractiveSpace();
                    QQ_OpenInteractiveReply(space.characterName);
                });
                
                $('.QQ_interactive_space').on('click', function(e) {
                    if (e.target === this) {
                        QQ_CloseInteractiveSpace();
                    }
                });
                
                triggerSlash(`/echo 已打开互动空间：${space.name}`);
            }
            
            /**
             * 删除互动空间
             * @param {string} spaceId - 空间ID
             */
            function QQ_DeleteInteractiveSpace(spaceId) {
                const space = QQ_InteractiveSpaces[spaceId];
                if (!space) return;
                
                if (confirm(`确定要删除互动空间"${space.name}"吗？此操作无法撤销。`)) {
                    delete QQ_InteractiveSpaces[spaceId];
                    QQ_SaveInteractiveSpaces();
                    QQ_CloseInteractiveSpace();
                    triggerSlash(`/echo 互动空间"${space.name}"已删除`);
                }
            }
            
            /**
             * 显示互动空间统计信息
             */
            function QQ_ShowInteractiveStats() {
                const spaces = Object.values(QQ_InteractiveSpaces);
                const totalSpaces = spaces.length;
                const characters = [...new Set(spaces.map(s => s.characterName))];
                const totalCharacters = characters.length;
                
                // 按角色统计
                const characterStats = {};
                spaces.forEach(space => {
                    const char = space.characterName;
                    if (!characterStats[char]) {
                        characterStats[char] = { count: 0, lastInteraction: space.lastAccess };
                    }
                    characterStats[char].count++;
                    if (new Date(space.lastAccess) > new Date(characterStats[char].lastInteraction)) {
                        characterStats[char].lastInteraction = space.lastAccess;
                    }
                });
                
                // 最近的互动
                const recentSpaces = spaces
                    .sort((a, b) => new Date(b.lastAccess) - new Date(a.lastAccess))
                    .slice(0, 5);
                
                let statsHtml = `
                    📊 互动空间统计信息
                    
                    总互动空间: ${totalSpaces}个
                    涉及角色: ${totalCharacters}个
                    
                    📈 角色互动统计:
                    ${Object.entries(characterStats)
                        .sort((a, b) => b[1].count - a[1].count)
                        .map(([char, stats]) => `• ${char}: ${stats.count}次`)
                        .join('\n')
                    }
                    
                    🕒 最近互动:
                    ${recentSpaces.map(space => 
                        `• ${space.name} (${new Date(space.lastAccess).toLocaleDateString()})`
                    ).join('\n')}
                    
                    💾 数据保存位置: 世界书
                    🔄 最后同步: ${new Date().toLocaleString()}
                `;
                
                triggerSlash(`/echo ${statsHtml}`);
                QQ_CloseSpiritPanel();
            }
            
            // ===== 用户菜单系统 =====
            
            /**
             * 切换用户菜单显示/隐藏
             */
            function QQ_ToggleUserMenu() {
                const menu = $('#QQ_user_menu');
                if (menu.is(':visible')) {
                    QQ_HideUserMenu();
                } else {
                    QQ_ShowUserMenu();
                }
            }
            
            /**
             * 显示用户菜单
             */
            function QQ_ShowUserMenu() {
                // 隐藏其他菜单
                $('.dropdown-menu, .context-menu').hide();
                
                $('#QQ_user_menu').fadeIn(200);
                
                // 点击其他地方关闭菜单
                $(document).one('click', function(e) {
                    if (!$(e.target).closest('#QQ_user_menu, #QQ_home_UserName').length) {
                        QQ_HideUserMenu();
                    }
                });
            }
            
            /**
             * 隐藏用户菜单
             */
            function QQ_HideUserMenu() {
                $('#QQ_user_menu').fadeOut(150);
            }
            
            // ===== 全局调试工具 =====
            
            /**
             * 显示互动空间详细统计（调试用）
             */
            window.QQ_Show_Interactive_Stats = function() {
                const spaces = Object.values(QQ_InteractiveSpaces);
                console.log('=== 互动空间详细统计 ===');
                console.log('总空间数量:', spaces.length);
                console.log('精灵按钮可见:', QQ_SpiritVisible);
                console.log('当前活动空间:', QQ_ActiveSpaceId);
                console.log('所有空间数据:', QQ_InteractiveSpaces);
                
                if (worldbook) {
                    // 使用异步方式获取条目
                    getLorebookEntries(worldbook).then(entries => {
                        if (entries) {
                            const entry = entries.find(e => e.comment === QQ_INTERACTIVE_BACKUP_KEY);
                            console.log('世界书备份条目:', entry ? '存在' : '不存在');
                            if (entry) {
                                console.log('备份内容长度:', entry.content.length);
                                try {
                                    const data = JSON.parse(entry.content);
                                    console.log('备份版本:', data.version);
                                    console.log('最后更新:', data.lastUpdated);
                                    console.log('备份空间数量:', Object.keys(data.spaces || {}).length);
                                } catch (e) {
                                    console.error('解析备份数据失败:', e);
                                }
                            }
                        } else {
                            console.warn('无法获取世界书条目');
                        }
                    }).catch(error => {
                        console.error('获取世界书条目失败:', error);
                    });
                } else {
                    console.warn('世界书未初始化');
                }
                
                // 检查精灵按钮状态
                const spiritButton = $('.QQ_spirit_button');
                console.log('精灵按钮DOM存在:', spiritButton.length > 0);
                if (spiritButton.length > 0) {
                    console.log('精灵按钮位置:', {
                        left: spiritButton.css('left'),
                        top: spiritButton.css('top'),
                        right: spiritButton.css('right'),
                        bottom: spiritButton.css('bottom')
                    });
                }
                
                const savedPosition = localStorage.getItem('QQ_spirit_position');
                console.log('保存的精灵位置:', savedPosition);
                
                triggerSlash('/echo 📊 互动空间调试信息已输出到控制台');
            };
            
            // ===== 页面初始化处理 =====
            
            /**
             * 初始化互动空间系统
             */
            async function QQ_InitInteractiveSystem() {
                try {
                    // 加载互动空间数据
                    await QQ_LoadInteractiveSpaces();
                    await QQ_LoadCharacterSpaces();
                    
                    // 添加CSS样式
                    if (!$('#QQ_interactive_styles').length) {
                        $('head').append(`
                            <style id="QQ_interactive_styles">
                                @keyframes menuSlideDown {
                                    from { 
                                        opacity: 0; 
                                        transform: translateY(-10px); 
                                    }
                                    to { 
                                        opacity: 1; 
                                        transform: translateY(0); 
                                    }
                                }
                                
                                .user_menu_item:last-child {
                                    border-bottom: none !important;
                                }
                                
                                /* 精灵按钮在移动设备上的优化 */
                                @media (max-width: 768px) {
                                    .QQ_spirit_button {
                                        width: 50px !important;
                                        height: 50px !important;
                                        font-size: 20px !important;
                                    }
                                }
                                
                                /* 互动空间在移动设备上的优化 */
                                @media (max-width: 768px) {
                                    .QQ_interactive_content {
                                        max-width: 95% !important;
                                        max-height: 85% !important;
                                    }
                                    
                                    .QQ_spirit_panel {
                                        width: 300px !important;
                                        max-height: 400px !important;
                                    }
                                }
                            </style>
                        `);
                    }
                    
                    console.log('✅ 互动空间系统初始化完成');
                } catch (error) {
                    console.error('❌ 互动空间系统初始化失败:', error);
                }
            }

            /**
             * 打开互动回应界面
             * @param {string} characterName - 角色名称
             */
            function QQ_OpenInteractiveReply(characterName) {
                // 创建更优雅的输入界面
                const inputHtml = `
                    <div class="QQ_reply_input_overlay" style="
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0, 0, 0, 0.5);
                        z-index: 10001;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        animation: fadeIn 0.3s ease;
                    ">
                        <div style="
                            background: white;
                            border-radius: 15px;
                            padding: 25px;
                            max-width: 80%;
                            width: 400px;
                            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
                            animation: slideIn 0.3s ease;
                        ">
                            <h3 style="margin: 0 0 15px 0; color: #333; text-align: center;">回应 ${characterName} 的互动</h3>
                            <textarea id="reply_input" placeholder="输入你的回应..." style="
                                width: 100%;
                                height: 100px;
                                border: 2px solid #e0e0e0;
                                border-radius: 10px;
                                padding: 12px;
                                font-size: 14px;
                                resize: vertical;
                                box-sizing: border-box;
                                font-family: inherit;
                            "></textarea>
                            <div style="display: flex; justify-content: center; gap: 15px; margin-top: 20px;">
                                <button id="send_reply" style="
                                    background: #4FC3F7;
                                    border: none;
                                    color: white;
                                    padding: 10px 20px;
                                    border-radius: 20px;
                                    cursor: pointer;
                                    font-size: 14px;
                                    font-weight: 500;
                                ">发送回应</button>
                                <button id="cancel_reply" style="
                                    background: #f5f5f5;
                                    border: none;
                                    color: #666;
                                    padding: 10px 20px;
                                    border-radius: 20px;
                                    cursor: pointer;
                                    font-size: 14px;
                                    font-weight: 500;
                                ">取消</button>
                            </div>
                        </div>
                    </div>
                `;
                
                $('body').append(inputHtml);
                
                // 聚焦输入框
                setTimeout(() => $('#reply_input').focus(), 100);
                
                // 绑定事件
                $('#send_reply').on('click', function() {
                    const replyText = $('#reply_input').val().trim();
                    if (replyText) {
                        const interactiveReply = `回应互动: ${replyText}`;
                        QQ_SendMessage(interactiveReply, characterName);
                        $('.QQ_reply_input_overlay').fadeOut(300, function() {
                            $(this).remove();
                        });
                    } else {
                        $('#reply_input').focus();
                    }
                });
                
                $('#cancel_reply').on('click', function() {
                    $('.QQ_reply_input_overlay').fadeOut(300, function() {
                        $(this).remove();
                    });
                });
                
                // 点击背景关闭
                $('.QQ_reply_input_overlay').on('click', function(e) {
                    if (e.target === this) {
                        $(this).fadeOut(300, function() {
                            $(this).remove();
                        });
                    }
                });
                
                // 回车发送
                $('#reply_input').on('keydown', function(e) {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        $('#send_reply').click();
                    }
                });
            }

            /**
             * 发送消息到指定角色
             * @param {string} message - 消息内容
             * @param {string} targetName - 目标角色名称
             */
            function QQ_SendMessage(message, targetName = "") {
                // 设置全局发送变量
                SendValue = message;
                SendName = targetName;
                
                // 调用现有的发送机制
                console.log(`发送互动回应消息: ${message} -> ${targetName}`);
                
                // 如果在聊天页面，直接发送
                if (typeof QQ_Send === 'function') {
                    QQ_Send();
                } else {
                    // 否则通过triggerSlash发送
                    if (targetName) {
                        triggerSlash(`/sendas name={{char}} 收到来自${UserName}的互动回应: ${message}`);
                    } else {
                        triggerSlash(`/sendas name={{char}} 收到互动回应: ${message}`);
                    }
                }
                
                // 清理发送变量
                SendValue = "";
                SendName = "";
            }

            
            // ===== 用户菜单控制函数 =====
            
            /**
             * 切换用户菜单显示状态
             */
            function QQ_ToggleUserMenu() {
                const menu = $('#QQ_user_menu');
                if (menu.is(':visible')) {
                    QQ_HideUserMenu();
                } else {
                    QQ_ShowUserMenu();
                }
            }
            
            /**
             * 显示用户菜单
             */
            function QQ_ShowUserMenu() {
                const menu = $('#QQ_user_menu');
                if (menu.length === 0) return;
                
                // 隐藏其他菜单
                $('.dropdown-menu, .context-menu, .QQ_spirit_panel').hide();
                
                // 显示菜单
                menu.show();
                
                // 绑定点击外部关闭事件
                setTimeout(() => {
                    $(document).on('click.user-menu', function(e) {
                        if (!menu.is(e.target) && menu.has(e.target).length === 0 && !$('#QQ_home_UserName').is(e.target)) {
                            QQ_HideUserMenu();
                        }
                    });
                }, 100);
            }
            
            /**
             * 隐藏用户菜单
             */
            function QQ_HideUserMenu() {
                $('#QQ_user_menu').hide();
                $(document).off('click.user-menu');
            }
            
            // ===== 互动空间调试工具 =====
            
            /**
             * 显示互动空间调试统计信息（全局函数）
             */
            window.QQ_Show_Interactive_Stats = function() {
                const spaces = Object.values(QQ_InteractiveSpaces);
                const spiritVisible = QQ_SpiritVisible;
                const activeSpace = QQ_ActiveSpaceId;
                
                let report = `
🧚‍✨ 互动空间系统状态报告
========================

📊 基础统计:
• 总空间数: ${spaces.length}
• 精灵状态: ${spiritVisible ? '显示' : '隐藏'}
• 活动空间: ${activeSpace || '无'}

📝 空间详情:`;
                
                if (spaces.length > 0) {
                    spaces.forEach((space, index) => {
                        const lastAccess = new Date(space.lastAccess).toLocaleString();
                        report += `
${index + 1}. ${space.name}
   ID: ${space.id}
   角色: ${space.characterName}
   创建: ${new Date(space.createdAt).toLocaleString()}
   最后访问: ${lastAccess}
   内容长度: ${space.content.length} 字符`;
                    });
                } else {
                    report += `
   暂无互动空间数据`;
                }
                
                report += `

💾 存储信息:
• 备份键: ${QQ_INTERACTIVE_BACKUP_KEY}
• 世界书状态: ${worldbook ? '已加载' : '未加载'}

🔧 可用命令:
• window.QQ_Show_Interactive_Stats() - 显示此统计
• QQ_ShowSpiritButton() - 显示精灵按钮
• QQ_HideSpiritButton() - 隐藏精灵按钮
• QQ_LoadInteractiveSpaces() - 重新加载空间数据
• QQ_SaveInteractiveSpaces() - 手动保存空间数据
`;
                
                console.log(report);
                triggerSlash(`/echo 📊 互动空间统计：${spaces.length}个空间，精灵${spiritVisible ? '显示' : '隐藏'}中`);
                return {
                    totalSpaces: spaces.length,
                    spiritVisible,
                    activeSpace,
                    spaces: spaces.map(s => ({
                        id: s.id,
                        name: s.name,
                        character: s.characterName,
                        created: s.createdAt,
                        lastAccess: s.lastAccess
                    }))
                };
            };
            
            /**
             * *** 新增：用户名下拉菜单功能 ***
             */
            function QQ_ToggleUserMenu() {
                console.log('点击用户名，显示下拉菜单');
                
                // 检查是否已存在菜单
                let existingMenu = document.getElementById('QQ_user_dropdown_menu');
                if (existingMenu) {
                    existingMenu.remove();
                    return;
                }
                
                // 创建下拉菜单
                const menu = document.createElement('div');
                menu.id = 'QQ_user_dropdown_menu';
                menu.style.cssText = `
                    position: fixed;
                    top: 70px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: white;
                    border: 1px solid #ddd;
                    border-radius: 8px;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                    z-index: 10000;
                    min-width: 200px;
                    overflow: hidden;
                `;
                
                // 获取当前用户名
                const currentUserName = document.getElementById('QQ_message_list_UserName').textContent.replace(/\*\*/g, '');
                
                // 菜单项数据
                const menuItems = [
                    {
                        icon: '👤',
                        text: '修改昵称',
                        action: () => QQ_ChangeUserName()
                    },
                    {
                        icon: '💫',
                        text: '互动使用指南',
                        action: () => QQ_ShowInteractiveGuide()
                    },
                    {
                        icon: '📱',
                        text: '手机状态',
                        action: () => QQ_ShowPhoneStatus()
                    },
                    {
                        icon: '🔄',
                        text: '同步数据',
                        action: () => QQ_SyncAllData()
                    },
                    {
                        icon: '📋',
                        text: '数据管理',
                        action: () => QQ_ShowDataManagement()
                    },
                    {
                        icon: '🧹',
                        text: '清理缓存',
                        action: () => QQ_ClearCache()
                    }
                ];
                
                // 添加菜单项
                menuItems.forEach((item, index) => {
                    const menuItem = document.createElement('div');
                    menuItem.style.cssText = `
                        padding: 12px 16px;
                        display: flex;
                        align-items: center;
                        cursor: pointer;
                        border-bottom: ${index < menuItems.length - 1 ? '1px solid #f0f0f0' : 'none'};
                        transition: background-color 0.2s;
                    `;
                    
                    menuItem.innerHTML = `
                        <span style="margin-right: 12px; font-size: 16px;">${item.icon}</span>
                        <span style="color: #333; font-size: 14px;">${item.text}</span>
                    `;
                    
                    menuItem.addEventListener('mouseover', () => {
                        menuItem.style.backgroundColor = '#f5f5f5';
                    });
                    
                    menuItem.addEventListener('mouseout', () => {
                        menuItem.style.backgroundColor = 'transparent';
                    });
                    
                    menuItem.addEventListener('click', () => {
                        menu.remove();
                        item.action();
                    });
                    
                    menu.appendChild(menuItem);
                });
                
                // 添加到页面
                document.body.appendChild(menu);
                
                // 点击其他地方关闭菜单
                setTimeout(() => {
                    document.addEventListener('click', function closeMenu(e) {
                        if (!menu.contains(e.target)) {
                            menu.remove();
                            document.removeEventListener('click', closeMenu);
                        }
                    });
                }, 100);
            }

            /**
             * *** 新增：显示互动使用指南 ***
             */
            function QQ_ShowInteractiveGuide() {
                const guideContent = `
🎯 互动功能使用指南

【主动触发互动】
使用特殊符号 && 直接触发互动内容：

✨ 使用方法：
• "&&想要拥抱你" 
• "抱抱你&&"  
• "我想&&和你一起散步"

🎪 效果：AI会直接生成互动场景，跳过普通聊天

【互动模式】
系统检测关键词自动触发：

💫 关键词类型：
• 身体接触：拥抱、亲吻、触摸、牵手
• 面对面交流：面对面、走近、坐下
• 情感表达：脸红、微笑、哭泣
• 动作描述：*动作*、【情感】

🏠 互动空间：
• 点击私聊角色名称可查看角色专属精灵
• 精灵可管理该角色的所有互动记录
• 支持创建新互动和查看历史记录

💡 小贴士：
• 主动符号触发更精准
• 互动模式在关键时刻激活
• 所有互动内容保存在世界书中
                `.trim();
                
                alert(guideContent);
                console.log('显示互动使用指南');
            }
            
            /**
             * *** 新增：修改用户昵称 ***
             */
            function QQ_ChangeUserName() {
                const currentName = document.getElementById('QQ_message_list_UserName').textContent.replace(/\*\*/g, '');
                const newName = prompt('请输入新的昵称:', currentName);
                
                if (newName && newName.trim() && newName.trim() !== currentName) {
                    const finalName = newName.trim();
                    
                    // 更新所有显示的用户名
                    document.getElementById('QQ_message_list_UserName').innerHTML = `<strong>${finalName}</strong>`;
                    document.getElementById('QQ_home_UserName').textContent = finalName;
                    
                    // 保存到世界书
                    QQ_SafeSaveToWorldBook('用户设置', {
                        userName: finalName,
                        updateTime: new Date().toISOString()
                    }, 'QQ_用户设置');
                    
                    console.log(`用户名已更改为: ${finalName}`);
                    triggerSlash(`/echo 用户名已更改为: ${finalName}`);
                }
            }

            /**
             * *** 新增：显示手机状态 ***
             */
            function QQ_ShowPhoneStatus() {
                const stats = {
                    contacts: Object.keys(window.QQ_Contacts || {}).length,
                    groups: Object.keys(window.QQ_Groups || {}).length,
                    messages: Object.keys(window.QQ_MessageHistory || {}).length,
                    moments: Object.keys(window.QQ_MomentData || {}).length,
                    interactiveSpaces: Object.keys(window.QQ_InteractiveSpaces || {}).length
                };
                
                const statusInfo = `
📱 手机状态报告
联系人: ${stats.contacts} 个
群聊: ${stats.groups} 个  
消息记录: ${stats.messages} 条
动态: ${stats.moments} 条
互动空间: ${stats.interactiveSpaces} 个

🔋 系统状态: 正常
📶 网络状态: 已连接
💾 数据同步: 世界书
                `.trim();
                
                alert(statusInfo);
                console.log('手机状态:', stats);
            }

            /**
             * *** 新增：同步所有数据 ***
             */
            function QQ_SyncAllData() {
                console.log('🔄 开始同步所有数据到世界书...');
                
                const syncTasks = [
                    () => QQ_SaveAllContactsToWorldBook(),
                    () => QQ_SaveAllGroupsToWorldBook(), 
                    () => QQ_SaveAllMessagesToWorldBook(),
                    () => QQ_SaveAllMomentsToWorldBook(),
                    () => QQ_SaveAllInteractiveSpacesToWorldBook(),
                    () => saveGroupsToStorage() // 保存当前角色的分组数据
                ];
                
                let completed = 0;
                const total = syncTasks.length;
                
                syncTasks.forEach((task, index) => {
                    setTimeout(() => {
                        try {
                            task();
                            completed++;
                            console.log(`✅ 同步任务 ${index + 1}/${total} 完成`);
                            
                            if (completed === total) {
                                triggerSlash(`/echo 所有数据已同步到世界书 (${total}/${total})`);
                                console.log('🎉 所有数据同步完成！');
                            }
                        } catch (error) {
                            console.error(`❌ 同步任务 ${index + 1} 失败:`, error);
                        }
                    }, index * 500); // 间隔500ms执行，避免并发问题
                });
                
                triggerSlash(`/echo 正在同步数据到世界书... (0/${total})`);
            }

            /**
             * *** 新增：显示数据管理界面 ***
             */
            function QQ_ShowDataManagement() {
                console.log('显示数据管理界面');
                alert('数据管理功能开发中...\n\n当前支持:\n• 所有数据保存在世界书中\n• 联系人分组管理\n• 互动空间管理\n• 消息记录管理');
            }

            /**
             * *** 新增：清理缓存 ***
             */
            function QQ_ClearCache() {
                if (confirm('确定要清理缓存吗？这将清除临时数据但保留世界书中的重要数据。')) {
                    // 清理前端缓存
                    window.QQ_Cache = {};
                    window.QQ_TempData = {};
                    
                    // 清理一些临时DOM缓存
                    $('.QQ_temp_cache').remove();
                    
                    console.log('缓存已清理');
                    triggerSlash('/echo 缓存已清理，重要数据保留在世界书中');
                }
            }

            // *** 新增：互动检测测试工具 - 优化版 ***
            window.QQ_Test_Interactive_Detection = function(text) {
                if (text) {
                    // 测试单个文本
                    const result = QQ_DetectInteractiveIntent(text);
                    
                    let details = `
=== 互动意图检测测试 ===
📝 测试文本: "${text}"`;

                    if (result && result.isInteractive) {
                        details += `
🎯 检测结果: ✅ 检测到互动意图
🔧 触发类型: ${result.triggerType === 'symbol' ? '🎯 特殊符号触发' : '💫 关键词触发 (互动模式)'}`;
                        
                        if (result.triggerType === 'symbol') {
                            details += `
🔗 触发符号: ${result.triggerSymbol}
📝 清理后内容: "${result.cleanContent}"
💡 说明: ${result.description}`;
                        } else {
                            details += `
📊 关键词匹配: ${result.matchCount || 0} 个
🎭 模式匹配: ${result.patternMatches || 0} 个
🔍 匹配内容: ${result.matchedKeywords ? result.matchedKeywords.join(', ') : '无'}
💡 说明: ${result.description}`;
                        }
                    } else {
                        details += `
🎯 检测结果: ❌ 未检测到互动意图`;
                    }

                    details += `

💡 使用指南:
🎯 【主动触发】使用特殊符号:
• "&&想要拥抱你" (✅ 符号触发)
• "抱抱你&&" (✅ 符号触发)  
• "我想&&和你一起散步" (✅ 符号触发)

💫 【互动模式】传统关键词:
• 身体接触: 拥抱、亲吻、触摸、牵手等
• 面对面交流: 面对面、当面、走近、坐下等  
• 情感表达: 脸红、害羞、微笑、哭泣等
• 动作描述: *动作*、【情感】等格式
• 需要2个关键词或1个模式匹配才触发

📚 示例测试文本:
• "&&抱抱你" (🎯 符号触发)
• "我想抱抱你" (💫 身体接触)
• "*走向你*" (💫 动作模式) 
• "面对面聊天" (💫 面对面+动作)
• "你好吗？" (❌ 普通对话)
                `;
                    console.log(details);
                    alert(details);
                    return result;
                } else {
                    // 运行完整的优化测试套件
                    console.log("🔍 ========== 互动检测优化测试套件 ==========");
                    
                    const testCases = [
                        // 🔬 先回复后互动的测试用例
                        {
                            name: "先私聊回复后互动",
                            content: "先在私聊回复'好的马上来'然后过来拥抱我",
                            expected: "应检测到先回复要求",
                            test: (content) => QQ_CheckPriorReplyRequest(content).shouldReplyFirst
                        },
                        {
                            name: "先群聊回复后互动", 
                            content: "先在群聊说'大家等我一下'然后再过来一起玩游戏",
                            expected: "应检测到先回复要求",
                            test: (content) => QQ_CheckPriorReplyRequest(content).shouldReplyFirst
                        },
                        
                        // 🔬 精确关键词检测的测试用例
                        {
                            name: "无效集体关键词",
                            content: "用户发送了'集体行动'但这只是在讨论概念",
                            expected: "不应触发多人互动",
                            test: (content) => !QQ_DetectMultiCharacterInteraction(content, null)
                        },
                        {
                            name: "有效集体互动",
                            content: "我们一起去公园玩吧，所有人都来",
                            expected: "应触发多人互动",
                            test: (content) => QQ_DetectMultiCharacterInteraction(content, null)
                        },
                        {
                            name: "过去时态无效",
                            content: "我们以前一起玩过游戏",
                            expected: "不应触发多人互动",
                            test: (content) => !QQ_DetectMultiCharacterInteraction(content, null)
                        },
                        {
                            name: "条件句无效",
                            content: "如果我们一起去的话会很有趣",
                            expected: "不应触发多人互动", 
                            test: (content) => !QQ_DetectMultiCharacterInteraction(content, null)
                        },
                        
                        // 🔬 互动内容检测的测试用例
                        {
                            name: "有效互动内容",
                            content: "*走向你* 想要拥抱你",
                            expected: "应检测到互动内容",
                            test: (content) => QQ_IsInteractiveContent(content)
                        },
                        {
                            name: "普通对话",
                            content: "你今天怎么样？工作顺利吗？",
                            expected: "不应检测到互动内容",
                            test: (content) => !QQ_IsInteractiveContent(content)
                        }
                    ];
                    
                    console.log("开始执行测试用例...");
                    
                    let passCount = 0;
                    let failCount = 0;
                    
                    testCases.forEach((testCase, index) => {
                        console.log(`\n--- 测试 ${index + 1}: ${testCase.name} ---`);
                        console.log(`内容: "${testCase.content}"`);
                        console.log(`期望: ${testCase.expected}`);
                        
                        try {
                            const result = testCase.test(testCase.content);
                            if (result) {
                                console.log(`✅ 测试通过`);
                                passCount++;
                            } else {
                                console.log(`❌ 测试失败`);
                                failCount++;
                            }
                        } catch (error) {
                            console.error(`💥 测试执行错误:`, error);
                            failCount++;
                        }
                    });
                    
                    console.log(`\n🏁 ========== 测试结果汇总 ==========`);
                    console.log(`✅ 通过: ${passCount}/${testCases.length}`);
                    console.log(`❌ 失败: ${failCount}/${testCases.length}`);
                    console.log(`📊 成功率: ${Math.round((passCount / testCases.length) * 100)}%`);
                    
                    if (failCount === 0) {
                        console.log(`🎉 所有测试用例都通过了！互动检测系统优化成功！`);
                    } else {
                        console.log(`⚠️ 有 ${failCount} 个测试用例失败，需要进一步优化`);
                    }
                    
                    return { passCount, failCount, total: testCases.length };
                }
            };
            
            function QQ_UpdateNewTips() {
                // 刷新左上角未读信息数字
                let ids = $(".QQ_chat_page")
                    .map(function () {
                        return this; // 直接返回元素的 ID
                    })
                    .get()
                    .filter(Boolean); // 过滤掉空 ID
                for (const id of ids) {
                    if ($(id).css("display") == "none") {
                        continue;
                    }
                    const name = $(id).attr("data-name") ?? "";
                    let TipsCount = QQ_GetChatShowTipsCount(name);
                    console.log(`获取到${name}的左上角数字为:${TipsCount}`);
                    const $Tips = $(`.QQ_chat_page[data-name='${name}']`).find(
                        `.new_tips`,
                    );
                    $Tips.text(TipsCount);
                    if (TipsCount > 0) {
                        $Tips.css("display", "flex");
                        console.log(`显示tips`);
                    } else {
                        $Tips.hide();
                        console.log(`隐藏tips`);
                    }
                }
            }
            /**
             * 导航到指定页面
             */
            function QQ_Nav(page) {
                // 页面切换时不自动检查QQ_Groups（避免重复加载）
                console.log(`导航到页面: ${page}`);
                
                const $message_svg = $("#QQ_message_svg");
                const $people_svg = $("#QQ_people_svg");
                const $moment_svg = $("#QQ_moment_svg");
                $message_svg.css("fill", "#000000");
                $people_svg.css("fill", "#000000");
                $moment_svg.css("fill", "#000000");
                $("#QQ_home_page").hide();
                $("#QQ_space_page").hide();
                $("#QQ_message_list_page").hide();
                
                // 显示底部导航栏
                $(".QQ_bottom_nav").show();
                
                // 更新当前页面状态
                QQ_currentPage = page;
                
                if (page === "message") {
                    $message_svg.css("fill", "#019aff");
                    $("#QQ_message_list_page").css('display','flex');
                    $("#App_QQ").css("background-color", "#eff3ff");
                    // 更新用户名显示
                    const userName = $("#QQ_home_UserName").text();
                    $("#QQ_message_list_UserName").text(userName);
                    // 每次切换到消息页面时都更新列表
                    // 使用setTimeout避免async问题
                    setTimeout(async () => {
                        await QQ_UpdateMessageList();
                    }, 100);
                    // 消息页面只需要显示已加载的群聊，不需要重新初始化
                    // 消息页面只需要更新列表显示，不需要重新加载数据
                    console.log('消息页面显示，更新消息列表');
                } else if (page === "people") {
                    $people_svg.css("fill", "#019aff");
                    $("#QQ_home_page").css('display','flex');
                    $("#App_QQ").css("background-color", "#eff3ff");
                    
                    console.log('切换到联系人页面');
                    
                    // 联系人页面只需要显示已加载的数据，不需要重新加载
                    console.log('联系人页面显示，数据已在初始化时加载');
                    
                    // 联系人页面只需要显示已加载的群聊，不需要重新初始化
                    
                    // 初始化联系人分组功能
                    if (typeof initContactGroups === 'function') {
                        setTimeout(initContactGroups, 200);
                    }
                } else if (page === "moment") {
                    $moment_svg.css("fill", "#019aff");
                    $("#QQ_space_page").show();
                    $("#App_QQ").css("background-color", "#ffffff");
                    QQ_SetNewTips(0);
                    QQ_NewMsg["moment"] = 0;
                    $(".new_tips").hide();
                } else if (page === "chat") {
                    // 处理聊天页面切换
                    console.log('切换到聊天页面');
                    
                    // 隐藏底部导航栏
                    $(".QQ_bottom_nav").hide();
                    
                    // 隐藏所有其他页面
                    $("#QQ_home_page").hide();
                    $("#QQ_space_page").hide();
                    $("#QQ_message_list_page").hide();
                    
                    // 如果是群聊，创建或显示群聊专用页面
                    if (window.currentGroupChat) {
                        console.log('显示群聊页面:', window.currentGroupChat.name, 'ID:', window.currentGroupChat.id);
                        
                        // 隐藏所有现有的聊天页面
                        $(".QQ_chat_page").hide();
                        
                        // 先移除所有现有的群聊页面，确保没有缓存问题
                        $(".group-chat-page").remove();
                        
                        // 创建新的群聊专用页面
                        console.log('创建群聊专用页面:', window.currentGroupChat.name);
                        const groupChatPage = $(`
                            <div data-group-id="${window.currentGroupChat.id}" class="QQ_chat_page group-chat-page" style="width:100%;height:100%;padding-top:0;background-color:white;position:relative;display:none;">
                                <div class="chat-header" style="padding:10px 15px;background-color:white;border-bottom:1px solid #eee;display:flex;align-items:center;">
                                    <div style="cursor:pointer;margin-right:15px;" onclick="QQ_GoHome()">
                                        <svg viewBox="0 0 1024 1024" style="height:20px;width:20px;">
                                            <path d="M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 0 0 0 50.3l450.8 352.1c5.3 4.1 12.9 0.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z" fill="#333"></path>
                                        </svg>
                                    </div>
                                    <div class="group-chat-info" style="flex:1;">
                                        <div class="group-chat-name" style="font-size:16px;font-weight:bold;color:#333;">${window.currentGroupChat.name}</div>
                                        <div class="group-chat-members" style="font-size:12px;color:#666;">群聊 · ${window.currentGroupChat.members.length}人</div>
                                    </div>
                                    <div style="cursor:pointer;" onclick="showGroupManagementMenu(window.currentGroupChat, this)">
                                        <svg viewBox="0 0 1024 1024" style="height:20px;width:20px;">
                                            <path d="M512 256c-35.3 0-64 28.7-64 64s28.7 64 64 64 64-28.7 64-64-28.7-64-64-64zm0 256c-35.3 0-64 28.7-64 64s28.7 64 64 64 64-28.7 64-64-28.7-64-64-64zm0 256c-35.3 0-64 28.7-64 64s28.7 64 64 64 64-28.7 64-64-28.7-64-64-64z" fill="#666"></path>
                                        </svg>
                                    </div>
                                </div>
                                <div class="msgcontent" style="flex:1;overflow-y:auto;padding:10px;background-color:#f5f5f5;height:calc(100vh - 120px);">
                                    <!-- 群聊消息内容 -->
                                </div>
                                <div class="chat-input" style="padding:10px;background-color:white;border-top:1px solid #eee;display:flex;align-items:center;">
                                    <input type="text" placeholder="输入消息..." style="flex:1;padding:8px 12px;border:1px solid #ddd;border-radius:20px;outline:none;">
                                    <button style="margin-left:10px;padding:8px 16px;background:#007AFF;color:white;border:none;border-radius:20px;cursor:pointer;">发送</button>
                                </div>
                            </div>
                        `);
                        
                        // 添加到页面
                        $("#App_QQ").append(groupChatPage);
                        
                        // 显示群聊页面
                        groupChatPage.show();
                        $("#App_QQ").css("background-color", "#ffffff");
                        
                        // 立即加载群聊历史消息
                        console.log('准备加载群聊历史消息:', window.currentGroupChat.id);
                        loadGroupChatHistory(window.currentGroupChat.id);
                        
                    } else {
                        // 普通聊天页面处理
                        const chatPage = $(".QQ_chat_page").not('.group-chat-page');
                        if (chatPage.length > 0) {
                            chatPage.first().show();
                            $("#App_QQ").css("background-color", "#ffffff");
                            console.log('聊天页面已显示');
                        } else {
                            console.error('未找到聊天页面元素');
                            // 如果找不到聊天页面，回退到消息页面
                            QQ_Nav("message");
                            return;
                        }
                    }
                }
            }

            /**
             * 返回首页
             */
            function QQ_GoHome() {
                QQ_HideAllChat();
                
                // 如果当前在群聊中，返回到来源页面
                if (window.currentGroupChat && window.groupChatSourcePage) {
                    const sourcePage = window.groupChatSourcePage;
                    console.log('从群聊返回到来源页面:', sourcePage);
                    
                    // 清除群聊状态
                    window.currentGroupChat = null;
                    window.groupChatSourcePage = null;
                    
                    // 返回到来源页面
                    if (sourcePage === 'messages') {
                        QQ_Nav("message");
                    } else {
                        QQ_Nav("people");
                    }
                    return;
                }
                
                // 根据当前页面状态返回到正确的页面
                if (QQ_currentPage === "message") {
                    // 如果之前在消息页面，返回到消息页面
                    QQ_Nav("message");
                } else if (QQ_currentPage === "moment") {
                    // 如果之前在动态页面，返回到动态页面
                    QQ_Nav("moment");
                } else {
                    // 默认返回到联络人页面
                    QQ_Nav("people");
                }
            }
            /**
             * 错误提示
             * @param content 提示内容
             * @param change 是否更换浏览器
             */
            function QQ_Error(content, change) {
                triggerSlash(`/echo severity=error ${content}`);
                if (change) {
                    triggerSlash(`/echo 请更换浏览器重试`);
                }
            }
            /**
             * 初始化
             */
            async function init() {
                const LorebookSettings = await getLorebookSettings();
                if (
                    LorebookSettings &&
                    LorebookSettings.context_percentage != 100
                ) {
                    console.log(`设置上下文!!!!!!!!!!`);
                    await setLorebookSettings({ context_percentage: 100 });
                }
                Verify();
                UserName =
                    (await triggerSlashWithResult("/pass {{user}}")) ?? "";
                $("#QQ_home_UserName").html(`<strong>${UserName}</strong>`);
                $("#QQ_message_list_UserName").html(`<strong>${UserName}</strong>`);
                charAvatarPath =
                    (await triggerSlashWithResult(
                        "/pass {{charAvatarPath}}",
                    )) ?? "";
                userAvatarPath =
                    (await triggerSlashWithResult(
                        "/pass {{userAvatarPath}}",
                    )) ?? "";
                console.log(`获取到的user头像:${userAvatarPath}`);
                charcardname =
                    (await triggerSlashWithResult("/pass {{char}}")) ?? "";
                console.log(`开始获取世界书配置`);
                try {
                    worldbook = await GetWorldBookName();
                    if (!worldbook) {
                        QQ_Error(`获取世界书失败!!!!`);
                    }
                    console.log(`获取到的世界书名字:${worldbook}`);
                    entries = await getLorebookEntries(worldbook);
                    if (!entries) {
                        QQ_Error(`获取世界书条目失败!!!!`);
                    }
                } catch (e) {
                    QQ_Error(`出现异常:\n${e}`);
                    console.log(`获取世界书出现异常:${e}`);
                }
                Variables = await getVariables();
                if (Variables) {
                    if (Variables.Npc_Settings) {
                        try {
                            Npc_Settings = JSON.parse(Variables.Npc_Settings);
                        } catch {
                            QQ_Error("读取NPC配置失败");
                        }
                    }
                }
                // NpcCssValue = Variables.NpcCssValue ?? "";
                // console.log(`首次读取到的NpcCss:\n${NpcCssValue}`);
                $("<style>")
                    .attr("data-name", "AutoNpc")
                    .text("")
                    .appendTo("head");
                System_UpdateNpcCss();
                let Phone_Entry = GetWorldEntry(
                    ["手机-界面基本设置", "手机界面基本设置"],
                    true,
                );
                if (Phone_Entry) {
                    Phone_Settings.loadText(Phone_Entry.content);
                }
                DelPadding(); // 移除头像和边距
                await WorldBookUpdate();
                await GetSettings();
                await LoadRandomHead();
                await LoadEmoji();
                await LoadChars();
                await MiPhone_Merge();

                // 群聊数据已在LoadChars中加载，无需额外恢复
                
                // *** 新增：初始化时加载已读状态 ***
                console.log('开始加载已读状态...');
                await QQ_LoadReadStatus();
                
                // *** 新增：加载保存的动态内容 ***
                console.log('开始加载动态内容...');
                await QQ_Load_Moments();
                
                // *** 新增：初始化互动空间系统 ***
                console.log('开始初始化互动空间系统...');
                await QQ_InitInteractiveSystem();
                
                console.log('页面初始化完成');
                
                // 为聊天元素绑定点击事件
                console.log('绑定底部导航点击事件');
                $(document).on("click", "#QQ_message_nav", () => {
                    console.log('点击消息导航');
                    QQ_Nav("message");
                });
                $(document).on("click", "#QQ_people_nav", () => {
                    console.log('点击联系人导航');
                    QQ_Nav("people");
                });
                $(document).on("click", "#QQ_moment_nav", () => {
                    console.log('点击动态导航');
                    QQ_Nav("moment");
                });
                $(document).on("click", ".QQ-close-btn", () => QQ_GoHome());
                $(document).on("click", ".QQ_home_usermsg", (e) =>
                    QQ_ChangeChatPage(e),
                );
                $(document).on("click", "#QQ_chat_page_setting", (e) =>
                    QQ_SetChatPageSetting(e),
                );
                $(document).on("click", ".close-setting-btn", () =>
                    closeSettingPopup(),
                );
                
                // *** 新增：动态删除相关事件绑定 ***
                // 点击三个点显示菜单
                $(document).on("click", ".moment_menu_dots", showMomentMenu);
                
                // 点击菜单项
                $(document).on("click", ".moment_menu_item", function(e) {
                    e.stopPropagation();
                    const action = $(this).data('action');
                    const momentId = $(this).data('moment-id');
                    
                    hideMomentMenu();
                    
                    if (action === 'delete') {
                        confirmDeleteMoment(momentId);
                    }
                });
                
                // 点击确认删除对话框按钮
                $(document).on("click", ".moment_dialog_cancel", function() {
                    $('.moment_confirm_dialog').fadeOut(200, function() {
                        $(this).remove();
                    });
                });
                
                $(document).on("click", ".moment_dialog_confirm", async function() {
                    const momentId = $(this).data('moment-id');
                    const success = await QQ_Delete_Moment(momentId);
                    
                    $('.moment_confirm_dialog').fadeOut(200, function() {
                        $(this).remove();
                    });
                    
                    if (success) {
                        // 可以在这里添加成功提示
                        console.log('动态删除成功');
                    } else {
                        console.error('动态删除失败');
                    }
                });
                
                // 点击空白区域隐藏菜单
                $(document).on("click", function() {
                    hideMomentMenu();
                });
                
                // 防止菜单内点击事件冒泡
                $(document).on("click", ".moment_menu_dropdown", function(e) {
                    e.stopPropagation();
                });
                
                // 防止对话框内点击事件冒泡
                $(document).on("click", ".moment_confirm_dialog > div", function(e) {
                    e.stopPropagation();
                });
                $(document).on("click", "#cancel-setting-btn", () =>
                    closeSettingPopup(),
                );
                $(document).on("click", "#save-setting-btn", () =>
                    saveSettingAndClose(),
                );
                $(document).on(
                    "click",
                    "#randomcolor-setting-btn",
                    function () {
                        const { bgColor, textColor } = generateBubbleColor();
                        $("#bubble-color").val(bgColor);
                        $("#bubble-color-input").val(bgColor);
                        $("#text-color").val(textColor);
                        $("#text-color-input").val(textColor);
                        $("#chat-setting-preview").each(function () {
                            this.style.setProperty(
                                "background-color",
                                bgColor,
                                "important",
                            );
                            const spans = this.querySelectorAll("span");
                            spans.forEach((span) => {
                                span.style.setProperty(
                                    "color",
                                    textColor,
                                    "important",
                                );
                            });
                        });
                    },
                );
                // *** 启用动态评论功能 ***
            $(document).on("click", ".moment_comment", QQ_Moment_Comment);
            
            // *** 新增：支持回车键发送评论 ***
            $(document).on("keypress", ".user_moment input[type='text']", function(e) {
                if (e.which === 13) { // 回车键
                    const $sendButton = $(this).siblings('.moment_comment');
                    if ($sendButton.length > 0) {
                        $sendButton.click();
                    }
                }
            });
                $(document).on("click", "#QQ_chat_send-btn", (event) =>
                    QQ_SendMsg(event),
                );
                $(document).on("dblclick", ".Chat_MyHead", (e) => QQ_Roll(e));
                $(document).on("click", ".QQ_chat_voice", (e) =>
                    QQ_Voice2Text(e),
                );
                $(document).on("click", ".music-container", (e) =>
                    QQ_MusicPlay(e),
                );
                $(document).on("click", ".popup-overlay", function (e) {
                    if (e.target === this) {
                        closeSettingPopup();
                    }
                });
                $(document).on("click", ".top", function () {
                    if ($(".discord").css("display") == "none") {
                        App_Load("discord");
                    } else {
                        App_Load("QQ");
                    }
                });
                $(document).on("click", ".discord-top-return", () =>
                    App_Load("QQ"),
                );
                $(document).on("click", ".app-svg-div[data-app='QQ']", () =>
                    App_Load("QQ"),
                );
                $(document).on(
                    "click",
                    ".app-svg-div[data-app='twitter']",
                    () => App_Load("twitter"),
                );
                // 添加输入框回车事件监听
                $(document).on("keydown", ".userInput", function (e) {
                    QQ_EnterPress(e, this);
                });
                $(document).on(
                    "keydown",
                    ".discord-thread-input-userinput",
                    function (e) {
                        Discord_EnterPress(e, this);
                    },
                );
                $(document).on("click", ".discord-card", (e) =>
                    Discord_LoadThread(e),
                );
                $(document).on(
                    "click",
                    ".discord-thread-top-return",
                    function () {
                        $(".discord-homepage").show();
                        $(".discord-thread-list").hide();
                    },
                );
                $(document).on("click", ".discord-cardget", function () {
                    triggerSlash("/send 查看discord帖子内容|/trigger");
                });
                $(document).on(
                    "click",
                    ".discord_thread-input-sendbutton",
                    (e) => Discord_Send(e),
                );
                $(document).on(
                    "input",
                    ".discord-thread-input-userinput",
                    (e) => Discord_input(e),
                );
                // 首先，尝试从聊天备份中恢复历史记录
                console.log("初始化流程：开始加载聊天记录备份...");
                const restoredFromBackup = await QQ_Load_Chat_Backup();

                const message = System_TagCompletion(
                    await ST.GetCurrentMessages(),
                );

                if (!restoredFromBackup) {
                    // 如果从备份加载失败（比如新用户），则尝试解析当前楼层的旧格式消息作为备用方案
                    console.log('备份加载失败，尝试解析当前楼层消息...');
                let match = message.match(/msg_start([\s\S]+?)msg_end/);
                if (match) {
                        console.log(`解析当前楼层聊天记录：\n${match[1].trim()}`);
                    await QQ_Msg_Parse(match[1].trim());
                    if (!match[1].match(/\S/)) {
                        await QQ_Save_Msg();
                    }
                    }
                }
                const matches = message.matchAll(
                    /moment_start([\s\S]+?)moment_end/g,
                );
                if (matches) {
                    console.log(`解析动态内容!!!!!!!!!!!!!!!`);
                    for (const m of matches) {
                        QQ_Moment_Parse(m[1].trim());
                    }
                }
                let discords = message.matchAll(
                    /(?:discord_start|<discord>)([\S\s]+?)(?:discord_end|<\/discord>)/g,
                );
                if (discords) {
                    console.log(`解析论坛内容!!!!!!!!!!!!!!!`);
                    for (const discord of discords) {
                        Discord_Parse(discord[1]);
                    }
                }
                console.log(`群聊列表:${QQ_Groups.join(",")}`);
                
                // 4. 所有数据加载完成后，最后执行UI渲染和导航
                console.log("页面初始化完成，即将导航到默认页面...");
                setTimeout(() => {
                    QQ_Nav("people");
                    QQ_UpdateMessageList();
                    if (typeof initContactSearch === 'function') {
                        initContactSearch();
                    }
                    if (typeof initContactGroups === 'function') {
                        initContactGroups();
                    }
                }, 500);
            }
            //space_init();
            console.log(`4.11`);
            init();
            
            
            // 确保页面完全加载后更新消息列表
            setTimeout(() => {
                QQ_UpdateMessageList();
                
                // 额外的搜索功能初始化检查（用于SillyTavern环境）
                if (document.getElementById('contact_search_input') && 
                    !document.getElementById('contact_search_input').hasAttribute('data-initialized')) {
                    console.log("执行额外的搜索功能初始化");
                    initContactSearch();
                }
            }, 1000);
            async function WorldBookUpdate() {
                let text = {
                    "手机-格式1-格式开头": _1_raw_namespaceObject,
                    "手机-格式2-QQ聊天": _2_QQ_raw_namespaceObject,
                    "手机-格式3-QQ空间": _3_QQ_raw_namespaceObject,
                    "手机-格式4-discord论坛": _4_discord_raw_namespaceObject,
                    "手机-格式999-格式结尾": _999_raw_namespaceObject,
                    "手机-界面基本设置": src_worldbook_raw_namespaceObject_0,
                    // "手机-角色"条目不应该被自动更新，应该保留用户的数据
                    "手机-角色": `[a]
头像=http://sharkpan.xyz/f/mQFW/mmexport1736279065029.png
[b]
头像=http://sharkpan.xyz/f/BZsa/mmexport1736279012663.png
[相亲相爱一家人]
类型=群聊
成员=a,b
头像=http://sharkpan.xyz/f/z0WU5/mmexport1736971020657.gif`,
                    "手机-表情包存放": _worldbook_raw_namespaceObject,
                    "手机-随机头像": _raw_namespaceObject,
                };
                const nowver = Phone_Settings.readValue(
                    "下面是基本设置",
                    "世界书版本",
                );
                if (nowver && Number(version) <= Number(nowver)) {
                    console.log(`世界书版本:${nowver} 符合要求不更新`);
                    return;
                }
                console.log(`世界书版本:${nowver}`);
                console.log(`开始自动更新世界书`);
                for (let entry of entries) {
                    if (entry.comment == "手机-格式") {
                        try {
                            await deleteLorebookEntry(worldbook, entry.uid);
                        } catch {
                            console.log(`删除手机-格式世界书失败`);
                        }
                    }
                }
                let ini = new MyINI();
                ini.loadText(worldlistraw_namespaceObject);
                for (const section of ini.getAllSections()) {
                    let targetEntry = entries.find(
                        (entry) => entry.comment == section,
                    );
                    if (targetEntry && ini.readValue(section, "覆盖") != "真") {
                        continue;
                    }
                    if (targetEntry) {
                        console.log(`${section}存在,开始修改`);
                        await setLorebookEntries(worldbook, [
                            {
                                uid: targetEntry.uid,
                                content: text[section],
                                key: ini
                                    .readValue(section, "关键词")
                                    .split(",")
                                    .map((item) => item.trim()),
                                depth: ini.readValue(section, "深度"),
                                type:
                                    ini.readValue(section, "类型") == "蓝灯"
                                        ? "constant"
                                        : "selective",
                                exclude_recursion: true,
                                order: Number(ini.readValue(section, "顺序")),
                                enabled: true,
                            },
                        ]);
                        console.log(`${section}修改完成`);
                    } else {
                        console.log(`${section}不存在,开始创建`);
                        await createLorebookEntry(worldbook, {
                            comment: section,
                            key: ini
                                .readValue(section, "关键词")
                                .split(",")
                                .map((item) => item.trim()),
                            content: text[section],
                            position: "at_depth_as_system",
                            type:
                                ini.readValue(section, "类型") == "蓝灯"
                                    ? "constant"
                                    : "selective",
                            depth: ini.readValue(section, "深度"),
                            exclude_recursion: true,
                            order: Number(ini.readValue(section, "顺序")),
                            enabled: true,
                        });
                    }
                }
                Phone_Settings.writeValue(
                    "下面是基本设置",
                    "世界书版本",
                    version,
                );
                // for (let entry of entries) {
                //   if (
                //     entry.comment == "手机-界面基本设置" ||
                //     entry.comment == "手机界面基本设置"
                //   ) {
                //     await setLorebookEntries(worldbook,
                //       [{
                //         uid: entry.uid,
                //         content: Phone_Settings.getAllText(),
                //       }]
                //     );
                //   }
                // }
                // 重新获取更新后的世界书条目
                entries = await getLorebookEntries(worldbook);
                triggerSlash("/echo severity=success 手机世界书自动更新成功");
                triggerSlash("/echo severity=success 点击手机logo可以切换页面");
            }
            function System_TagCompletion(content) {
                if (!content) {
                    return "";
                }
                content = content.replace(
                    /<(?:think|thinking)>[\s\S]+?<\/(?:think|thinking)>/gi,
                    "",
                );
                let match = content.match(/moment_end[\s\S]*discord_start/);
                if (!match && content.indexOf("moment_end") > 0) {
                    content = content.replace(
                        "moment_end",
                        "moment_end\ndiscord_start",
                    );
                }
                match = content.match(/MiPhone_start[\s\S]*msg_start/);
                if (!match && content.indexOf("msg_start") > 0) {
                    content = content.replace(
                        "msg_start",
                        "MiPhone_start\nmsg_start",
                    );
                }
                return content;
            }
            function System_AddNpcHead(name, url) {
                if (name in Npc_Settings && Npc_Settings[name].head) {
                    return;
                }
                if (
                    name == UserName ||
                    QQ_CharSettings.getAllSections().includes(name)
                ) {
                    //console.log(`${name}已存在头像,不再重复添加`)
                    return;
                }
                if (name in Npc_Settings == false) {
                    Npc_Settings[name] = {};
                }
                if (!url) {
                    url = QQ_GetRandomHead();
                }
                console.log(`为${name}添加头像${url}`);
                Npc_Settings[name].head = url;
                System_UpdateNpcCss();
            }
            function System_UpdateNpcCss() {
                let cssvalue = "";
                for (let key in Npc_Settings) {
                    try {
                        if (
                            "head" in Npc_Settings[key] == false ||
                            !Npc_Settings[key].head
                        ) {
                            Npc_Settings[key].head = QQ_GetRandomHead();
                            //console.log(`给${key}添加随机头像:${Npc_Settings[key].head}`);
                        }
                        cssvalue += `\n.head[data-name='${key}'] { background-image: url('${Npc_Settings[key].head}') !important;}`;
                        const { bgColor, textColor } = generateBubbleColor();
                        if (
                            "bubble" in Npc_Settings[key] == false ||
                            !Npc_Settings[key].bubble
                        ) {
                            Npc_Settings[key].bubble = bgColor;
                        }
                        if (
                            "text" in Npc_Settings[key] == false ||
                            !Npc_Settings[key].text
                        ) {
                            Npc_Settings[key].text = textColor;
                        }
                        cssvalue += `\n.QQ_chat_msgdiv[data-name='${key}']{
      background-color: ${Npc_Settings[key].bubble} !important;
      span{
      color: ${textColor} !important;}
      }`;
                    } catch (e) {}
                }
                //console.log(`新Npc的Css:\n${cssvalue}`);
                $(`style[data-name=AutoNpc]`).text(cssvalue);
                insertOrAssignVariables({
                    Npc_Settings: JSON.stringify(Npc_Settings),
                });
            }
            function generateBubbleColor() {
                // 生成背景色参数（HSV模型）
                const hueSegments = [0, 60, 120, 180, 240, 300, 360];
                const segmentIndex = Math.floor(Math.random() * 6); // 0-5
                // 在选定的区间内随机生成色相（避免跨区间混杂）
                const H = hueSegments[segmentIndex] + Math.random() * 60;
                const S = 30 + Math.random() * 40; // 饱和度 30%-70%
                const V = 60 + Math.random() * 30; // 亮度 60%-90%
                const bgRgb = hsvToRgb(H, S, V);
                const bgHex = rgbToHex(...bgRgb);
                // 生成互补色
                const complementH = (H + 180) % 360;
                // 提高饱和度并反转亮度
                const textS = Math.min(S + 20, 100); // 提高20%饱和度
                const textV = 100 - V; // 亮度取反
                const textRgb = hsvToRgb(complementH, textS, textV);
                const textHex = rgbToHex(...textRgb);
                // 计算对比度
                const bgLum = calculateLuminance(bgRgb);
                const textLum = calculateLuminance(textRgb);
                const contrastRatio =
                    (Math.max(bgLum, textLum) + 0.05) /
                    (Math.min(bgLum, textLum) + 0.05);
                // 根据对比度返回颜色（至少4.5:1）
                if (contrastRatio >= 4.5) {
                    return { bgColor: bgHex, textColor: textHex };
                } else {
                    // 对比度不足时回退到黑白
                    const textColor = bgLum > 0.5 ? "#000000" : "#FFFFFF";
                    return { bgColor: bgHex, textColor };
                }
            }
            /**
             * 计算颜色的相对亮度（范围 0-1）
             * 公式参考：WCAG 2.0 标准（https://www.w3.org/TR/WCAG20/）
             */
            function calculateLuminance([r, g, b]) {
                const [R, G, B] = [r, g, b].map((v) => {
                    v /= 255;
                    return v <= 0.03928
                        ? v / 12.92
                        : Math.pow((v + 0.055) / 1.055, 2.4);
                });
                return 0.2126 * R + 0.7152 * G + 0.0722 * B; // 权重系数
            }
            function hsvToRgb(h, s, v) {
                h /= 360;
                s /= 100;
                v /= 100; // 归一化到 [0,1]
                const i = Math.floor(h * 6);
                const f = h * 6 - i;
                const p = v * (1 - s);
                const q = v * (1 - f * s);
                const t = v * (1 - (1 - f) * s);
                let r, g, b;
                switch (i % 6) {
                    case 0:
                        [r, g, b] = [v, t, p];
                        break;
                    case 1:
                        [r, g, b] = [q, v, p];
                        break;
                    case 2:
                        [r, g, b] = [p, v, t];
                        break;
                    case 3:
                        [r, g, b] = [p, q, v];
                        break;
                    case 4:
                        [r, g, b] = [t, p, v];
                        break;
                    case 5:
                        [r, g, b] = [v, p, q];
                        break;
                }
                // 扩展为 0-255 的 RGB 值
                return [
                    Math.round(r * 255),
                    Math.round(g * 255),
                    Math.round(b * 255),
                ];
            }
            /**
             * RGB 转十六进制
             */
            function rgbToHex(...rgb) {
                return (
                    "#" +
                    rgb.map((x) => x.toString(16).padStart(2, "0")).join("")
                );
            }
            function Discord_EnterPress(e, element) {
                if (e.key !== "Enter") {
                    return;
                }
                if (!element) return;
                const value = $(element).val();
                if (!value) {
                    return;
                }
                const $closest = $(element).closest(".discord-thread");
                const id = $closest.attr("data-id");
                const result = `在帖子${id}中回复:\n${value}`;
                triggerSlash(`/send ${result}|/trigger`);
                $(element).val("").trigger("input");
                const commentlist = $closest.find(
                    ".discord-thread-comment-list",
                );
                const comment = _.template(discord_discord_thread_comment)({
                    name: UserName,
                    content: value,
                    creator: "",
                    isuser: " user_avatar",
                });
                commentlist.append(comment);
                const scroll = $closest.find(".discord-scroll-container");
                scroll.scrollTop(scroll[0].scrollHeight);
            }
            function Discord_Send(event) {
                event.stopPropagation();
                if (!event.currentTarget) return;
                const $closest = $(event.currentTarget).closest(
                    ".discord-thread",
                );
                const value = $closest
                    .find(".discord-thread-input-userinput")
                    .val();
                const id = $closest.attr("data-id");
                const result = `在帖子${id}中回复:\n${value}`;
                triggerSlash(`/send ${result}|/trigger`);
                $closest
                    .find(".discord-thread-input-userinput")
                    .val("")
                    .trigger("input");
                const commentlist = $closest.find(
                    ".discord-thread-comment-list",
                );
                const comment = _.template(discord_discord_thread_comment)({
                    name: UserName,
                    content: value,
                    creator: "",
                    isuser: " user_avatar",
                });
                commentlist.append(comment);
                const scroll = $closest.find(".discord-scroll-container");
                scroll.scrollTop(scroll[0].scrollHeight);
            }
            function Discord_Parse(content) {
                const matches = content.matchAll(
                    /<([0-9a-zA-Z]+)>([\s\S+]*?)<\/([0-9a-zA-Z]+)>/g,
                );
                if (!matches) {
                    console.log(`论坛匹配失败,返回!`);
                    return;
                }
                for (const match of matches) {
                    Discord_AddCard(match[1], match[2]);
                }
            }
            function Discord_AddCard(id, content) {
                if (!id) return;
                console.log(`添加论坛内容!!!!!!!!!`);
                let comment_list;
                let author = "";
                let map = new Map();
                let match = content.match(/<正文>([\s\S+]+?)<\/正文>/);
                if (!match) {
                    console.log(`匹配正文标签失败\n${content}`);
                    return;
                }
                let matches = match[1].matchAll(/(.+?)[:：]\s*(.+)/g);
                for (const m of matches) {
                    if (m[1].trim() == "帖子总评论数-") {
                        map.set("帖子总评论数", m[2].trim());
                    } else {
                        map.set(m[1].trim(), m[2].trim());
                    }
                }
                console.log(
                    `匹配到论坛内容:\n${JSON.stringify(Object.fromEntries(map))}`,
                );
                let img = map.get("帖子配图描述")?.match(/\[img-(.+?)\]/);
                if (img) {
                    map.set("帖子配图描述", img[1]);
                }
                if (map.get("帖子标签")) {
                    let tags = map.get("帖子标签").split("/");
                    let localtag = "";
                    for (const tag of tags) {
                        localtag += `<div class="discord-card-tag">${tag}</div>`;
                    }
                    if (localtag) {
                        map.set("帖子标签", localtag);
                    }
                }
                const html = _.template(discord_discord_card)({
                    id: id,
                    tag: map.get("帖子标签"),
                    time: map.get("距离发帖过去时间"),
                    name: map.get("发帖人"),
                    cardtilte: map.get("帖子标题"),
                    content: map.get("帖子正文"),
                    img: map.get("帖子配图描述"),
                    messages: map.get("帖子总评论数"),
                    likes: map.get("帖子总点赞数"),
                });
                $(".discord-cardlist").append(html);
                $(".discord-cardget").hide();
                const thread = _.template(discord_discord_thread)({
                    id: id,
                    tag: map.get("帖子标签"),
                    time: map.get("距离发帖过去时间"),
                    name: map.get("发帖人"),
                    threadtilte: map.get("帖子标题"),
                    content: map.get("帖子正文"),
                    img: map.get("帖子配图描述"),
                    messages: map.get("帖子总评论数"),
                    likes: map.get("帖子总点赞数"),
                    isuser:
                        map.get("发帖人").trim() == UserName
                            ? " user_avatar"
                            : "",
                });
                System_AddNpcHead(map.get("发帖人") ?? "未知用户");
                $(".discord-thread-list").append(thread);
                comment_list = $(`.discord-thread[data-id=${id}]`).find(
                    ".discord-thread-comment-list",
                );
                match = content.match(/<评论>([\s\S+]+?)<\/评论>/);
                if (match) {
                    let matches = match[1].matchAll(/^\s*(.+?)--\s*(.+)$/gm);
                    if (matches) {
                        for (let m of matches) {
                            const comment = _.template(
                                discord_discord_thread_comment,
                            )({
                                name: m[1].trim(),
                                content: AtMessage(m[2]),
                                creator:
                                    map.get("发帖人") == m[1] ||
                                    QQ_CharSettings.getAllSections().includes(
                                        m[1],
                                    )
                                        ? " discord-name-creator"
                                        : "",
                                isuser:
                                    m[1].trim() == UserName
                                        ? " user_avatar"
                                        : "",
                            });
                            System_AddNpcHead(m[1]);
                            comment_list.append(comment);
                        }
                    }
                }
            }
            function AtMessage(content) {
                const match = content.match(/(@.{1,8}?) /);
                if (match) {
                    content = content.replace(
                        match[1],
                        `<span style='color:#587ef5'>${match[1]}</span>`,
                    );
                }
                return content;
            }
            function Discord_AddCard_Old(id, content) {
                console.log(`添加论坛内容!!!!!!!!!`);
                let comment_list;
                let author = "";
                for (const str of content.split(/\r?\n/g)) {
                    let match = str.match(
                        /(.+?)--(.+?)--(.+?)--(.+?)--(.+?)--(.+?)--(.+?)--(.+)/,
                    );
                    if (match) {
                        const html = _.template(discord_card)({
                            id: id,
                            tag: match[5],
                            time: match[6],
                            name: match[1],
                            cardtilte: match[2],
                            content: match[3],
                            img: match[4],
                            messages: match[7],
                            likes: match[8],
                        });
                        $(".discord-cardlist").append(html);
                        const thread = _.template(discord_thread)({
                            id: id,
                            tag: match[5],
                            time: match[6],
                            name: match[1],
                            threadtilte: match[2],
                            content: match[3],
                            img: match[4],
                            messages: match[7],
                            likes: match[8],
                        });
                        System_AddNpcHead(match[1]);
                        $(".discord-thread-list").append(thread);
                        comment_list = $(`.discord-thread[data-id=${id}]`).find(
                            ".discord-thread-comment-list",
                        );
                        author = match[1];
                        continue;
                    }
                    match = str.match(/^(.+?)[:：](.+)$/m);
                    if (match && comment_list && comment_list.length > 0) {
                        const comment = _.template(discord_thread_comment)({
                            name: match[1],
                            content: match[2],
                            creator:
                                author == match[1]
                                    ? " discord-name-creator"
                                    : "",
                            isuser: match[1] == UserName ? " user_avatar" : "",
                        });
                        System_AddNpcHead(match[1]);
                        comment_list.append(comment);
                    }
                }
            }
            function Discord_LoadThread(event) {
                event.stopPropagation();
                if (!event.currentTarget) return;
                const id = $(event.currentTarget).attr("data-id");
                if (!id) {
                    return;
                }
                let ThreadPage = $(`.discord-thread[data-id=${id}]`);
                if (ThreadPage.length === 0) {
                    return;
                }
                $(`.discord-thread`).hide();
                ThreadPage.show();
                $(".discord-homepage").hide();
                $(".discord-thread-list").show();
            }
            function Discord_input(event) {
                event.stopPropagation();
                if (!event.currentTarget) return;
                if ($(event.currentTarget).val()) {
                    console.log(`显示`);
                    $(".discord-thread-input-button").hide();
                    $(".discord-thread-input-focus-button").show();
                } else {
                    console.log(`隐藏`);
                    $(".discord-thread-input-button").show();
                    $(".discord-thread-input-focus-button").hide();
                }
            }
            async function QQ_MusicPlay(event) {
                event.stopPropagation();
                if (!event.currentTarget) return;
                const $element = $(event.currentTarget);
                const musicname = $element.find(".music-name")?.text().trim();
                const singer = $element.find(".music-author")?.text().trim();
                if (!musicname) {
                    QQ_Error("获取歌曲信息失败");
                    return;
                }
                const $playbutton = $element.find(".icon-music-play");
                const $stopbutton = $element.find(".icon-music-stop");
                // 立即切换按钮状态
                if (!$playbutton.is(":hidden")) {
                    // 🔴 先改变界面状态
                    $playbutton.hide();
                    $stopbutton.show();
                    $element.addClass("loading"); // 添加加载动画
                    QQ_Music.lastelement = $element;
                    try {
                        // 异步获取音源
                        let source = await WY_MusicGetUrl(musicname, singer);
                        if (!source?.url) {
                            console.log(`网易云获取失败,开始在QQ音乐中搜索`);
                            source = await QQ_MusicGetUrl(musicname);
                            if (!source || !source.url) {
                                throw new Error("无可用音源");
                            }
                        }
                        // 设置新音源
                        QQ_Music.audio.src = source.url;
                        if (source.cover) {
                            $element
                                .find(".music-img")
                                .css(
                                    "background-image",
                                    `url('${source.cover}')`,
                                );
                            $element.find(".music-img").show();
                        }
                        // 自动播放
                        await QQ_Music.audio.play();
                        // 更新其他元素状态
                        if (
                            QQ_Music.lastelement &&
                            !QQ_Music.lastelement.is($element)
                        ) {
                            QQ_Music.lastelement
                                .find(".icon-music-stop")
                                .hide();
                            QQ_Music.lastelement
                                .find(".icon-music-play")
                                .show();
                        }
                    } catch (error) {
                        console.error("播放失败:", error);
                        QQ_Error("播放失败");
                        // 🔴 失败时回滚按钮状态
                        $playbutton.show();
                        $stopbutton.hide();
                    } finally {
                        $element.removeClass("loading");
                    }
                } else {
                    // 暂停逻辑保持不变
                    QQ_Music.audio.pause();
                    $playbutton.show();
                    $stopbutton.hide();
                }
            }
            async function QQ_MusicGetUrl(name) {
                try {
                    // 获取歌曲列表
                    name = name.replace(/\s/g, "");
                    let cover = "";
                    const result = await Http_Get(
                        `https://api.vkeys.cn/v2/music/tencent?word=${name}`,
                    );
                    if (!result?.data?.length) {
                        QQ_Error("搜索歌曲失败");
                        return;
                    }
                    // 提取所有id
                    let ids = [];
                    for (const data of result.data) {
                        if (!cover && data.cover) {
                            cover = data.cover;
                        }
                        if (data.id) {
                            ids.push(data.id);
                        }
                        if (data.grp) {
                            for (const grp of data.grp) {
                                if (grp.id) {
                                    ids.push(grp.id);
                                }
                            }
                        }
                    }
                    console.log(`id数量:${ids.length}`);
                    // 遍历音质组检测可用音源
                    for (const id of ids) {
                        try {
                            // 获取具体音源URL
                            console.log(`准备检测音源 ID:${id}`);
                            const r = await Http_Get(
                                `https://api.vkeys.cn/v2/music/tencent?id=${id}`,
                            );
                            if (!r?.data?.url) continue;
                            // 异步检测音源可用性
                            const isAvailable = await checkAudioAvailability(
                                r.data.url,
                            );
                            if (isAvailable) {
                                console.log(`找到可用音源: ${r.data.url}`);
                                return {
                                    url: r.data.url,
                                    cover: cover,
                                };
                            }
                        } catch (e) {
                            console.warn(`音源检测失败: ${id}`, e);
                        }
                    }
                    QQ_Error("没有找到可用音源");
                } catch (e) {
                    QQ_Error("歌曲搜索异常");
                    console.error("获取音源失败:", e);
                }
            }
            async function WY_MusicGetUrl(name, singer) {
                let url = `https://api.vkeys.cn/v2/music/netease?word=${name}`;
                if (singer) {
                    url += `-${singer}`;
                }
                let result = await Http_Get(url);
                if (!result) return;
                let cover = "";
                let ids = [];
                for (const data of result.data) {
                    if (!cover && data.cover) {
                        cover = data.cover;
                    }
                    if (data.id) {
                        ids.push(data.id);
                    }
                }
                for (const id of ids) {
                    try {
                        // 获取具体音源URL
                        console.log(`准备检测音源 ID:${id}`);
                        const r = await Http_Get(
                            `https://api.vkeys.cn/v2/music/netease?id=${id}`,
                        );
                        if (!r?.data?.url) continue;
                        // 异步检测音源可用性
                        const isAvailable = await checkAudioAvailability(
                            r.data.url,
                        );
                        if (isAvailable) {
                            console.log(`找到可用音源: ${r.data.url}`);
                            return {
                                url: r.data.url,
                                cover: cover,
                            };
                        }
                    } catch (e) {
                        console.warn(`音源检测失败: ${id}`, e);
                    }
                }
            }
            /** 音频可用性检测函数 */
            async function checkAudioAvailability(url) {
                return new Promise((resolve) => {
                    // 创建测试用音频对象
                    const tester = new Audio();
                    let timer;
                    // 成功加载元数据
                    const onLoaded = () => {
                        cleanup();
                        resolve(true);
                    };
                    // 发生错误或超时
                    const onError = () => {
                        cleanup();
                        resolve(false);
                    };
                    // 清理事件监听
                    const cleanup = () => {
                        tester.removeEventListener("loadedmetadata", onLoaded);
                        tester.removeEventListener("error", onError);
                        clearTimeout(timer);
                        tester.src = ""; // 释放资源
                    };
                    // 设置检测参数
                    tester.preload = "metadata";
                    tester.src = url;
                    timer = setTimeout(onError, 3000); // 3秒超时
                    // 绑定事件监听
                    tester.addEventListener("loadedmetadata", onLoaded);
                    tester.addEventListener("error", onError);
                });
            }
            function Http_Get(url) {
                return new Promise((resolve, reject) => {
                    $.ajax({
                        url: url,
                        method: "GET",
                        timeout: 10000,
                        success: function (data, status) {
                            resolve(data); // 成功时返回数据
                        },
                        error: function (xhr, status, error) {
                            if (status === "timeout") {
                                console.error("请求超时，请检查网络或重试");
                            } else {
                                console.error("请求失败，错误信息：", error);
                            }
                            resolve(null);
                            //reject(error); // 失败时抛出错误
                        },
                    });
                });
            }
            function JsonYamlParse(content) {
                content = content.replace(/\{\{user\}\}/g, UserName);
                try {
                    let json = JSON.parse(content);
                    return json;
                } catch {
                    console.log(`json解析失败`);
                }
                try {
                    let simple = Simpleformat(content);
                    if (simple) {
                        console.log(`简单格式转换成功:\n${simple}`);
                        return simple;
                    } else {
                        console.log(`简单转换失败`);
                    }
                } catch {}
                try {
                    let yaml = YAML.parse(content);
                    console.log(`yaml解析成功`);
                    return yaml;
                } catch {
                    //console.log(`yaml解析失败:\n${content}`);
                }
                try {
                    content = content.replace(/^\s*群聊:/m, "群聊:");
                    content = content.replace(/^\s*私聊:/m, "私聊:");
                    content = fixYamlSingleQuotes(content);
                    //console.log(`第一次修复后的yaml文本:\n${content}`);
                    if (!content) {
                        return null;
                    }
                    let yaml = YAML.parse(content);
                    return yaml;
                } catch {
                    console.log(`第一次yaml修复失败`);
                }
                try {
                    content = fixYamlSingleQuotes(
                        content.replace(/\\'/g, "''"),
                    );
                    //console.log(`第二次修复后的yaml文本:\n${content}`);
                    if (!content) {
                        return null;
                    }
                    let yaml = YAML.parse(content);
                    return yaml;
                } catch {
                    console.log(`第二次yaml修复失败`);
                }
                try {
                    content = content.replace(/, /g, "\r\n    - ");
                    content = content.replace(/\['/g, "\r\n    - '");
                    content = content.replace(/'\]/g, "'");
                    content = fixYamlSingleQuotes(content);
                    //console.log(`第三次修复后的yaml文本:\n${content}`);
                    if (!content) {
                        return null;
                    }
                    let yaml = YAML.parse(content);
                    return yaml;
                } catch {
                    return null;
                }
            }
            function Simpleformat(content) {
                let json = {
                    私聊: {},
                    群聊: {},
                };
                // 添加私聊消息
                let matches = content.matchAll(
                    /<(.+?)和(.+?)的私聊>([\s\S]+?)<\/(.+?)和(.+?)的私聊>/g,
                );
                if (matches) {
                    for (const match of matches) {
                        if (match[1] != match[4] || match[2] != match[5]) {
                            QQ_Error("私聊标签闭合异常,请手动修复");
                        }
                        const key = `${match[1]}和${match[2]}的聊天`;
                        json.私聊[key] = [];
                        for (let line of match[3].split(/\r?\n/)) {
                            line = line.trim();
                            if (line) {
                                let m = line.match(
                                    /(.+?)\s*(?:--|:|：)\s*(.+)/,
                                );
                                if (!m) {
                                    continue;
                                }
                                let message = m[2];
                                if (message.split("--").length >= 2) {
                                    message = message.split("--")[0];
                                }
                                json.私聊[key].push(`${m[1]}--${m[2]}`);
                            }
                        }
                    }
                }
                // 添加群聊消息
                matches = content.matchAll(
                    /<群聊[:：](.+?)>([\s\S]+?)<\/群聊[:：](.+?)>/g,
                );
                if (matches) {
                    for (const match of matches) {
                        if (match[1] != match[3]) {
                            QQ_Error("群聊标签闭合异常,请手动修复");
                        }
                        json.群聊[match[1]] = {};
                        json.群聊[match[1]].members = [];
                        json.群聊[match[1]].msgs = [];
                        let m = match[2].match(/<成员>([\S\s]+?)<\/成员>/);
                        if (m) {
                            let members = m[1]
                                .split(",")
                                .map((item) => item.trim());
                            json.群聊[match[1]].members = members;
                        }
                        m = match[2].match(/<聊天内容>([\S\s]+?)<\/聊天内容>/);
                        if (m) {
                            for (let message of m[1].split(/\r?\n/)) {
                                message = message.trim();
                                if (message) {
                                    let regex = message.match(
                                        /(.+?)\s*(?:--|:|：)\s*(.+)/,
                                    );
                                    if (!regex) {
                                        continue;
                                    }
                                    let content = regex[2];
                                    if (content.split("--").length >= 2) {
                                        content = content.split("--")[0];
                                    }
                                    json.群聊[match[1]].msgs.push(
                                        `${regex[1]}--${regex[2]}`,
                                    );
                                }
                            }
                        }
                    }
                }
                console.log(`简单格式转换:${JSON.stringify(json)}`);
                return json;
            }
            function fixYamlSingleQuotes(yamlText) {
                try {
                    return yamlText.replace(
                        /(- ')(.*?[^\\])(')(?=\s*#|$)/gm,
                        (match, prefix, content, suffix) => {
                            // 使用三步处理法保证已有转义不变
                            const escaped = content
                                .replace(/''/g, "\uE000") // 步骤1：用临时Unicode占位符保存已有双引号
                                .replace(/'/g, "''") // 步骤2：转义所有剩余单引号
                                .replace(/\uE000/g, "''"); // 步骤3：恢复原有双引号
                            return `${prefix}${escaped}${suffix}`;
                        },
                    );
                } catch (e) {
                    QQ_Error(`${e}`);
                    return "";
                }
            }
            async function MiPhone_Merge() {
                let messages = await ST.GetCurrentMessages();
                messages = messages.replace(
                    /<(?:think|thinking)>[\s\S]+?<\/(?:think|thinking)>/gi,
                    "",
                );
                const matches = messages.matchAll(
                    /MiPhone_start([\s\S]+?)MiPhone_end/g,
                );
                if (!matches) {
                    return;
                }
                const matchesArray = [...matches];
                const length = matchesArray.length;
                console.log(`匹配到数量:${length}`);
                if (length <= 1) {
                    return;
                }
                for (let i = 0; i < matchesArray.length; i++) {
                    const value = matchesArray[i][0];
                    console.log(`value:\n${value}`);
                    const msg = value.match(/msg_start([\s\S]+?)msg_end/);
                    if (msg) {
                        let json;
                        try {
                            json = JsonYamlParse(msg[1]);
                            if (json) {
                                json = QQ_Msg_DeletOld(json);
                                await QQ_Msg_Parse(JSON.stringify(json));
                            }
                        } catch {}
                    }
                    if (i != matchesArray.length - 1) {
                        messages = messages.replace(value, "");
                    } else {
                        if (msg) {
                            const lovalvalue = value.replace(
                                msg[0],
                                `msg_start\n${QQ_Json2Text(QQ_msgjson)}\nmsg_end`,
                            );
                            messages = messages.replace(value, lovalvalue);
                        } else {
                            messages = messages.replace(
                                "MiPhone_start",
                                `msg_start\n${QQ_Json2Text(QQ_msgjson)}\nmsg_end`,
                            );
                        }
                    }
                }
                triggerSlash("/echo 存在多个格式,自动合并");
                triggerSlash(
                    "/echo 合并只会保留聊天内容,动态和论坛会丢失!!!!!",
                );
                const CurrentMessageId = await getCurrentMessageId();
                setChatMessage({ message: messages }, CurrentMessageId);
            }
            /**
             * *** 新增：从worldbook加载动态内容 ***
             */
            async function QQ_Load_Moments() {
                if (!worldbook || !entries) {
                    console.log('动态加载跳过：缺少worldbook或entries');
                    return;
                }
                
                try {
                    const momentEntry = entries.find(entry => entry.comment === "手机-动态内容存储");
                    
                    if (momentEntry && momentEntry.content) {
                        // 解析保存的动态数据
                        const savedMoments = JSON.parse(momentEntry.content);
                        
                        // 确保每个动态都有点赞数据结构
                        QQ_MomentsData = savedMoments.map(moment => {
                            if (!moment.likes) {
                                moment.likes = {
                                    count: parseInt(moment.extraContent) || 0,
                                    userLiked: false,
                                    likedBy: [],
                                    lastLikeTime: null
                                };
                            }
                            return moment;
                        });
                        
                        window.QQ_MomentsData = QQ_MomentsData; // 更新全局引用
                        
                        console.log('成功加载动态内容:', QQ_MomentsData.length, '条动态');
                        
                        // 重新渲染动态界面
                        await QQ_Render_Moments();
                    } else {
                        console.log('未找到保存的动态内容');
                    }
                } catch (error) {
                    console.error('加载动态内容失败:', error);
                }
            }
            
            /**
             * *** 新增：从worldbook加载聊天消息备份 ***
             */
             async function QQ_Load_Chat_Backup() {
                if (!worldbook || !entries) {
                    console.log('聊天备份加载跳过：缺少worldbook或entries');
                    return false;
                }
                
                try {
                    const chatBackupEntry = entries.find(entry => entry.comment === "手机-聊天消息备份");
                    
                    if (chatBackupEntry && chatBackupEntry.content) {
                        // 解析保存的聊天备份数据
                        const backupData = JSON.parse(chatBackupEntry.content);
                        
                        if (backupData.data && (backupData.data.私聊 || backupData.data.群聊)) {
                            console.log('✅ 找到聊天备份，准备恢复...');
                            
                            // [修复] 直接恢复备份数据，不再进行复杂的条件判断
                            QQ_msgjson = JSON.parse(JSON.stringify(backupData.data)); // 深拷贝
                            QQ_ChatBackup = backupData; // 更新内存中的备份引用
                            window.QQ_msgjson = QQ_msgjson; // 确保全局引用也更新
                            window.QQ_ChatBackup = QQ_ChatBackup; 
                            
                            console.log('✅ 成功恢复聊天备份数据:', Object.keys(QQ_msgjson.私聊 || {}).length, '个私聊,', Object.keys(QQ_msgjson.群聊 || {}).length, '个群聊');
                            return true;
                        } else {
                             console.log('🟡 聊天备份数据格式不正确或为空');
                             return false;
                        }
                    } else {
                        console.log('ℹ️ 未在世界书中找到聊天备份条目');
                        return false;
                    }
                } catch (error) {
                    console.error('加载聊天备份时发生严重错误:', error);
                    return false;
                }
            }

            /**
             * *** 新增：渲染动态内容到界面 (支持分页) ***
             */
            async function QQ_Render_Moments(loadMore = false) {
                const $spaceContents = $("#space_contents");
                
                if (QQ_MomentsData.length === 0) {
                    console.log('没有动态内容需要渲染');
                    momentsDisplayCount = 0;
                    return;
                }

                // 首次加载或非加载更多时清空内容
                if (!loadMore) {
                    $spaceContents.empty();
                    momentsDisplayCount = 0;
                }
                
                // 按时间戳倒序排列（最新的在前）
                const sortedMoments = [...QQ_MomentsData].sort((a, b) => {
                    return new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime();
                });

                // 确定要显示的动态范围
                const startIndex = momentsDisplayCount;
                const endIndex = Math.min(startIndex + (loadMore ? MOMENTS_LOAD_INCREMENT : MOMENTS_DISPLAY_LIMIT), sortedMoments.length);
                const momentsToShow = sortedMoments.slice(startIndex, endIndex);
                
                for (const momentData of momentsToShow) {
                    try {
                        const momentDiv = $("<div>", { 
                            class: "user_moment",
                            "data-moment-id": momentData.id // 添加动态ID属性
                        });
                        momentDiv.html(
                            _.template(moment_page)({
                                userName: momentData.userName,
                                message: momentData.message,
                                timestamp: momentData.timestampText,
                                additionalInfo: momentData.additionalInfo,
                                randomPhone: momentData.randomPhone,
                                extraContent: momentData.likes ? momentData.likes.count : 0, // 修正：点赞数用于extraContent
                                imgcontent: momentData.imgcontent || '',
                                momentId: momentData.id, // 传递动态ID到模板
                                // 新增：点赞相关数据
                                likeCount: momentData.likes ? momentData.likes.count : 0,
                                likedByUser: momentData.likes ? momentData.likes.userLiked : false
                            })
                        );
                        
                        // *** 渲染评论（使用新的折叠系统） ***
                        const commentsList = momentDiv.find(".user_leave_message_list");
                        QQ_Render_Comments(momentData, commentsList);
                        
                        $spaceContents.append(momentDiv);
                    } catch (error) {
                        console.error('渲染动态失败:', error, momentData);
                    }
                }

                // 更新显示计数
                momentsDisplayCount = endIndex;

                // 添加或更新"查看更多"按钮
                QQ_Update_Moments_LoadMore(sortedMoments.length);
                
                // 初始化点赞按钮事件绑定（如果还没有初始化）
                if (typeof QQ_InitMomentLikes === 'function') {
                    QQ_InitMomentLikes();
                }
                
                // 加载点赞状态
                if (typeof QQ_LoadMomentLikes === 'function') {
                    await QQ_LoadMomentLikes();
                }
                
                console.log(`动态内容渲染完成，显示 ${momentsDisplayCount}/${sortedMoments.length} 条`);
            }

            /**
             * *** 更新动态"查看更多"按钮 ***
             */
            function QQ_Update_Moments_LoadMore(totalMoments) {
                const $spaceContents = $("#space_contents");
                const loadMoreId = 'moments-load-more';
                
                // 移除旧的加载更多按钮
                $(`#${loadMoreId}`).remove();
                
                // 如果还有更多动态需要显示，添加按钮
                if (momentsDisplayCount < totalMoments) {
                    const loadMoreBtn = $(`
                        <div id="${loadMoreId}" style="text-align: center; padding: 20px 0; color: #999; font-size: 12px; cursor: pointer; border-top: 1px solid #e5e5e5; margin-top: 10px;">
                            --点击查看更多--
                        </div>
                    `);
                    
                    loadMoreBtn.on('click', async function() {
                        $(this).text('加载中...');
                        try {
                            await QQ_Render_Moments(true);  // 加载更多
                        } catch (error) {
                            console.error('加载更多动态失败:', error);
                            $(this).text('加载失败，点击重试');
                        }
                    });
                    
                    $spaceContents.append(loadMoreBtn);
                }
            }

            /**
             * *** 聊天消息分页加载函数 ***
             */
            async function QQ_Load_Chat_History(chatName, msgContainer) {
                const isGroup = QQ_Groups.includes(chatName);
                let allMessages = [];
                
                // 获取所有历史消息
                if (isGroup && QQ_msgjson.群聊[chatName] && QQ_msgjson.群聊[chatName].msgs) {
                    allMessages = [...QQ_msgjson.群聊[chatName].msgs];
                } else if (!isGroup && QQ_msgjson.私聊[`${UserName}和${chatName}的聊天`]) {
                    allMessages = [...QQ_msgjson.私聊[`${UserName}和${chatName}的聊天`]];
                }
                
                // 获取当前显示的消息数量
                const currentDisplayed = chatDisplayCounts[chatName] || 0;
                const totalMessages = allMessages.length;
                
                if (currentDisplayed >= totalMessages) {
                    console.log('没有更多历史消息');
                    return false;
                }
                
                // 计算要加载的消息范围（从历史往前倒推）
                const loadCount = Math.min(CHAT_LOAD_INCREMENT, totalMessages - currentDisplayed);
                const startIndex = Math.max(0, totalMessages - currentDisplayed - loadCount);
                const endIndex = totalMessages - currentDisplayed;
                const messagesToLoad = allMessages.slice(startIndex, endIndex);
                
                console.log(`准备加载历史消息: ${startIndex}-${endIndex}, 共${loadCount}条`);
                
                // 获取当前第一个消息元素，用于插入位置
                const $firstMsg = $(msgContainer).children().not('.load-more-messages').first();
                
                // 倒序添加消息到顶部（保持时间顺序）
                for (let i = messagesToLoad.length - 1; i >= 0; i--) {
                    const msg = messagesToLoad[i];
                    const tempDiv = $('<div>');
                    
                    // 使用修改后的QQ_Chat_AddMsg添加消息，跳过滚动和计数
                    QQ_Chat_AddMsg(tempDiv[0], msg, chatName, false, true);
                    
                    // 将消息插入到容器顶部
                    if ($firstMsg.length > 0) {
                        $firstMsg.before(tempDiv.html());
                    } else {
                        $(msgContainer).prepend(tempDiv.html());
                    }
                }
                
                // 更新显示计数
                chatDisplayCounts[chatName] = (chatDisplayCounts[chatName] || 0) + loadCount;
                
                console.log(`历史消息加载完成，当前显示: ${chatDisplayCounts[chatName]}/${totalMessages}`);
                return chatDisplayCounts[chatName] < totalMessages; // 返回是否还有更多消息
            }

            /**
             * *** 更新聊天"加载更多"按钮 ***
             */
            function QQ_Update_Chat_LoadMore(chatName, msgContainer) {
                const $container = $(msgContainer);
                const loadMoreId = `chat-load-more-${chatName.replace(/[^a-zA-Z0-9]/g, '_')}`;
                
                // 移除旧的加载更多按钮
                $(`.load-more-messages`).remove();
                
                // 检查是否需要显示加载更多按钮
                const isGroup = QQ_Groups.includes(chatName);
                let totalMessages = 0;
                
                if (isGroup && QQ_msgjson.群聊[chatName] && QQ_msgjson.群聊[chatName].msgs) {
                    totalMessages = QQ_msgjson.群聊[chatName].msgs.length;
                } else if (!isGroup && QQ_msgjson.私聊[`${UserName}和${chatName}的聊天`]) {
                    totalMessages = QQ_msgjson.私聊[`${UserName}和${chatName}的聊天`].length;
                }
                
                const currentDisplayed = chatDisplayCounts[chatName] || 0;
                
                // 只有当消息数量超过显示限制且还有历史消息时才显示按钮
                if (totalMessages > CHAT_DISPLAY_LIMIT && currentDisplayed < totalMessages) {
                    const loadMoreBtn = $(`
                        <div id="${loadMoreId}" class="load-more-messages" style="text-align: center; padding: 15px 0; color: #999; font-size: 12px; cursor: pointer; border-bottom: 1px solid #e5e5e5; margin-bottom: 10px; background-color: #f9f9f9;">
                            --点击加载更多--
                        </div>
                    `);
                    
                    loadMoreBtn.on('click', async function() {
                        $(this).text('加载中...');
                        try {
                            const hasMore = await QQ_Load_Chat_History(chatName, msgContainer);
                            if (!hasMore) {
                                $(this).text('没有更多消息了').css('color', '#ccc').off('click');
                                setTimeout(() => $(this).fadeOut(), 2000);
                            } else {
                                $(this).text('--点击加载更多--');
                            }
                        } catch (error) {
                            console.error('加载更多聊天消息失败:', error);
                            $(this).text('加载失败，点击重试');
                        }
                    });
                    
                    // 将按钮插入到容器顶部
                    $container.prepend(loadMoreBtn);
                }
            }

            /**
             * 初始化动态空间内容
             */
            function space_init() {
                $("#space_contents").prepend(space_contents);
                // *** 修改：初始化时加载保存的动态内容 ***
                setTimeout(() => {
                    QQ_Load_Moments();
                }, 500);
            }
            async function GetWorldBookName() {
                let localbook;
                try {
                    localbook = await getCurrentCharPrimaryLorebook();
                    console.log(
                        `角色卡绑定主要世界书`,
                        JSON.stringify(localbook),
                    );
                } catch (e) {
                    console.log(`获取绑定世界书出现异常:${e}`);
                }
                if (localbook) {
                    const localentrys = await getLorebookEntries(localbook);
                    const targetEntry = localentrys.find((entry) =>
                        ["手机-界面基本设置", "手机界面基本设置"].includes(
                            entry.comment,
                        ),
                    );
                    if (targetEntry) {
                        console.log(`使用角色卡绑定的世界书`);
                        return localbook;
                    }
                }
                const globalbook = (await getLorebookSettings())
                    .selected_global_lorebooks;
                if (globalbook) {
                    for (const book of globalbook) {
                        const localentrys = await getLorebookEntries(book);
                        const targetEntry = localentrys.find((entry) =>
                            ["手机-界面基本设置", "手机界面基本设置"].includes(
                                entry.comment,
                            ),
                        );
                        if (targetEntry) {
                            console.log(`使用全局世界书:${book}`);
                            return book;
                        }
                    }
                }
                if (localbook) {
                    return localbook;
                }
                console.log(`没有匹配的世界书`);
                return null;
            }
            async function DelPadding() {
                const message_id = await getCurrentMessageId();
                console.log(`开始移除头像和边距:${message_id}`);
                $(`div.mes[mesid="${message_id}"]`, window.parent.document)
                    .find(`div.mes_text`)
                    .css("padding-right", "0");
                $(`div.mes[mesid="${message_id}"]`, window.parent.document)
                    .find(`div.avatar`)
                    .css("display", "none");
                $(`div.mes[mesid="${message_id}"]`, window.parent.document)
                    .find(`div.mesAvatarWrapper`)
                    .css("display", "none");
            }
            /**
             * 获取设置
             */
            async function GetSettings() {
                console.log(
                    `测试获取ini:${Phone_Settings.readValue("下面是基本设置", "聊天壁纸")}`,
                );
                if (Phone_Settings.readValue("下面是基本设置", "内框颜色")) {
                    let value = Phone_Settings.readValue(
                        "下面是基本设置",
                        "内框颜色",
                    );
                    if (value[0] != "#") {
                        value += "#";
                    }
                    console.log(`设置气泡颜色为 ${value}`);
                    $("<style>")
                        .text(
                            `.card { background-color: ${value} !important; }`,
                        )
                        .appendTo("head");
                    $("<style>")
                        .text(`.top { background-color: ${value} !important; }`)
                        .appendTo("head");
                }
                let value = Phone_Settings.readValue(
                    "下面是基本设置",
                    "外框颜色",
                );
                if (value) {
                    if (value[0] != "#") {
                        value += "#";
                    }
                    console.log(`设置气泡颜色为 ${value}`);
                    $("<style>")
                        .text(
                            `.card { border: 2px solid ${value} !important; }`,
                        )
                        .appendTo("head");
                }
                value = Phone_Settings.readValue("下面是基本设置", "侧边按钮");
                if (value) {
                    if (value[0] != "#") {
                        value += "#";
                    }
                    console.log(`设置气泡颜色为 ${value}`);
                    $("<style>")
                        .text(
                            `.btn1 { background-color: ${value} !important; }`,
                        )
                        .appendTo("head");
                    $("<style>")
                        .text(
                            `.btn2 { background-color: ${value} !important; }`,
                        )
                        .appendTo("head");
                    $("<style>")
                        .text(
                            `.btn3 { background-color: ${value} !important; }`,
                        )
                        .appendTo("head");
                }
                value = Phone_Settings.readValue("下面是基本设置", "发送模式");
                if (value) {
                    if (value == "2") {
                        newgen = false;
                        console.log("设置发送模式为非流式");
                    } else {
                        newgen = true;
                        console.log("设置发送模式为流式");
                    }
                } else {
                    Phone_Settings.writeValue(
                        "下面是基本设置",
                        "发送模式",
                        "1",
                    );
                    console.log("未找到发送模式设置，使用默认流式发送");
                }
                value = Phone_Settings.readValue("下面是基本设置", "聊天壁纸");
                if (value) {
                    $("<style>")
                        .text(
                            `.QQ_chat_page {
      background-image: url("${value}");
    }`,
                        )
                        .appendTo("head");
                }
                value = Phone_Settings.readValue("下面是基本设置", "气泡颜色");
                if (value) {
                    if (value[0] != "#") {
                        value += "#";
                    }
                    //console.log(`设置气泡颜色为 ${value}`);
                    $("<style>")
                        .text(
                            `.QQ_chat_msgdiv { background-color: ${value} !important; }`,
                        )
                        .appendTo("head");
                }
                Phone_Settings.writeValue(
                    "下面是基本设置",
                    "世界书版本",
                    version,
                );
                for (let entry of entries) {
                    if (
                        entry.comment == "手机-界面基本设置" ||
                        entry.comment == "手机界面基本设置"
                    ) {
                        await setLorebookEntries(worldbook, [
                            {
                                uid: entry.uid,
                                content: Phone_Settings.getAllText(),
                            },
                        ]);
                    }
                }
                entries = await getLorebookEntries(worldbook);
            }
            /**
             * 根据角色名获取聊天设定
             *
             * @param name 角色名
             * @returns 聊天设定
             */
            function GetChatCharSettingByName(name) {
                let char_setting = "";
                for (let entry of entries) {
                    if (entry.comment == "配置-聊天-角色个人设定") {
                        char_setting = entry.content.trim();
                    }
                }
                if (!char_setting) {
                    return;
                }
                const char_setting_json = JSON.parse(char_setting);
                const setting = char_setting_json.find(
                    (item) => item.name === name,
                );
                if (!setting) {
                    return;
                }
                console.log(`获取到角色设定:${YAML.stringify(setting)}`);
                return setting;
            }
            async function Verify() {
                try {
                    // 获取版本元素并提取纯版本号
                    let version = await getFrontendVersion();
                    console.log(`酒馆助手版本${version}`);
                    // 拆分版本号为数字数组
                    const versionParts = version.split(".").map(Number);
                    if (versionParts.length < 3 || versionParts.some(isNaN)) {
                        throw new Error("Invalid version format");
                    }
                    // 解构赋值版本号
                    const [major, minor, patch] = versionParts;
                    // 设置最低要求版本
                    const MIN_MAJOR = 2;
                    const MIN_MINOR = 4;
                    const MIN_PATCH = 3;
                    // 版本比较逻辑
                    if (
                        major < MIN_MAJOR ||
                        (major === MIN_MAJOR &&
                            (minor < MIN_MINOR ||
                                (minor === MIN_MINOR && patch < MIN_PATCH)))
                    ) {
                        alert(
                            `前端助手版本过低 (当前 ${versionParts.join(".")}，需要至少 ${MIN_MAJOR}.${MIN_MINOR}.${MIN_PATCH})，请更新`,
                        );
                    }
                } catch (error) {
                    assertIsError(error);
                    console.error("版本验证失败:", error);
                    // 如果存在自定义错误处理则调用，否则使用默认提示
                    if (typeof QQ_Error === "function") {
                        QQ_Error(`验证前端助手版本失败: ${error.message}`);
                    } else {
                        alert("版本验证失败，请检查控制台信息");
                    }
                }
            }
            function assertIsError(error) {
                if (!(error instanceof Error)) {
                    throw new TypeError();
                }
            }
            function random(min, max) {
                return Math.floor(Math.random() * (max - min) + min);
            }
            function head_init() {
                let girl = `EJeUD/Image_1737026320652.jpg|Y8pt1/Image_1737026296736.jpg|QWWc6/Image_1737026308451.jpg|Z8LIW/Image_1737026306601.jpg|W8lhW/Image_1737026313246.jpg|0rJtX/Image_1737026292787.jpg|yVxsN/Image_1737026293840.jpg|vaBCL/Image_1737026286979.jpg|pZ6hQ/Image_1737026285632.jpg|11AH2/Image_1737026284351.jpg|eXKUw/Image_1737026281715.jpg|o31F4/Image_1737026277201.jpg|8E2uj/Image_1737026279242.jpg|GLmIl/Image_1737026275069.jpg|zWZT5/Image_1737026271769.jpg|7Zrij/Image_1737026269532.jpg|AqYsZ/Image_1737026266131.jpg|w4lFq/2406563368.jpeg|MQNua/2403629154.jpeg|3YZhe/2405854911.jpeg|5QKhj/2312445144.jpeg|k6JT6/2408434848.jpeg|j6Bf6/2386328773.jpeg|a8LHY/2386327598.jpeg|r08C6/2386327604.jpeg|DgECK/2331678725.jpeg|LJrC7/2371251634.jpeg|q1LF3/2329660869.gif|X84sW/2328035526.jpeg|2eDfQ/2326662447.jpeg|ggetw/2326683821.jpeg|J21ig/2323432137.gif`;
                let girls = girl.split("|");
                let result = "";
                for (let i = 0; i < girls.length; i++) {
                    if (girls[i]) {
                        random_head_list.push(girls[i]);
                        result += `\nhttp://sharkpan.xyz/f/${girls[i]}`;
                    }
                }
            }
            // 增加音频状态监听
            QQ_Music.audio.addEventListener("ended", () => {
                if (QQ_Music.lastelement) {
                    QQ_Music.lastelement.find(".icon-music-stop").hide();
                    QQ_Music.lastelement.find(".icon-music-play").show();
                }
            });
            QQ_Music.audio.addEventListener("error", () => {
                if (QQ_Music.lastelement) {
                    QQ_Music.lastelement.find(".icon-music-stop").hide();
                    QQ_Music.lastelement.find(".icon-music-play").show();
                }
                QQ_Error("播放出错，请尝试重新播放");
            });
            // 增加音频中断监听
            QQ_Music.audio.addEventListener("pause", () => {
                if (QQ_Music.lastelement) {
                    QQ_Music.lastelement.find(".icon-music-stop").hide();
                    QQ_Music.lastelement.find(".icon-music-play").show();
                }
            });
            async function LoadRandomHead() {
                let content = "";
                for (let entry of entries) {
                    if (entry.comment == "手机-随机头像") {
                        content = entry.content;
                    }
                }
                if (!content) {
                    return;
                }
                const matches = content.matchAll(/^http.+$/gm);
                for (const match of matches) {
                    const obj = {
                        url: match[0],
                        count: [
                            ...NpcCssValue.matchAll(new RegExp(match[0], "g")),
                        ].length,
                    };
                    QQ_RandomHead.push(obj);
                }
            }
            function GetWorldEntry(name, search) {
                let list = [];
                
                // 检查entries是否已初始化
                if (!entries) {
                    console.warn('GetWorldEntry: entries未初始化，返回null');
                    return null;
                }
                
                entries.forEach((item) => {
                    if (search) {
                        name.forEach((n) => {
                            if (item.comment.indexOf(n) > -1) {
                                list.push(item);
                            }
                        });
                    } else if (name.includes(item.comment)) {
                        list.push(item);
                    }
                });
                if (list.length == 0) {
                    return null;
                } else if (list.length == 1) {
                    return list[0];
                }
                // 存在多个条目,使用开启的条目,有多个开启条目不做处理
                for (let entry of list) {
                    if (entry.enabled) {
                        return entry;
                    }
                }
                // 全都没开启,直接返回第一个
                return list[0];
            }
            /**
             * 获取表情包
             */
            async function LoadEmoji() {
                let content = "";
                let phonebook = "";
                let phoneuid = -1;
                
                // 检查entries是否已初始化
                if (!entries) {
                    console.warn('LoadEmoji: entries未初始化，跳过表情包加载');
                    return;
                }
                
                for (let entry of entries) {
                    if (
                        entry.comment == "手机-表情包存放" ||
                        entry.comment == "表情包存放世界书"
                    ) {
                        content = entry.content;
                    } else if (entry.comment == "手机-格式2-QQ聊天") {
                        phonebook = entry.content;
                        phoneuid = entry.uid;
                    }
                }
                if (!content) {
                    console.log(`获取表情包世界书失败`);
                    return;
                }
                if (phoneuid == -1) {
                    console.log(`获取手机格式世界书条目失败`);
                    return;
                }
                content = content.replace(
                    /http:\/\/sharkpan/g,
                    "https://sharkpan",
                );
                content = content.replace(/--\n/g, "--");
                const regex = new RegExp("(.+?)--(http.+)", "g");
                const matches = [...content.matchAll(regex)];
                if (!matches) {
                    return;
                }
                console.log(`表情包数量:${matches.length}`);
                for (const match of matches) {
                    QQ_emoji.set(match[1], match[2]);
                }
                const keysArray = JSON.stringify(Array.from(QQ_emoji.keys()));
                const m = phonebook.match(
                    /<表情包列表>([\s\S]*?)<\/表情包列表>/,
                );
                if (m) {
                    phonebook = phonebook.replace(
                        m[0],
                        `<表情包列表>\n${keysArray}\n<\/表情包列表>`,
                    );
                    // await setLorebookEntries(worldbook, entrys.map((entry) => ({ uid: phoneuid, content: phonebook })));
                    await setLorebookEntries(worldbook, [
                        { uid: phoneuid, content: phonebook },
                    ]);
                }
            }
            /**
             * 聊天-加载角色列表
             *
             */
            async function LoadChars() {
                console.log('=== LoadChars 开始执行 ===');
                console.log('entries变量状态:', typeof entries, entries ? entries.length : 'undefined');
                console.log('worldbook变量:', worldbook);
                
                // 先列出所有entries的comment来检查
                if (entries) {
                    console.log('所有世界书条目:', entries.map(e => ({comment: e.comment, enabled: e.enabled, hasContent: !!e.content})));
                }
                
                // 检查世界书中的群聊内容
                checkWorldbookGroups();
                
                let content;
                // for (let entry of entries) {
                //   if (entry.comment == "手机-角色" || entry.comment == "手机界面-角色") {
                //     content = entry.content;
                //     break;
                //   }
                // }
                // if (!content) {
                //   return;
                // }
                let entry = GetWorldEntry(["手机-角色", "手机界面-角色"], true);
                console.log('找到的世界书条目:', entry);
                
                // 如果GetWorldEntry失败，尝试直接查找
                if (!entry || !entry.content) {
                    console.log('GetWorldEntry失败，尝试直接查找...');
                    for (let e of entries || []) {
                        console.log(`检查条目: ${e.comment}`);
                        if (e.comment === "手机-角色" || e.comment === "手机界面-角色") {
                            console.log('直接查找找到条目:', e);
                            entry = e;
                            break;
                        }
                    }
                }
                
                if (!entry || !entry.content) {
                    console.error('仍然未找到手机-角色世界书条目或内容为空');
                    console.error('当前entry:', entry);
                    return;
                }
                content = entry.content;
                console.log('世界书内容长度:', content.length);
                console.log(`获取到的角色信息:${content}`);
                QQ_CharSettings.loadText(content);
                console.log(`GetAllText:\n${QQ_CharSettings.getAllText()}`);
                const allSections = QQ_CharSettings.getAllSections();
                console.log('所有解析的段落:', allSections);
                for (let section of allSections) {
                    const hasGetCharAvatar =
                        typeof getCharAvatarPath === "function"; // 核心检查逻辑
                    const type = QQ_CharSettings.readValue(section, "类型");
                    if (section == "char") {
                        section = getFilenameWithoutExtension(charAvatarPath);
                    }
                    let headurl = QQ_CharSettings.readValue(section, "头像");
                    if (!headurl) {
                        if (hasGetCharAvatar) {
                            headurl = await getCharAvatarPath(section);
                        } else {
                            QQ_Error(
                                `自动获取头像要求前端助手版本在2.4.4及以上版本`,
                            );
                            continue;
                        }
                    } else {
                        const match = headurl.match(/[<{]+(.+?)[>}]/);
                        if (match) {
                            if (hasGetCharAvatar) {
                                headurl = await getCharAvatarPath(match[1]);
                            } else {
                                QQ_Error(
                                    `自动获取头像要求前端助手版本在2.4.4及以上版本`,
                                );
                                continue;
                            }
                        }
                    }
                    if (!type.match(/npc/i) && type != "路人" && type != "群聊") {
                        // 只处理私聊角色，群聊由独立的loadGroupChatsFromWorldbook函数处理
                        console.log(`准备添加角色: ${section}, 类型: ${type}`);
                        AddNewChar(section, headurl);
                        QQ_msgjson.私聊[`${UserName}和${section}的聊天`] = [];
                        } else {
                        console.log(`跳过角色: ${section}, 类型: ${type}`);
                    }
                    console.log(`角色${section}的头像:${headurl}`);
                    let CssValue = new Map();
                    let divkey = `.QQ_chat_msgdiv[data-name='${section}']`;
                    let MsgColor = QQ_CharSettings.readValue(
                        section,
                        "气泡颜色",
                    );
                    if (MsgColor) {
                        MsgColor =
                            MsgColor[0] == "#" ? MsgColor : `#${MsgColor}`;
                        CssValue.set(
                            divkey,
                            `--MsgColor: ${MsgColor};
        background-color: var(--MsgColor) !important; `,
                        );
                        console.log(
                            `设置了角色 ${section} 的气泡颜色:${MsgColor}`,
                        );
                    }
                    let TextColor = QQ_CharSettings.readValue(
                        section,
                        "字体颜色",
                    );
                    if (TextColor) {
                        TextColor =
                            TextColor[0] == "#" ? TextColor : `#${TextColor}`;
                        if (CssValue.has(divkey)) {
                            CssValue.set(
                                divkey,
                                CssValue.get(divkey) +
                                    `--TextColor: ${TextColor};`,
                            );
                        }
                        CssValue.set(
                            `.QQ_chat_msgdiv[data-name='${section}'] span`,
                            `color:var(--TextColor) !important;`,
                        );
                        console.log(
                            `设置了角色 ${section} 的字体颜色:${TextColor}`,
                        );
                    }
                    let BackGroundImg = QQ_CharSettings.readValue(
                        section,
                        "聊天壁纸",
                    );
                    if (BackGroundImg) {
                        CssValue.set(
                            `.QQ_chat_page[data-name='${section}']`,
                            `--BackGroundImg: url('${BackGroundImg}');
        background-image:var(--BackGroundImg) !important;`,
                        );
                        console.log(
                            `设置了角色 ${section} 的聊天壁纸:${BackGroundImg}`,
                        );
                    }
                    if (headurl) {
                        CssValue.set(
                            `.head[data-name=${section}]`,
                            `background-image:url('${headurl}')`,
                        );
                        console.log(`添加headurl`);
                    }
                    if (CssValue) {
                        let value = "";
                        for (const key of CssValue.keys()) {
                            value += `\n${key}{${CssValue.get(key)}}`;
                        }
                        if (value) {
                            $(`<style>`)
                                .attr("data-name", section)
                                .text(value)
                                .appendTo("head");
                            //console.log(`设置css:\n${value}`);
                        }
                    }
                    //console.log(`获取到的样式表:\n${$(`style[data-name='${section}']`).text()}`);
                }
                const style = $("<style></style>").prop("type", "text/css");
                const cssRule = chat_headraw_namespaceObject
                    .replace(/\$\{name\}/g, UserName)
                    .replace(/\$\{head\}/g, userAvatarPath);
                style.text(cssRule);
                $("head").append(style);
                
                // 加载保存的群聊数据
                console.log('LoadChars: 准备加载群聊数据, worldbook状态:', !!worldbook, 'QQ_Groups长度:', QQ_Groups.length);
                if (worldbook) {
                    console.log('LoadChars: 开始加载群聊数据');
                    await loadGroupChatsFromWorldbook();
                } else {
                    console.log('LoadChars: 跳过群聊加载 - worldbook未初始化');
                }
                
                // 注释：清理重复群聊已移除，避免误删新创建的群聊
                // setTimeout(async () => {
                //     await cleanupDuplicateGroups();
                // }, 500);
            }
            
            /**
             * 从手机-角色中随机选择一个聊天壁纸
             */
            function getRandomChatBackground() {
                try {
                    console.log('开始获取随机聊天壁纸...');
                    
                    // 获取世界书条目
                    const entry = GetWorldEntry(["手机-角色", "手机界面-角色"], true);
                    if (!entry || !entry.content) {
                        console.log('无法获取角色配置，使用默认壁纸');
                        console.log('entry:', entry);
                        return 'http://sharkpan.xyz/f/mM2SW/Screenshot_20250317_001012.jpg';
                    }
                    
                    console.log('成功获取到角色配置条目，内容长度:', entry.content.length);
                    
                    // 解析配置
                    const settings = new QQ_Settings();
                    settings.loadText(entry.content);
                    const allSections = settings.getAllSections();
                    
                    console.log('解析得到的角色sections数量:', allSections.length);
                    
                    // 收集所有有聊天壁纸的非群聊角色
                    const availableBackgrounds = [];
                    
                    for (const section of allSections) {
                        const type = settings.readValue(section, "类型");
                        const backgroundImg = settings.readValue(section, "聊天壁纸");
                        
                        console.log(`检查角色 ${section}: 类型=${type}, 聊天壁纸=${backgroundImg ? '有' : '无'}`);
                        
                        // 排除群聊、路人、NPC类型
                        if (!type || (type.trim() !== '群聊' && type.trim() !== '路人' && !type.match(/npc/i))) {
                            if (backgroundImg && backgroundImg.trim()) {
                                availableBackgrounds.push({
                                    character: section,
                                    url: backgroundImg.trim()
                                });
                                console.log(`收集到角色 ${section} 的聊天壁纸: ${backgroundImg.trim()}`);
                            }
                        }
                    }
                    
                    console.log('总共收集到', availableBackgrounds.length, '个可用的聊天壁纸');
                    
                    // 如果找到了壁纸，随机选择一个
                    if (availableBackgrounds.length > 0) {
                        const randomChoice = availableBackgrounds[Math.floor(Math.random() * availableBackgrounds.length)];
                        console.log(`为群聊随机选择了来自角色 "${randomChoice.character}" 的聊天壁纸: ${randomChoice.url}`);
                        return randomChoice.url;
                    }
                    
                } catch (error) {
                    console.error('随机选择聊天壁纸时出错:', error);
                }
                
                // 如果没有找到或出错，返回默认壁纸
                console.log('没有找到可用的聊天壁纸，使用默认壁纸');
                return 'http://sharkpan.xyz/f/mM2SW/Screenshot_20250317_001012.jpg';
            }
            
            /**
             * 为群聊添加初始欢迎消息（已移动到后面，此处删除重复函数）
             */
            
            function SetCssVariable(name, variable, value) {
                let cssvalue = $(`style[data-name='${name}']`).text();
                if (!cssvalue) {
                    return;
                }
                const match = cssvalue.match(
                    new RegExp(`--${variable}\s*:\s*(.+?);`),
                );
                if (!match) {
                    return;
                }
                cssvalue = cssvalue
                    .replace(
                        `${match[0]}`,
                        `${match[0].replace(match[1], value)}`,
                    )
                    .trim();
                console.log(`更新后的css:\n${cssvalue}`);
                $(`style[data-name='${name}']`).text(cssvalue);
            }
            /**
             * 聊天-添加新角色到列表
             * @param {*} name
             * @param {*} head
             */
            function AddNewChar(name, head) {
                console.log(`添加新角色:${name}  ${head}`);
                let html = _.template(chat_list_item)({
                    name: name,
                    head: head.trim(),
                });
                $("#QQ_home_chars").append(html);
                QQ_pages.push(name);
                const style = $("<style></style>").prop("type", "text/css");
                const cssRule = chat_headraw_namespaceObject
                    .replace(/\$\{name\}/g, name)
                    .replace(/\$\{head\}/g, head);
                style.text(cssRule);
                $("head").append(style);
                //System_AddNpcHead(name, head);
                
                // 更新消息列表
                setTimeout(() => {
                    QQ_UpdateMessageList();
                }, 100);
            }
            
            /**
             * 添加新群聊（完全基于私聊逻辑）
             */
             function AddNewGroup(name, head, members, description) {
                console.log(`添加/更新群聊:${name}  |  成员:${members.length}人  |  描述:${description}`);

                // *** 新增：预检查，如果群聊已初始化且有消息数据，谨慎处理 ***
                if (QQ_GroupInitializedSet.has(name) && QQ_msgjson.群聊[name] && QQ_msgjson.群聊[name].msgs.length > 0) {
                    console.log(`群聊 ${name} 已初始化且有消息数据，检查是否需要重新创建界面`);
                    
                    const existingElements = $(`.QQ_home_usermsg[data-name='${name}'][data-group-type='true']`);
                    if (existingElements.length > 0) {
                        console.log(`群聊 ${name} 界面已存在且数据完整，跳过AddNewGroup操作`);
                        return; // 完全跳过，避免任何重复操作
                    } else {
                        console.log(`群聊 ${name} 数据存在但界面不存在，仅重建界面`);
                        // 界面不存在时才重建，但绝对不重新添加初始消息
                    }
                }

                const existingElements = $(`.QQ_home_usermsg[data-name='${name}'][data-group-type='true']`);
                if (existingElements.length > 0) {
                    console.log(`找到同名群聊，执行更新操作`);
                    existingElements.remove();
                }

                // *** 修复：确保head是字符串，如果是对象则处理为合适的字符串 ***
                let headStr = '';
                if (typeof head === 'string') {
                    headStr = head.trim();
                } else if (head && typeof head === 'object') {
                    // 如果是头像对象，提取合适的值
                    if (head.type === 'upload' && head.imageData) {
                        headStr = head.imageData;
                    } else if (head.type === 'preset' && head.text) {
                        headStr = head.text;
                    } else if (head.type === 'url' && head.url) {
                        headStr = head.url;
                    } else {
                        headStr = 'https://files.catbox.moe/skngqq.jpg'; // 默认头像
                    }
                } else {
                    headStr = head || 'https://files.catbox.moe/skngqq.jpg'; // 默认头像
                }
                
                let html = _.template(chat_list_item)({ name: name, head: headStr });
                const $html = $(html);
                $html.attr('data-group-type', 'true').attr('data-group-name', name).attr('draggable', 'true');
                
                // *** 修复：不要硬编码群聊显示，稍后会通过updateGroupLastMessageDisplay更新 ***
                // 临时设置初始显示，防止空白
                const memberCount = members ? members.length : 0;
                $html.find('.QQ_home_lastmsg').text('群聊');
                $html.find('.QQ_home_lasttime').text(`${memberCount}人`);

                $html.on('click', function() {
                    console.log('群聊被点击:', name);
                    QQ_ChangeChatPage(null, name);
                });

                const $contactsContainer = $("#QQ_home_chars");
                let $ungroupedSection = $contactsContainer.find('.ungrouped-contacts');
                if ($ungroupedSection.length === 0) {
                    $ungroupedSection = $(`<div class="ungrouped-contacts"><div class="ungrouped-header">未分组联系人</div><div class="drop-zone ungrouped-drop-zone" data-group-id="ungrouped"></div></div>`);
                    $contactsContainer.prepend($ungroupedSection);
                }
                $ungroupedSection.append($html);
                
                QQ_pages.push(name);
                if (!QQ_Groups.includes(name)) {
                    QQ_Groups.push(name);
                }

                if (!QQ_msgjson.群聊[name]) {
                    QQ_msgjson.群聊[name] = { msgs: [], members: [] };
                }
                QQ_msgjson.群聊[name].members = members || [];

                const randomBackground = getRandomChatBackground();
                let cssRule = chat_headraw_namespaceObject.replace(/\$\{name\}/g, name).replace(/\$\{head\}/g, headStr);
                
                if (randomBackground) {
                    const backgroundCSS = `
.QQ_chat_page[data-name='${name}'] {
    --BackGroundImg: url('${randomBackground}');
    background-image: var(--BackGroundImg) !important;
}`;
                    cssRule += backgroundCSS;
                }

                const style = $("<style></style>").prop("type", "text/css");
                style.text(cssRule);
                $("head").append(style);
                
                // *** 核心改动：直接在此处生成欢迎消息 ***
                addGroupWelcomeMessages(name, members);

                // *** 修复：在创建群聊后立即更新最后消息显示 ***
                setTimeout(() => {
                    updateGroupLastMessageDisplay(name);
                    QQ_UpdateMessageList();
                }, 100);

                console.log(`群聊 ${name} 创建/更新流程完成`);
            }

            /**
             * 为群聊添加初始欢迎消息 (强化防重复版本)
             */
            function addGroupWelcomeMessages(groupName, members) {
                console.log(`addGroupWelcomeMessages 被调用: ${groupName}`);
                
                // *** 第一层检查：Session级防重复机制 ***
                if (QQ_GroupInitializedSet.has(groupName)) {
                    console.log(`群聊 ${groupName} 在当前会话中已初始化过，跳过添加`);
                    return;
                }
                
                if (!QQ_msgjson.群聊[groupName]) {
                    QQ_msgjson.群聊[groupName] = { msgs: [], members: members || [] };
                }
                
                const groupData = QQ_msgjson.群聊[groupName];
                
                // *** 第二层检查：强化的系统初始消息检测机制 ***
                const hasInitialMessages = groupData.msgs.some(msg => {
                    if (typeof msg !== 'string') return false;
                    
                    // 检查是否为系统消息格式
                    if (!msg.startsWith('系统消息--')) return false;
                    
                    // 分割消息格式：系统消息--时间--内容
                    const parts = msg.split('--');
                    if (parts.length < 3) return false;
                    
                    const content = parts[2]; // 内容部分
                    
                    // 检查是否包含初始系统消息的关键内容
                    return content.includes('创建成功') || 
                           content.includes('加入了群聊') ||
                           content.includes('开始聊天吧') ||
                           /^\d{2}:\d{2}$/.test(content); // 纯时间消息格式
                });
                
                // *** 第三层检查：消息数量和内容综合判断 ***
                const hasSystemMessages = groupData.msgs.some(msg => 
                    typeof msg === 'string' && msg.startsWith('系统消息--')
                );
                
                // 如果已有初始消息或系统消息，立即标记并跳过
                if (hasInitialMessages || hasSystemMessages) {
                    console.log(`群聊 ${groupName} 已有系统初始消息，跳过添加`);
                    console.log(`现有消息列表 (前5条):`, groupData.msgs.slice(0, 5));
                    
                    // 立即标记为已初始化，防止后续重复检查
                    QQ_GroupInitializedSet.add(groupName);
                    return;
                }
                
                // *** 第四层检查：防止在有非系统消息时重复添加初始消息 ***
                const hasUserMessages = groupData.msgs.some(msg => 
                    typeof msg === 'string' && !msg.startsWith('系统消息--') && msg.includes('--')
                );
                
                if (hasUserMessages && groupData.msgs.length > 0) {
                    console.log(`群聊 ${groupName} 已有 ${groupData.msgs.length} 条用户消息，但缺少初始系统消息，谨慎添加`);
                    
                    // 在有用户消息但没有系统消息的情况下，仍然要检查是否真的需要添加
                    const firstMessage = groupData.msgs[0];
                    if (firstMessage && typeof firstMessage === 'string') {
                        // 如果第一条消息看起来像是旧的初始消息格式，跳过添加
                        if (firstMessage.includes('群聊') || firstMessage.includes('创建') || firstMessage.includes('加入')) {
                            console.log(`群聊 ${groupName} 第一条消息疑似初始消息，跳过添加:`, firstMessage);
                            QQ_GroupInitializedSet.add(groupName);
                            return;
                        }
                    }
                }

                console.log(`群聊 ${groupName} 确认需要添加初始系统消息`);

                const currentTime = new Date().toLocaleTimeString('zh-CN', { 
                    hour12: false, 
                    hour: '2-digit', 
                    minute: '2-digit' 
                });
                
                // 添加群聊创建系统消息
                const systemMsg = `系统消息--${currentTime}--群聊"${groupName}"创建成功，开始聊天吧！`;
                groupData.msgs.push(systemMsg);
                
                // 添加成员加入消息
                if (members && members.length > 0) {
                    members.forEach(member => {
                        const joinMsg = `系统消息--${currentTime}--${member} 加入了群聊`;
                        groupData.msgs.push(joinMsg);
                    });
                }
                
                // 添加时间系统消息
                const timeMsg = `系统消息--${currentTime}--${currentTime}`;
                groupData.msgs.push(timeMsg);
                
                // *** 立即标记为已初始化，防止任何后续的重复添加 ***
                QQ_GroupInitializedSet.add(groupName);
                
                // *** 立即更新群聊的最后消息和时间显示 ***
                updateGroupLastMessageDisplay(groupName);
                
                console.log(`为群聊 ${groupName} 成功添加了初始系统消息，当前消息总数: ${groupData.msgs.length}`);
            }
            
            /**
             * 更新群聊的最后消息和时间显示
             */
            function updateGroupLastMessageDisplay(groupName) {
                const groupData = QQ_msgjson.群聊[groupName];
                if (!groupData || !groupData.msgs || groupData.msgs.length === 0) {
                    return;
                }
                
                // 获取最后一条消息
                const lastMsgRaw = groupData.msgs[groupData.msgs.length - 1];
                const msgParts = lastMsgRaw.split('--');
                
                if (msgParts.length >= 3) {
                    const sender = msgParts[0];
                    const content = msgParts[1];
                    const time = msgParts[2] || '';
                    
                    let displayMsg = content;
                    let displayTime = time;
                    
                    // 如果是系统消息，直接显示内容
                    if (sender === '系统消息') {
                        displayMsg = content;
                    } else {
                        // 如果是用户消息，显示为 "发送者: 内容"
                        displayMsg = `${sender}: ${content}`;
                    }
                    
                    // 限制消息长度避免界面过宽
                    if (displayMsg.length > 20) {
                        displayMsg = displayMsg.substring(0, 20) + '...';
                    }
                    
                    // 更新界面显示
                    $(`.QQ_home_usermsg[data-name='${groupName}'] .QQ_home_lastmsg`).text(displayMsg);
                    $(`.QQ_home_usermsg[data-name='${groupName}'] .QQ_home_lasttime`).text(displayTime);
                    
                    console.log(`群聊 ${groupName} 最后消息已更新: ${displayMsg} (${displayTime})`);
                }
            }
            
            function getFilenameWithoutExtension(path) {
                // 解码URI组件（处理特殊字符）
                const decodedPath = decodeURIComponent(path);
                // 分割路径并获取文件名部分
                const filename = decodedPath.split("/").pop();
                // 找到最后一个点的位置
                const lastDotIndex = filename.lastIndexOf(".");
                // 判断并截取文件名（无后缀）
                return lastDotIndex > 0
                    ? filename.slice(0, lastDotIndex)
                    : filename;
            }
            function QQ_page(id) {
                if (id == "message") {
                    console.log("点击了消息页");
                    $("#QQ_home_page").show();
                    $("#QQ_space_page").hide();
                    $(".QQ_chat_page").hide();
                    $("#QQ_message_svg").css("fill", "#019aff");
                    $("#QQ_people_svg").css("fill", "#000000");
                    $("#QQ_moment_svg").css("fill", "#000000");
                    $("#App_QQ").css("background-color", "#eff3ff");
                } else if (id == "people") {
                    console.log("点击了联系人");
                } else if (id == "moment") {
                    console.log("点击了动态页");
                    $("#QQ_home_page").hide();
                    $("#QQ_space_page").show();
                    $(".QQ_chat_page").hide();
                    $("#QQ_moment_svg").css("fill", "#019aff");
                    $("#QQ_people_svg").css("fill", "#000000");
                    $("#QQ_message_svg").css("fill", "#000000");
                    $("#App_QQ").css("background-color", "#ffffff");
                    QQ_SetNewTips(0);
                    QQ_NewMsg["moment"] = 0;
                    $(".new_tips").hide();
                }
            }
            function QQ_SetNewTips(count) {
                let tips = $(".new_tips");
                tips.each(function () {
                    if (count == 0) {
                        $(this).css("display", "none");
                    } else {
                        $(this).css("display", "flex").text(count);
                    }
                });
            }
            
            async function QQ_UpdateMessageList() {
                console.log("开始更新消息列表");
                
                // 不再自动重新加载群聊，避免重复循环
                console.log('当前QQ_Groups状态:', QQ_Groups.length, '个群聊');
                
                const $messageChars = $("#QQ_message_list_chars");
                const $homeChars = $("#QQ_home_chars");
                
                // 清空消息页面的联系人列表
                $messageChars.empty();
                
                // 只复制联系人项目，不复制搜索框
                const $homeContacts = $homeChars.find('.QQ_home_usermsg');
                
                // 然后过滤，只显示有真实消息沟通过的联系人
                const contactedUsers = [];
                let firstContact = null;
                
                $homeContacts.each(function() {
                    const $contact = $(this);
                    const name = $contact.attr('data-name');
                    const $newMsgBadge = $contact.find('.QQ_home_usermsg_new');
                    const hasNewMessages = $newMsgBadge.is(':visible') && parseInt($newMsgBadge.text()) > 0;
                    const lastMsg = $contact.find('.QQ_home_lastmsg').text().trim();
                    const isGroup = $contact.attr('data-group-type') === 'true';
                    
                    if (!firstContact) {
                        firstContact = $contact.clone(true);
                    }
                    
                    // 检查是否有真实的消息记录
                    let hasRealMessageRecord = false;
                    
                    // 检查私聊记录
                    const privateChatKey = `${UserName}和${name}的聊天`;
                    if (QQ_msgjson && QQ_msgjson.私聊 && QQ_msgjson.私聊[privateChatKey] && QQ_msgjson.私聊[privateChatKey].length > 0) {
                        hasRealMessageRecord = true;
                    }
                    
                    // 检查群聊记录
                    if (QQ_msgjson && QQ_msgjson.群聊 && QQ_msgjson.群聊[name] && QQ_msgjson.群聊[name].msgs && QQ_msgjson.群聊[name].msgs.length > 0) {
                        hasRealMessageRecord = true;
                    }
                    
                    // 检查未读消息数量（必须大于0且可见）
                    const hasUnreadCount = hasNewMessages && parseInt($newMsgBadge.text()) > 0;
                    
                    // 群聊特殊处理：如果是群聊且在QQ_Groups中，则显示
                    if (isGroup) {
                        if (QQ_Groups.includes(name)) {
                            console.log('添加群聊到消息列表:', name);
                            contactedUsers.push($contact.clone(true));
                        }
                    } else {
                        // 只有真正有消息记录或未读消息才显示
                    if (hasRealMessageRecord || hasUnreadCount) {
                        contactedUsers.push($contact.clone(true));
                        }
                    }
                });
                
                // 如果没有任何联系过的用户，只显示第一个联系人（贝尔法斯特）
                if (contactedUsers.length === 0 && firstContact) {
                    $messageChars.append(firstContact);
                } else {
                    contactedUsers.forEach(function($contact) {
                        $messageChars.append($contact);
                    });
                }
                
                console.log("消息列表更新完成");
            }
            function QQ_HideAllChat() {
                // for (let name of QQ_pages) {
                //   let $page = $(`#QQ_chat_${name}`);
                //   if ($page.length === 0) {
                //     continue;
                //   }
                //   $page.hide();
                // }
                $(`.QQ_chat_page`).hide();
            }
            function QQ_ChangeChatPage(event, directName = null) {
                const $QQpage = $("#App_QQ");
                if ($QQpage.length === 0) {
                    console.log("获取QQpage失败");
                    return;
                }
                
                let name;
                if (directName) {
                    // 直接传入名称（用于群聊）
                    name = directName;
                } else {
                    // 从事件获取名称（用于私聊）
                    let element = event.currentTarget;
                    name = element.getAttribute("data-name") ?? "";
                }
                
                // 检查是否为群聊
                const isGroup = QQ_Groups.includes(name);
                console.log(`切换到聊天页: ${name}, 是否为群聊: ${isGroup}`);
                
                let $page = $(`.QQ_chat_page[data-name='${name}']`);
                if ($page.length === 0) {
                    console.log(`${name}的聊天页不存在,开始创建`);
                    $page = $(QQ_CreatChatPage(name));
                    $QQpage.append($page);
                }
                
                // 如果是群聊，设置特殊的CSS类和属性
                if (isGroup) {
                    $page.addClass('group-chat-page');
                    $page.attr('data-group-type', 'true');
                    
                    // 更新聊天页面的标题显示群聊信息
                    const $username = $page.find('#QQ_chat_username');
                    if ($username.length > 0) {
                        const groupData = QQ_msgjson.群聊[name];
                        const memberCount = groupData && groupData.members ? groupData.members.length : 0;
                        $username.html(`${name} <span style="font-size: 12px; color: #999; font-weight: normal;">(${memberCount}人)</span>`);
                    }
                    
                    // 确保群聊输入框有正确的类名和属性
                    const $input = $page.find('.QQ_chat_input');
                    $input.addClass('userInput');
                    $input.attr('data-name', name);
                }
                
                QQ_SetHomeTips(name, "0");
                
                // *** 新增：点击聊天时标记为已读 ***
                QQ_MarkAsRead(name);
                
                // *** 新增：页面切换时隐藏其他角色的精灵按钮，只保留当前角色的精灵 ***
                if (!isGroup) {
                    // 私聊页面，隐藏其他角色的精灵，显示当前角色的精灵
                    Object.keys(QQ_CharacterSpirits).forEach(characterName => {
                        if (characterName !== name) {
                            QQ_HideCharacterSpirit(characterName);
                        }
                    });
                } else {
                    // 群聊页面，隐藏所有角色精灵
                    QQ_HideAllCharacterSpirits();
                }
                
                QQ_HideAllChat();
                // 隐藏QQ主页和消息页面
                $("#QQ_home_page").hide();
                $("#QQ_message_list_page").hide();
                $("#QQ_space_page").hide();
                // 隐藏底部导航栏
                $(".QQ_bottom_nav").hide();
                $page.show();
                console.log(`显示聊天页:QQ_chat_${name}`);
                let $msgContent = $page.find(".msgcontent");
                $msgContent.scrollTop($msgContent[0].scrollHeight);
                let TipsCount = QQ_GetChatShowTipsCount(name);
                const $Tips = $page.find(`.new_tips`);
                $Tips.text(TipsCount);
                if (TipsCount > 0) {
                    $Tips.css("display", "flex");
                } else {
                    $Tips.hide();
                }
            }
            /**
             * 创建聊天页
             * @param name 聊天页名称
             * @returns 聊天页HTML
             */
             function QQ_CreatChatPage(name) {
                console.log(`创建聊天页: ${name}`);
                const isGroup = QQ_Groups.includes(name);
                
                // 使用模板创建页面
                let $page = $(_.template(chat_page)({
                    name: name,
                    isGroup: isGroup,
                    members: isGroup ? (QQ_msgjson.群聊[name]?.members || []).join(', ') : ''
                }));

                // *** 核心修复：创建页面后，立即加载并显示已有消息（支持分页） ***
                const $msgContent = $page.find(".msgcontent");
                let allMessages = [];
                
                if (isGroup && QQ_msgjson.群聊[name] && QQ_msgjson.群聊[name].msgs) {
                    allMessages = QQ_msgjson.群聊[name].msgs;
                } else if (!isGroup && QQ_msgjson.私聊[`${UserName}和${name}的聊天`]) {
                    allMessages = QQ_msgjson.私聊[`${UserName}和${name}的聊天`];
                }
                
                if (allMessages.length > 0) {
                    console.log(`为新创建的聊天 ${name} 加载消息，总数: ${allMessages.length}`);
                    
                    // 初始化显示计数
                    chatDisplayCounts[name] = 0;
                    
                    // 计算要显示的消息数量（从最新的开始，最多显示CHAT_DISPLAY_LIMIT条）
                    const startIndex = Math.max(0, allMessages.length - CHAT_DISPLAY_LIMIT);
                    const messagesToShow = allMessages.slice(startIndex);
                    
                    // 添加消息到界面
                    messagesToShow.forEach(msg => {
                        QQ_Chat_AddMsg($msgContent[0], msg, name, false, true); // 跳过分页控制
                    });
                    
                    // 更新显示计数
                    chatDisplayCounts[name] = messagesToShow.length;
                    
                    // 添加"加载更多"按钮（如果需要）
                    QQ_Update_Chat_LoadMore(name, $msgContent[0]);
                    
                    console.log(`聊天页面加载完成: 显示 ${messagesToShow.length}/${allMessages.length} 条消息`);
                }
                
                // 滚动到底部
                $msgContent.scrollTop($msgContent[0].scrollHeight);

                return $page;
            }
            function QQ_Msg_DelUserKey(content) {
                let json = JsonYamlParse(content);
                if (!json) {
                    return content;
                }
                let others = "";
                if (`${UserName}` in json.私聊 == false) {
                    return content;
                }
                for (let msg of json.私聊[`${UserName}`]) {
                    const sp = msg.split("--");
                    if (sp.length <= 0) {
                        continue;
                    }
                    if (sp[0] != `${UserName}`) {
                        if (!others) {
                            others = sp[0];
                        } else if (sp[0] != others) {
                            // 出现第三个名字,过于复杂不做处理
                            return content;
                        }
                    }
                }
                if (!others) {
                    // 没取到对方名字
                    if (json.私聊[`${UserName}`].length == 0) {
                        delete json.私聊[`${UserName}`];
                        return JSON.stringify(json);
                    }
                    return content;
                }
                if (others in json.私聊 == false) {
                    // 不存在对方名字键,直接改名
                    const newvalue = json.私聊[`${UserName}`];
                    delete json.私聊[`${UserName}`];
                    json.私聊[others] = newvalue;
                    return JSON.stringify(json);
                } else if (json.私聊[others].length == 0) {
                    // 存在但为空
                    const newvalue = json.私聊[`${UserName}`];
                    delete json.私聊[`${UserName}`];
                    json.私聊[others] = newvalue;
                    return JSON.stringify(json);
                }
                return content;
            }
            function QQ_AddNpcHead(content) {
                let json = JsonYamlParse(content);
                if (!json) {
                    return content;
                }
                // 头像修复
                const Sections = QQ_CharSettings.getAllSections();
                let newcss = "";
                for (let str in json.私聊) {
                    for (const msg of json.私聊[str]) {
                        const sp = msg.split("--");
                        if (sp.length <= 1) {
                            continue;
                        }
                        const name = sp[0];
                        if (!Sections.includes(name) && name != `${UserName}`) {
                            // 路人,设置随机头像
                            System_AddNpcHead(name);
                        }
                    }
                }
                for (let Group in json.群聊) {
                    for (const msg of json.群聊[Group].msgs) {
                        const sp = msg.split("--");
                        if (sp.length <= 0) {
                            continue;
                        }
                        const name = sp[0];
                        if (!Sections.includes(name) && name != `${UserName}`) {
                            // 路人,设置随机头像
                            System_AddNpcHead(name);
                        }
                    }
                }
            }
            function QQ_Msg_Repair(content) {
                let json = JsonYamlParse(content);
                if (!json) {
                    return content;
                }
                // 修正顺序
                for (let str in json.私聊) {
                    const match = str.match(/(.+?)和(.+?)的聊天/);
                    if (!match) {
                        // 旧版本只有一个名字
                        if (str != `${UserName}`) {
                            const value = json.私聊[str];
                            delete json.私聊[str];
                            json.私聊[`${UserName}和${str}的聊天`] = value;
                        } else {
                            delete json.私聊[str];
                        }
                        continue;
                    }
                    if (
                        match[1] != `${UserName}` &&
                        match[2] != `${UserName}`
                    ) {
                        // 俩角色之间的私聊,属于特殊情况直接删了
                        console.log(`删除:${str}`);
                        delete json.私聊[str];
                        continue;
                    }
                    if (
                        match[1] != `${UserName}` &&
                        match[2] == `${UserName}`
                    ) {
                        // 顺序反了
                        const value = json.私聊[str];
                        delete json.私聊[str];
                        json.私聊[`${UserName}和${match[1]}的聊天`] = value;
                    }
                }
                // 修正网名
                const keys = QQ_CharSettings.getAllSections();
                for (let str in json.私聊) {
                    const match = str.match(/(.+?)和(.+?)的聊天/);
                    if (!match) {
                        continue;
                    }
                    // 不管有没有错先修正一次内容
                    let value = QQ_NickNameRepair(json.私聊[str]);
                    json.私聊[str] = value;
                    const localname = match[2];
                    if (!keys.includes(localname)) {
                        // 键名是用的网名,修正
                        for (const char of keys) {
                            let find = false;
                            const namelist = QQ_CharSettings.readValue(
                                char,
                                "网名",
                            ).split(",");
                            if (!namelist || namelist.length == 0) {
                                continue;
                            }
                            for (const name of namelist) {
                                const regex = createRegExp(name);
                                if (!name || !regex) {
                                    continue;
                                }
                                if (localname.match(regex)) {
                                    delete json.私聊[str];
                                    json.私聊[`${UserName}和${char}的聊天`] =
                                        value;
                                    find = true;
                                    break;
                                }
                            }
                            if (find) {
                                break;
                            }
                        }
                    }
                }
                for (const Group in json.群聊) {
                    json.群聊[Group].msgs = QQ_NickNameRepair(
                        json.群聊[Group].msgs,
                    );
                }
                QQ_AddNpcHead(JSON.stringify(json));
                return JSON.stringify(json);
            }
            function QQ_NickNameRepair(content) {
                if (!content || content.length == 0) {
                    return content;
                }
                let charlist = QQ_CharSettings.getAllSections();
                let result = [];
                for (let str of content) {
                    const match = str.match(/(.+?)--([\s\S]+)/);
                    if (match && match[1] != UserName) {
                        const localname = match[1];
                        if (!charlist.includes(localname)) {
                            for (const char of charlist) {
                                let find = false;
                                const namelist = QQ_CharSettings.readValue(
                                    char,
                                    "网名",
                                ).split(",");
                                if (!namelist || namelist.length == 0) {
                                    continue;
                                }
                                for (const name of namelist) {
                                    if (!name) {
                                        continue;
                                    }
                                    if (name.match(/^\/(.+)\/([gimuy]*)$/)) {
                                        // 名字是正则表达式
                                        const regex = createRegExp(name);
                                        if (!regex) {
                                            continue;
                                        }
                                        if (localname.match(regex)) {
                                            str = `${char}--${match[2]}`;
                                            find = true;
                                            break;
                                        }
                                    } else {
                                        // 名字不是正则表达式
                                        if (namelist.includes(localname)) {
                                            str = `${char}--${match[2]}`;
                                            find = true;
                                            break;
                                        }
                                    }
                                }
                                if (find) {
                                    break;
                                }
                            }
                        }
                    }
                    result.push(str);
                }
                return result;
            }
            function createRegExp(pattern) {
                if (!pattern) return null;
                // 如果已经是RegExp对象，直接返回
                if (pattern instanceof RegExp) return pattern;
                try {
                    // 检查是否是 /pattern/flags 格式
                    const regexMatch = pattern.match(/^\/(.+)\/([gimuy]*)$/);
                    if (regexMatch) {
                        // 提取正则表达式的模式和标志
                        const [_, regexPattern, flags] = regexMatch;
                        return new RegExp(regexPattern, flags);
                    } else {
                        // 不带/的纯字符串格式，默认不加任何标志
                        return new RegExp(pattern);
                    }
                } catch (error) {
                    console.error("创建正则表达式失败:", error);
                    return null;
                }
            }
            /**
             * *** 新增：处理角色之间的私聊（不包含用户的角色间互动） ***
             * @param {string} chatKey - 聊天标识，如"角色A和角色B的聊天"
             * @param {Array} messages - 消息列表
             * @param {string} char1 - 角色1名称
             * @param {string} char2 - 角色2名称
             */
            async function QQ_HandleCharacterChat(chatKey, messages, char1, char2) {
                console.log(`处理角色间私聊: ${char1} 和 ${char2}`);
                
                if (!messages || messages.length === 0) {
                    console.log('角色间私聊消息为空，跳过处理');
                    return;
                }
                
                // 创建角色间私聊的标识
                const chatId = `char_chat_${char1}_${char2}`;
                const chatTitle = `${char1}和${char2}的私聊`;
                
                // 存储到专门的角色间私聊数据结构
                if (!window.QQ_CharacterChats) {
                    window.QQ_CharacterChats = {};
                }
                
                if (!window.QQ_CharacterChats[chatKey]) {
                    window.QQ_CharacterChats[chatKey] = {
                        id: chatId,
                        title: chatTitle,
                        char1: char1,
                        char2: char2,
                        messages: [],
                        lastTime: '',
                        lastMessage: ''
                    };
                }
                
                // 处理消息
                let lastTime = '';
                let lastMessage = '';
                for (let msg of messages) {
                    // 清理消息内容
                    const parts = msg.split("--");
                    if (parts.length >= 2) {
                        parts[1] = QQ_CleanNestedTags(parts[1]);
                        msg = parts.join("--");
                    }
                    
                    // 检查是否为新消息
                    if (!window.QQ_CharacterChats[chatKey].messages.includes(msg)) {
                        window.QQ_CharacterChats[chatKey].messages.push(msg);
                        console.log(`角色间私聊新增消息: ${msg}`);
                    }
                    
                    // 更新最后消息信息
                    const sp = msg.split("--");
                    if (sp.length >= 2) {
                        lastMessage = sp[1];
                    }
                    if (sp.length >= 3) {
                        lastTime = sp[2];
                    }
                }
                
                window.QQ_CharacterChats[chatKey].lastTime = lastTime;
                window.QQ_CharacterChats[chatKey].lastMessage = lastMessage;
                
                // 在联系人列表中显示角色间私聊
                QQ_CreateCharacterChatInterface(window.QQ_CharacterChats[chatKey]);
                
                // 保存到世界书
                await QQ_SaveCharacterChatToWorldbook(window.QQ_CharacterChats[chatKey]);
            }
            
            /**
             * *** 新增：创建角色间私聊的联系人界面（只读） ***
             * @param {Object} chatData - 角色间私聊数据
             */
            function QQ_CreateCharacterChatInterface(chatData) {
                const contactsContainer = $('#QQ_home_chars');
                if (!contactsContainer.length) {
                    console.error('找不到联系人容器');
                    return;
                }
                
                // 检查是否已存在
                const existingElement = contactsContainer.find(`[data-char-chat-id="${chatData.id}"]`);
                if (existingElement.length > 0) {
                    // 更新现有元素
                    existingElement.find('.QQ_home_lastmsg').text(chatData.lastMessage);
                    existingElement.find('.QQ_home_lasttime').text(chatData.lastTime);
                    return;
                }
                
                // 创建新的角色间私聊元素
                const chatElement = $(`
                    <div class="QQ_home_char" data-char-chat-id="${chatData.id}" data-char-chat="true">
                        <div class="QQ_home_head">
                            <div class="QQ_home_avatar" style="background: linear-gradient(135deg, #9C27B0, #673AB7); border-radius: 50%; width: 50px; height: 50px; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 14px;">
                                💬
                            </div>
                        </div>
                        <div class="QQ_home_info">
                            <div class="QQ_home_name" style="color: #9C27B0; font-weight: bold;">${chatData.title}</div>
                            <div class="QQ_home_lastmsg">${chatData.lastMessage}</div>
                        </div>
                        <div class="QQ_home_time">
                            <div class="QQ_home_lasttime">${chatData.lastTime}</div>
                            <div class="QQ_readonly_badge" style="background: #9C27B0; color: white; font-size: 10px; padding: 2px 6px; border-radius: 10px; margin-top: 5px;">只读</div>
                        </div>
                    </div>
                `);
                
                // 添加点击事件（只读查看）
                chatElement.on('click', function() {
                    QQ_ShowCharacterChatDialog(chatData);
                });
                
                // 添加到联系人列表
                contactsContainer.append(chatElement);
                console.log(`角色间私聊界面已创建: ${chatData.title}`);
            }
            
            /**
             * *** 新增：显示角色间私聊的只读对话框 ***
             * @param {Object} chatData - 角色间私聊数据
             */
            function QQ_ShowCharacterChatDialog(chatData) {
                // 创建只读对话框
                const dialogHtml = `
                    <div id="char-chat-dialog" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 9999; display: flex; align-items: center; justify-content: center;">
                        <div style="background: white; border-radius: 15px; width: 90%; max-width: 400px; max-height: 80%; display: flex; flex-direction: column; overflow: hidden;">
                            <div style="padding: 15px; background: linear-gradient(135deg, #9C27B0, #673AB7); color: white; display: flex; align-items: center; justify-content: space-between;">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <div style="width: 30px; height: 30px; background: rgba(255,255,255,0.2); border-radius: 50%; display: flex; align-items: center; justify-content: center;">💬</div>
                                    <div>
                                        <div style="font-weight: bold; font-size: 16px;">${chatData.title}</div>
                                        <div style="font-size: 12px; opacity: 0.8;">角色间私聊（只读）</div>
                                    </div>
                                </div>
                                <button id="close-char-chat" style="background: none; border: none; color: white; font-size: 20px; cursor: pointer; padding: 5px;">×</button>
                            </div>
                            <div style="flex: 1; overflow-y: auto; padding: 15px; background: #f5f5f5;">
                                <div id="char-chat-messages"></div>
                            </div>
                            <div style="padding: 10px; background: #e0e0e0; text-align: center; color: #666; font-size: 12px;">
                                📖 这是角色之间的私聊，您只能查看不能回复
                            </div>
                        </div>
                    </div>
                `;
                
                // 移除现有对话框
                $('#char-chat-dialog').remove();
                
                // 添加新对话框
                $('body').append(dialogHtml);
                
                // 渲染消息
                const messagesContainer = $('#char-chat-messages');
                chatData.messages.forEach(msg => {
                    const parts = msg.split('--');
                    if (parts.length >= 2) {
                        const sender = parts[0];
                        const content = parts[1];
                        const time = parts.length >= 3 ? parts[2] : '';
                        
                        const messageHtml = `
                            <div style="margin-bottom: 15px;">
                                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 5px;">
                                    <div style="font-weight: bold; color: #9C27B0;">${sender}</div>
                                    <div style="font-size: 11px; color: #999;">${time}</div>
                                </div>
                                <div style="background: white; padding: 10px; border-radius: 10px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                                    ${content}
                                </div>
                            </div>
                        `;
                        messagesContainer.append(messageHtml);
                    }
                });
                
                // 滚动到底部
                messagesContainer.scrollTop(messagesContainer[0].scrollHeight);
                
                // 绑定关闭事件
                $('#close-char-chat, #char-chat-dialog').on('click', function(e) {
                    if (e.target === this) {
                        $('#char-chat-dialog').remove();
                    }
                });
            }
            
            /**
             * *** 新增：保存角色间私聊到世界书 ***
             * @param {Object} chatData - 角色间私聊数据
             */
            async function QQ_SaveCharacterChatToWorldbook(chatData) {
                try {
                    // 使用简单的世界书检查
                    if (!worldbook || !entries) {
                        console.warn('世界书功能不可用，无法保存角色间私聊');
                        return false;
                    }
                    
                    const entryKey = `QQ_角色间私聊_${chatData.char1}_${chatData.char2}`;
                    const uniqueComment = `手机-角色间私聊-${chatData.char1}和${chatData.char2}`;
                    
                    // 查找现有条目
                    let existingEntry = entries.find(e => e.comment === uniqueComment);
                    
                    // 构建保存内容
                    const saveContent = JSON.stringify({
                        id: chatData.id,
                        title: chatData.title,
                        char1: chatData.char1,
                        char2: chatData.char2,
                        messages: chatData.messages,
                        lastTime: chatData.lastTime,
                        lastMessage: chatData.lastMessage,
                        timestamp: new Date().toISOString()
                    });
                    
                    if (existingEntry) {
                        // 更新现有条目
                        await setLorebookEntries(worldbook, [{
                            uid: existingEntry.uid,
                            content: saveContent
                        }]);
                        console.log(`角色间私聊已更新到世界书: ${chatData.title}`);
                    } else {
                        // 创建新条目
                        await createLorebookEntry(worldbook, {
                            comment: uniqueComment,
                            key: [entryKey],
                            content: saveContent,
                            position: 0,
                            disable: false,
                            addMemo: false,
                            order: 1000,
                            depth: 4,
                            selectiveLogic: 0,
                            excludeRecursion: false,
                            delayUntilRecursion: false,
                            probability: 100,
                            useProbability: false
                        });
                        console.log(`角色间私聊已保存到世界书: ${chatData.title}`);
                    }
                    
                    return true;
                } catch (error) {
                    console.error('保存角色间私聊到世界书失败:', error);
                    return false;
                }
            }

            /**
             * 初始化时解析聊天消息
             * @param content 聊天消息内容
             */
            async function QQ_Msg_Parse(content) {
                //content = QQ_Msg_Repair(content);
                console.log(`开始解析聊天消息:${content}`);
                let hasstr = false;
                if (content.match(/\S/)) {
                    hasstr = true;
                }
                let json = JsonYamlParse(content);
                if (!json) {
                    if (hasstr) {
                        QQ_Error(`解析聊天记录失败,请手动解决`);
                    }
                    // QQ_Error(`yaml解析失败`);
                    return;
                }
                console.log(`解析成功时的聊天消息:${JSON.stringify(json)}`);
                const $QQpage = $("#App_QQ");
                if ($QQpage.length === 0) {
                    console.log("获取QQpage失败");
                    return;
                }
                for (let str in json.私聊) {
                    const match = str.match(/(.+?)和(.+?)的聊天/);
                    if (!match) {
                        continue;
                    }
                    // *** 首先检查：角色之间的私聊（不包含用户） ***
                    if (match[1] !== `${UserName}` && match[2] !== `${UserName}`) {
                        console.log(`检测到角色间私聊: ${match[1]} 和 ${match[2]}`);
                        await QQ_HandleCharacterChat(str, json.私聊[str], match[1], match[2]);
                        continue;
                    }
                    
                    // *** 处理用户参与的私聊 ***
                    let name = "";
                    if (match[1] != `${UserName}`) {
                        name = match[1];
                    } else if (match[2] != `${UserName}`) {
                        name = match[2];
                    } else {
                        // 两个参与者都是用户，跳过
                        continue;
                    }
                    try {
                        if (!QQ_msgjson.私聊[str]) {
                            QQ_msgjson.私聊[str] = [];
                        }
                        if (!QQ_NewMsg[name]) {
                            QQ_NewMsg[name] = {};
                        }
                        if (
                            !$(`.QQ_home_usermsg[data-name='${name}']`)
                                .length &&
                            name != `${UserName}`
                        ) {
                            console.log(`${name}的主页不存在,开始创建`);
                            AddNewChar(name, "");
                        }
                        let $page = $(`.QQ_chat_page[data-name='${name}']`);
                        let Creat = false;
                        if ($page.length === 0) {
                            Creat = true;
                            console.log(`${name}的聊天页不存在,开始创建123`);
                            $page = $(QQ_CreatChatPage(`${name}`));
                            $QQpage.append($page);
                        }
                        if (json.私聊[str].length == 0) {
                            continue;
                        }
                        let $msgContent = $page.find(".msgcontent");
                        let NewMsgCount = 0;
                        let LastTime = "";
                        let LastMsg = "";
                        for (let msg of json.私聊[str]) {
                            // *** 新增：清理私聊消息内容 ***
                            const parts = msg.split("--");
                            if (parts.length >= 2) {
                                parts[1] = QQ_CleanNestedTags(parts[1]);
                                msg = parts.join("--");
                            }
                            
                            // 检查是否为新消息（不在现有消息列表中）
                            const isNewMsg = !QQ_msgjson.私聊[str].includes(msg);
                            QQ_Chat_AddMsg($msgContent[0], msg, name, isNewMsg);
                            QQ_msgjson.私聊[str].push(msg);
                            let sp = msg.split("--");
                            if (sp.length >= 2) {
                                if (sp[0] == `${UserName}`) {
                                    User_LastMsgMap.私聊[name] =
                                        `${sp[0]}--${sp[1]}`;
                                } else if (sp[0] == name) {
                                    if (sp.length >= 3) {
                                        Char_LastMsgMap.私聊[name] =
                                            `${sp[0]}--${sp[1]}--${sp[2]}`;
                                    } else {
                                        Char_LastMsgMap.私聊[name] =
                                            `${sp[0]}--${sp[1]}`;
                                    }
                                }
                            }
                            if (sp.length >= 3) {
                                LastTime = sp[2];
                            }
                            LastMsg = sp[1];
                        }
                        
                        // *** 新的未读消息计算逻辑：使用QQ_CalculateUnreadCount ***
                        NewMsgCount = QQ_CalculateUnreadCount(name, QQ_msgjson.私聊[str], 'private');
                        console.log(`私聊 ${name} 计算未读消息: ${NewMsgCount}`);
                        // 设置红点和首页显示的消息
                        if (
                            $(`.QQ_chat_page[data-name='${name}']`).css(
                                "display",
                            ) != "none" &&
                            !Creat
                        ) {
                            console.log(`display不为none,红点为0  ${name}`);
                            NewMsgCount = 0;
                        }
                        $(
                            `.QQ_home_usermsg[data-name='${name}'] .QQ_home_lastmsg`,
                        ).text(LastMsg);
                        $(
                            `.QQ_home_usermsg[data-name='${name}'] .QQ_home_lasttime`,
                        ).text(LastTime);
                        QQ_SetHomeTips(name, NewMsgCount);
                        $msgContent.scrollTop($msgContent[0].scrollHeight);
                        
                        // *** 新增：更新分页按钮 ***
                        if (NewMsgCount > 0) {
                            QQ_Update_Chat_LoadMore(name, $msgContent[0]);
                        }
                        
                        // 有新消息时更新消息列表
                        QQ_UpdateMessageList();
                    } catch (error) {
                        throw error;
                        assertIsError(error);
                        //QQ_Error(error.message);
                    }
                }
                for (let name in json.群聊) {
                    try {
                        // *** 新增：清理群聊消息内容 ***
                        if (json.群聊[name]["msgs"]) {
                            json.群聊[name]["msgs"] = json.群聊[name]["msgs"].map(msg => {
                                const parts = msg.split("--");
                                if (parts.length >= 2) {
                                    // 清理消息内容部分（第二部分）
                                    parts[1] = QQ_CleanNestedTags(parts[1]);
                                    return parts.join("--");
                                }
                                return msg;
                            });
                        }
                        
                        if (!QQ_msgjson.群聊[name]) {
                            QQ_msgjson.群聊[name] = {};
                            QQ_msgjson.群聊[name]["members"] =
                                json.群聊[name]["members"];
                            QQ_msgjson.群聊[name]["msgs"] = [];
                        }
                        // 检查是否是已存在的群聊
                        let existingGroupElement = $(`.QQ_home_usermsg[data-name='${name}']`);
                        let isExistingGroup = false;
                        
                        // 检查是否在存储的群聊列表中
                        const storedGroups = await loadGroupChatsFromWorldbook();
                        const storedGroup = storedGroups.find(g => g.name === name);
                        
                        if (existingGroupElement.length > 0) {
                            // 群聊元素已存在
                            isExistingGroup = true;
                            console.log(`群聊 ${name} 已存在，使用现有群聊`);
                        } else if (storedGroup) {
                            // 群聊在存储中存在，但界面元素不存在，重新创建
                            console.log(`群聊 ${name} 在存储中存在，重新创建界面元素`);
                            AddNewGroup(storedGroup.name, storedGroup.avatar || 'https://files.catbox.moe/skngqq.jpg', storedGroup.members, storedGroup.description);
                            isExistingGroup = true;
                        } else {
                            // 这是一个全新的群聊，需要智能处理
                            console.log(`检测到新群聊: ${name}，开始智能路由处理`);
                            
                            let redirected = false;
                            
                            // 智能消息路由：检查消息中是否包含用户发送的内容
                            const hasUserMessage = json.群聊[name]["msgs"].some(msg => {
                                const parts = msg.split("--");
                                return parts.length >= 2 && parts[0] === `${UserName}`;
                            });
                            
                            // 如果包含用户消息，说明这是用户发起的对话，需要找到正确的目标群聊
                            if (hasUserMessage) {
                                console.log(`检测到用户在群聊 ${name} 中发送了消息，开始智能路由`);
                                
                                // 检查用户最后发送消息的群聊
                                let targetGroupName = null;
                                
                                // 方法1：检查User_LastMsgMap中最近的群聊消息
                                if (User_LastMsgMap.群聊) {
                                    const recentGroupChats = Object.keys(User_LastMsgMap.群聊);
                                    if (recentGroupChats.length > 0) {
                                        // 找到最近发送消息的群聊
                                        targetGroupName = recentGroupChats[recentGroupChats.length - 1];
                                        console.log(`从User_LastMsgMap找到目标群聊: ${targetGroupName}`);
                                    }
                                }
                                
                                // 方法2：检查当前可见的群聊页面
                                if (!targetGroupName) {
                                    const currentChatPage = $('.QQ_chat_page:visible, .group-chat-page:visible');
                                    if (currentChatPage.length > 0) {
                                        const currentChatName = currentChatPage.attr('data-name');
                                        const currentGroupId = currentChatPage.attr('data-group-id');
                                        
                                        if (currentGroupId) {
                                            // 从群聊ID找到群聊名称
                                            const groups = await loadGroupChatsFromWorldbook();
                                            const currentGroup = groups.find(g => g.id === currentGroupId);
                                            if (currentGroup) {
                                                targetGroupName = currentGroup.name;
                                                console.log(`从可见群聊页面找到目标群聊: ${targetGroupName}`);
                                            }
                                        } else if (QQ_Groups.includes(currentChatName)) {
                                            targetGroupName = currentChatName;
                                            console.log(`从可见聊天页面找到目标群聊: ${targetGroupName}`);
                                        }
                                    }
                                }
                                
                                // 方法3：检查window.currentGroupChat
                                if (!targetGroupName && window.currentGroupChat) {
                                    targetGroupName = window.currentGroupChat.name;
                                    console.log(`从window.currentGroupChat找到目标群聊: ${targetGroupName}`);
                                }
                                
                                // 如果找到了目标群聊且与AI回复的群聊不同，进行重定向
                                if (targetGroupName && targetGroupName !== name) {
                                    console.log(`消息路由重定向: ${name} -> ${targetGroupName}`);
                                    const originalName = name;
                                    name = targetGroupName;
                                    json.群聊[name] = json.群聊[originalName];
                                    delete json.群聊[originalName];
                                    isExistingGroup = true;
                                    redirected = true;
                                } else if (targetGroupName === name) {
                                    // 群聊名称匹配，直接使用
                                    console.log(`群聊名称匹配，直接使用: ${name}`);
                                    isExistingGroup = true;
                                    redirected = true;
                                } else {
                                    console.log(`无法确定目标群聊，跳过处理避免创建错误群聊`);
                                    toastr.warning(`无法确定消息发送的目标群聊，请重新发送`, '消息发送失败');
                                    continue;
                                }
                            } else {
                                // 没有用户消息，可能是AI主动创建的群聊
                                console.log(`AI创建新群聊: ${name}，检查是否应该重定向到当前群聊`);
                                
                                // 检查当前活跃的群聊
                                if (window.currentGroupChat) {
                                    console.log(`用户当前在群聊 ${window.currentGroupChat.name} 中，将AI消息重定向到此群聊`);
                                    const originalName = name;
                                    name = window.currentGroupChat.name;
                                    json.群聊[name] = json.群聊[originalName];
                                    delete json.群聊[originalName];
                                    isExistingGroup = true;
                                    redirected = true;
                                } else {
                                    // 检查可见的聊天页面
                                    const currentChatPage = $('.QQ_chat_page:visible, .group-chat-page:visible');
                                    if (currentChatPage.length > 0) {
                                        const currentChatName = currentChatPage.attr('data-name');
                                        const currentGroupId = currentChatPage.attr('data-group-id');
                                        
                                        // 如果是群聊页面
                                        if (currentGroupId || QQ_Groups.includes(currentChatName)) {
                                            console.log(`用户当前在群聊页面 ${currentChatName} 中，将AI消息重定向到此群聊`);
                                            const originalName = name;
                                            name = currentChatName;
                                            json.群聊[name] = json.群聊[originalName];
                                            delete json.群聊[originalName];
                                            isExistingGroup = true;
                                            redirected = true;
                                        }
                                    }
                                }
                            }
                            
                            // 如果没有成功重定向，说明这是一个新的AI创建的群聊
                            if (!redirected) {
                                console.log(`AI创建新群聊: ${name}，参考私聊逻辑进行处理`);
                                
                                // 创建群聊数据结构
                                const newGroupData = {
                                    id: `group_${Date.now()}`,
                                    name: name,
                                    members: json.群聊[name]["members"] || [],
                                    avatar: {
                                        type: 'preset',
                                        gradient: {
                                            start: '#199AFF',
                                            end: '#0066CC'
                                        },
                                        text: '群'
                                    },
                                    lastMessage: '群聊已创建',
                                    lastTime: new Date().toLocaleTimeString('zh-CN', { hour12: false }).slice(0, 5),
                                    timestamp: new Date().toLocaleTimeString('zh-CN', { hour12: false }).slice(0, 5)
                                };
                                
                                // 调用AddNewGroup函数（类似AddNewChar）
                                AddNewGroup(newGroupData.name, newGroupData.avatar, newGroupData.members, newGroupData.lastMessage);
                                
                                // *** 新增：将AI创建的新群聊保存到世界书 ***
                                try {
                                    console.log(`保存AI创建的新群聊到世界书: ${newGroupData.name}`);
                                    await saveGroupToWorldbook(newGroupData);
                                    console.log(`AI创建的群聊 ${newGroupData.name} 已成功保存到世界书`);
                                    toastr.success(`新群聊 "${newGroupData.name}" 已创建并保存`, '群聊创建成功');
                                } catch (error) {
                                    console.error('保存AI创建的群聊到世界书失败:', error);
                                    toastr.warning(`群聊 "${newGroupData.name}" 已创建，但保存到世界书失败`, '部分成功');
                                }
                                
                                isExistingGroup = true;
                            }
                        }
                        
                        // 只有确认是现有群聊时才继续处理
                        if (!isExistingGroup) {
                            continue;
                        }
                        if (!QQ_Groups.includes(name)) {
                            QQ_Groups.push(name);
                        }
                        // 优先查找群聊专用页面，然后查找普通聊天页面
                        let $page = $(`.QQ_chat_page[data-group-id], .QQ_chat_page[data-name='${name}']`).filter(function() {
                            return $(this).attr('data-name') === name || 
                                   ($(this).attr('data-group-id') && window.currentGroupChat && window.currentGroupChat.name === name);
                        });
                        
                        let Creat = false;
                        if ($page.length === 0) {
                            Creat = true;
                            console.log(`${name}的聊天页不存在,开始创建`);
                            
                            // 如果是群聊且有currentGroupChat，使用群聊专用页面
                            if (window.currentGroupChat && window.currentGroupChat.name === name) {
                                $page = ensureGroupChatPage(window.currentGroupChat);
                            } else {
                            $page = $(QQ_CreatChatPage(name));
                            $QQpage.append($page);
                            }
                        }
                        let $msgContent = $page.find(".msgcontent");
                        if (json.群聊[name]["msgs"].length == 0) {
                            console.log(`数组空,跳出`);
                            continue;
                        }
                        let NewMsgCount = 0;
                        let LastTime = "";
                        let LastMsg = "";
                        for (let msg of json.群聊[name]["msgs"]) {
                            // 检查是否为新消息（不在现有消息列表中）
                            const isNewMsg = !QQ_msgjson.群聊[name]["msgs"].includes(msg);
                            QQ_Chat_AddMsg($msgContent[0], msg, name, isNewMsg);
                            console.log(`在群聊:${name}中添加消息:${msg} (新消息: ${isNewMsg})`);
                            QQ_msgjson.群聊[name]["msgs"].push(msg);
                            
                            // 同时保存到群聊专用的消息存储
                            const groupsForMessage = await loadGroupChatsFromWorldbook();
                            const currentGroup = groupsForMessage.find(g => g.name === name);
                            if (currentGroup) {
                                const sp = msg.split("--");
                                if (sp.length >= 2) {
                                    const messageObj = {
                                        sender: sp[0],
                                        content: sp[1],
                                        timestamp: sp.length >= 3 ? sp[2] : new Date().toLocaleTimeString('zh-CN', { hour12: false })
                                    };
                                    saveGroupMessage(currentGroup.id, messageObj);
                                    
                                    // 更新群聊的最后消息
                                    await updateGroupLastMessage(currentGroup.id, sp[1]);
                                }
                            }
                            
                            let sp = msg.split("--");
                            if (sp.length >= 2) {
                                if (sp[0] == `${UserName}`) {
                                    User_LastMsgMap.群聊[name] =
                                        `${sp[0]}--${sp[1]}`;
                                } else {
                                    if (sp.length >= 3) {
                                        Char_LastMsgMap.群聊[name] =
                                            `${sp[0]}--${sp[1]}--${sp[2]}`;
                                    } else {
                                        Char_LastMsgMap.群聊[name] =
                                            `${sp[0]}--${sp[1]}`;
                                    }
                                }
                            }
                            if (sp.length >= 3) {
                                LastTime = sp[2];
                            }
                            LastMsg = `${sp[0]}:${sp[1]}`;
                        }
                        
                        // *** 新的未读消息计算逻辑：使用QQ_CalculateUnreadCount ***
                        NewMsgCount = QQ_CalculateUnreadCount(name, QQ_msgjson.群聊[name]["msgs"], 'group');
                        
                        // 设置红点和首页显示的消息
                        const isCurrentlyVisible = $(`.QQ_chat_page[data-name='${name}']`).css("display") != "none" ||
                                                  $(`.QQ_chat_page[data-group-id]`).filter(function() {
                                                      return $(this).attr('data-name') === name && $(this).css('display') !== 'none';
                                                  }).length > 0;
                        
                        if (isCurrentlyVisible && !Creat) {
                            NewMsgCount = 0;
                        }
                        
                        // 更新界面显示
                        $(`.QQ_home_usermsg[data-name='${name}'] .QQ_home_lastmsg`).text(LastMsg);
                        $(`.QQ_home_usermsg[data-name='${name}'] .QQ_home_lasttime`).text(LastTime);
                        
                        // 同时更新群聊专用元素
                        const groupsForUpdate = await loadGroupChatsFromWorldbook();
                        const currentGroup = groupsForUpdate.find(g => g.name === name);
                        if (currentGroup) {
                            $(`.QQ_home_usermsg[data-group-id='${currentGroup.id}'] .QQ_home_lastmsg`).text(LastMsg);
                            $(`.QQ_home_usermsg[data-group-id='${currentGroup.id}'] .QQ_home_lasttime`).text(LastTime);
                        }
                        
                        QQ_SetHomeTips(name, NewMsgCount);
                        console.log(`群聊的未读消息数量:${NewMsgCount}`);
                        $msgContent.scrollTop($msgContent[0].scrollHeight);
                        
                        // *** 新增：更新分页按钮 ***
                        if (NewMsgCount > 0) {
                            QQ_Update_Chat_LoadMore(name, $msgContent[0]);
                        }
                        
                        let TipsCount = QQ_GetChatShowTipsCount(name);
                        const $Tips = $(`.QQ_chat_page[data-name='${name}']`).find(`.new_tips`);
                        $Tips.text(TipsCount);
                        if (TipsCount > 0) {
                            $Tips.css("display", "flex");
                        } else {
                            $Tips.hide();
                        }
                        
                        // 注释掉可能导致消息清空的群聊历史加载
                        // if (currentGroup && window.currentGroupChat && window.currentGroupChat.name === name) {
                        //     setTimeout(() => {
                        //         loadGroupChatHistory(currentGroup.id);
                        //     }, 100);
                        // }
                        
                        // 更新群聊的最后消息显示
                        updateGroupLastMessageDisplay(name);
                        
                        // 群聊消息更新时也更新消息列表
                        QQ_UpdateMessageList();
                    } catch (error) {
                        assertIsError(error);
                        QQ_Error(error.message);
                    }
                }
                console.log(
                    `User_LastMsgMap:\n${JSON.stringify(User_LastMsgMap)}\nChar_LastMsgMap:\n${JSON.stringify(Char_LastMsgMap)}`,
                );
                return true;
            }
            function QQ_SetHomeTips(name, count) {
                $(
                    `.QQ_home_usermsg[data-name='${name}'] .QQ_home_usermsg_new`,
                ).text(count);
                if (count == 0) {
                    $(
                        `.QQ_home_usermsg[data-name='${name}'] .QQ_home_usermsg_new`,
                    ).hide();
                } else {
                    $(
                        `.QQ_home_usermsg[data-name='${name}'] .QQ_home_usermsg_new`,
                    ).show();
                }
                console.log(`设置${name}的首页红点:${count}`);
                QQ_NewMsg[name] = count;
            }
            function QQ_GetChatShowTipsCount(name) {
                let count = 0;
                for (const n in QQ_NewMsg) {
                    if (n != name) {
                        count += Number(QQ_NewMsg[n]);
                    }
                }
                return count;
            }
            
            // *** 新增：动态评论生成状态跟踪 ***
            let QQ_MomentGenerating = false;
            
            /**
             * *** 增强版动态评论功能 ***
             * 支持8条评论上限、智能折叠、AI回复引导、防重复发送
             */
            async function QQ_Moment_Comment(event) {
                if (QQ_MomentGenerating) {
                    triggerSlash("/echo 生成中，请勿重复发送");
                    return;
                }
                QQ_MomentGenerating = true;

                try {
                    // 1. 保留：获取DOM元素和用户输入
                    const $closest = $(event.currentTarget).closest('.user_moment');
                const message = $closest.find(".moment_message").text();
                const input = $closest.find("input[type='text']");
                const name = $closest.find(".moment_sender").text();
                const list = $closest.find(".user_leave_message_list");
                const value = input.val()?.trim();
                
                if (!value || !message) {
                    console.log('输入内容为空或无法获取动态信息');
                    return;
                }
                
                    // 2. 保留：在UI上实时显示用户自己的评论
                    // ... (您现有的显示评论、滚动、保存评论到 MomentsData 的逻辑不变) ...

                    // 3. 【全新核心逻辑】分析本次的所有任务
                    let tasks = {
                        momentComment: { author: name, content: value },
                        privateChats: [],
                        groupChats: [],
                        interactiveTask: null
                    };
                    const cachedActions = QQ_GetValueName(QQ_CacheSendMsg);
                    if (cachedActions) {
                        for (const action of cachedActions) {
                            if (QQ_Groups.includes(action.name)) {
                                if (!tasks.groupChats.some(g => g[action.name])) tasks.groupChats.push({ [action.name]: [] });
                } else {
                                if (!tasks.privateChats.includes(action.name)) tasks.privateChats.push(action.name);
                            }
                        }
                    }
                    
                    // 4. 【全新核心逻辑】保留并整合互动意图检测
                    const interactiveResult = QQ_DetectInteractiveIntent(value);
                    if (interactiveResult && interactiveResult.isInteractive) {
                        tasks.interactiveTask = interactiveResult;
                    QQ_UserTriggeredInteractive = true;
                    } else {
                    QQ_UserTriggeredInteractive = false;
                }
                
                    // 5. 【全新核心逻辑】调用动态指令生成器
                    const finalPrompt = buildDynamicPrompt(tasks);

                    // 6. 组合最终发送内容
                    let sendvalue = (QQ_CacheSendMsg ? `${QQ_CacheSendMsg.trim()}\n\n` : '') + `用户在${name}的动态下评论：${value}`;
                    const finalPayload = `${sendvalue}\n\n${QQ_GetTimeContext()}\n\n${finalPrompt}`;
                    QQ_CacheSendMsg = ""; // 清空缓存

                    // 7. 发送请求
                    console.log('发送给AI的最终Payload:\n', finalPayload);
                    const result = await QQ_Gen(finalPayload);
                    await ResultHandle(result);
                    await QQ_Save_Msg();
                    
                } catch (error) {
                    console.error('动态评论AI生成过程中出错:', error);
                    await QQ_Force_Save_All_Data();
                } finally {
                    QQ_MomentGenerating = false;
                }
            }
            
             /**
              * *** 重新设计：处理AI回复的评论，支持折叠和私聊 ***
              * @param {string} content - AI返回的内容
              * @param {jQuery} $momentDiv - 目标动态的jQuery对象
              */
             async function QQ_Handle_AI_Comments(content, $momentDiv) {
                 try {
                     // 提取moment_start和moment_end之间的内容
                     const momentMatch = content.match(/moment_start([\s\S]*?)moment_end/);
                     if (!momentMatch) {
                         console.log('未找到有效的moment格式');
                         return;
                     }
                     
                     const momentContent = momentMatch[1].trim();
                     const lines = momentContent.split(/\r?\n/g);
                     const commentsList = $momentDiv.find('.user_leave_message_list');
                     const momentId = $momentDiv.attr('data-moment-id');
                     
                     // 查找对应的动态数据对象
                     const targetMoment = QQ_MomentsData.find(moment => moment.id === momentId);
                     
                     // *** 获取原动态信息用于过滤重复内容 ***
                     const originalMessage = $momentDiv.find('.moment_message').text();
                     const originalSender = $momentDiv.find('.moment_sender').text();
                     
                     // *** 新增AI评论到数据中（不删除旧评论），同时过滤重复动态内容 ***
                     const newComments = [];
                     for (const line of lines) {
                         const trimmedLine = line.trim();
                         if (!trimmedLine) continue;
                         
                         // *** 严格检查是否为完整动态格式，防止AI创建新动态 ***
                         const fullMomentMatch = trimmedLine.match(/\s*(.+?)--(.+?)--(.+?)--(.+?)--(.+)/);
                         if (fullMomentMatch) {
                             console.log('⚠️ AI尝试创建新动态而非评论，已阻止:', trimmedLine);
                             continue;
                         }
                         
                         // *** 检查是否包含动态特征（时间戳、浏览数、点赞数） ***
                         if (trimmedLine.includes('--') && (
                             /\d{2}:\d{2}/.test(trimmedLine) || // 时间格式
                             /\d+月\d+日/.test(trimmedLine) || // 日期格式
                             /--\d+--\d+/.test(trimmedLine) || // 浏览数--点赞数格式
                             trimmedLine.split('--').length >= 4 // 超过4个分段
                         )) {
                             console.log('⚠️ AI尝试创建动态格式内容，已阻止:', trimmedLine);
                             continue;
                         }
                         
                         // 匹配评论格式：角色名--评论内容
                         const commentMatch = trimmedLine.match(/^\s*(.+?)(?::|：|--)(.+)$/);
                         if (commentMatch) {
                             const [, name, commentContent] = commentMatch;
                             
                             // *** 严格过滤重复的动态内容 ***
                             if (commentContent.includes(originalMessage) && commentContent.length > 20) {
                                 console.log('⚠️ AI重复原动态内容，已过滤:', commentContent);
                                 continue;
                             }
                             
                             // *** 过滤包含完整动态信息的评论 ***
                             if (commentContent.includes(originalSender) && commentContent.includes(originalMessage)) {
                                 console.log('⚠️ AI在评论中复制完整动态，已过滤:', commentContent);
                                 continue;
                             }
                             
                             // *** 过滤图片标签重复 ***
                             if (commentContent.includes('[img-') && originalMessage.includes('[img-')) {
                                 const originalImageContent = originalMessage.match(/\[img-([^\]]+)\]/);
                                 const commentImageContent = commentContent.match(/\[img-([^\]]+)\]/);
                                 if (originalImageContent && commentImageContent && 
                                     originalImageContent[1] === commentImageContent[1]) {
                                     console.log('⚠️ AI重复动态图片，已过滤:', commentContent);
                                     continue;
                                 }
                             }
                             
                             // *** 过滤评论长度过长（可能是动态内容） ***
                             if (commentContent.length > 200) {
                                 console.log('⚠️ 评论内容过长，可能是动态内容，已过滤:', commentContent.substring(0, 50) + '...');
                                 continue;
                             }
                             
                             const commentData = {
                                 name: name,
                                 content: commentContent,
                                 timestamp: new Date().toISOString()
                             };
                             
                             newComments.push(commentData);
                             
                             // *** 添加到数据对象 ***
                             if (targetMoment) {
                                 targetMoment.comments.push(commentData);
                                 
                                 // *** 保持评论数量上限（50条） ***
                                 if (targetMoment.comments.length > 50) {
                                     targetMoment.comments = targetMoment.comments.slice(-50);
                                 }
                             }
                             
                             console.log(`AI评论已添加: ${name} - ${commentContent}`);
                         }
                     }
                     
                     // *** 重新渲染整个评论区域，支持折叠 ***
                     if (targetMoment && newComments.length > 0) {
                         QQ_Render_Comments(targetMoment, commentsList);
                         // *** 确保立即保存动态数据 ***
                         await QQ_Save_Moments();
                         console.log('AI评论已保存到动态备份');
                     }
                     
                     // *** 处理私聊消息（避免重复处理） ***
                     const processedMessages = new Set(); // 记录已处理的消息
                     await QQ_Handle_Private_Messages(content, processedMessages);
                     
                 } catch (error) {
                     console.error('处理AI评论时出错:', error);
                 }
             }
             
             /**
              * *** 新增：渲染评论区域，支持折叠功能 ***
              * @param {Object} momentData - 动态数据对象
              * @param {jQuery} $commentsList - 评论列表容器
              */
             function QQ_Render_Comments(momentData, $commentsList) {
                 $commentsList.empty();
                 
                 const comments = momentData.comments || [];
                 const VISIBLE_COMMENTS = 8;
                 
                 if (comments.length <= VISIBLE_COMMENTS) {
                     // 评论数量未超过限制，直接显示所有评论
                     for (const comment of comments) {
                         const messageDiv = $("<div>", { class: "user_leave_message" });
                         messageDiv.html(`<span><strong>${comment.name}</strong>：${comment.content}</span>`);
                         $commentsList.append(messageDiv);
                     }
                 } else {
                     // 评论数量超过限制，需要折叠
                     const hiddenCommentsCount = comments.length - VISIBLE_COMMENTS;
                     const visibleComments = comments.slice(-VISIBLE_COMMENTS);
                     
                     // 添加展开按钮
                     const expandButton = $("<div>", { 
                         class: "comments-expand-btn",
                         style: "text-align: center; color: #999; padding: 5px; cursor: pointer; border-bottom: 1px solid #eee;"
                     });
                     expandButton.html(`<span>展开查看更多评论 (${hiddenCommentsCount}条)</span>`);
                     expandButton.on('click', function() {
                         // 展开所有评论
                         $commentsList.empty();
                         for (const comment of comments) {
                             const messageDiv = $("<div>", { class: "user_leave_message" });
                             messageDiv.html(`<span><strong>${comment.name}</strong>：${comment.content}</span>`);
                             $commentsList.append(messageDiv);
                         }
                         
                         // 添加收起按钮
                         const collapseButton = $("<div>", { 
                             class: "comments-collapse-btn",
                             style: "text-align: center; color: #999; padding: 5px; cursor: pointer; border-top: 1px solid #eee;"
                         });
                         collapseButton.html(`<span>收起评论</span>`);
                         collapseButton.on('click', function() {
                             QQ_Render_Comments(momentData, $commentsList);
                         });
                         $commentsList.append(collapseButton);
                         
                         // 滚动到新评论
                         $commentsList.scrollTop($commentsList[0].scrollHeight);
                     });
                     
                     $commentsList.append(expandButton);
                     
                     // 显示最新的8条评论
                     for (const comment of visibleComments) {
                         const messageDiv = $("<div>", { class: "user_leave_message" });
                         messageDiv.html(`<span><strong>${comment.name}</strong>：${comment.content}</span>`);
                         $commentsList.append(messageDiv);
                     }
                 }
                 
                 // 滚动到最新评论
                 if ($commentsList.length > 0) {
                     $commentsList.scrollTop($commentsList[0].scrollHeight);
                 }
             }
             
             /**
              * *** 优化：处理AI返回的私聊消息（防止重复） ***
              * @param {string} content - AI返回的完整内容
              * @param {Set} processedMessages - 已处理的消息集合（可选）
              */
             async function QQ_Handle_Private_Messages(content, processedMessages = new Set()) {
                 try {
                     // 查找所有私聊消息格式
                     const allMsgMatches = [...content.matchAll(/msg_start([\s\S]*?)msg_end/g)];
                     
                     if (allMsgMatches.length > 0) {
                         console.log(`检测到 ${allMsgMatches.length} 条私聊消息，开始处理...`);
                         
                         for (const msgMatch of allMsgMatches) {
                             let msgContent = msgMatch[1].trim();
                             
                             // *** 新增：清理AI回复中的consider注释和其他标签 ***
                             msgContent = QQ_CleanNestedTags(msgContent);
                             
                             // 创建消息唯一标识（避免重复处理）
                             let messageHash;
                             try {
                                 // 先尝试简单的hash方法
                                 messageHash = msgContent.split('').map(c => c.charCodeAt(0)).join('').substring(0, 20);
                             } catch (error) {
                                 // 如果出错，使用时间戳作为fallback
                                 messageHash = Date.now().toString();
                             }
                             
                             if (processedMessages.has(messageHash)) {
                                 console.log('跳过重复消息:', messageHash);
                                 continue;
                             }
                             
                             processedMessages.add(messageHash);
                             console.log('处理新消息:', messageHash, msgContent.substring(0, 50) + '...');
                             
                             // 处理私聊消息
                             await QQ_Msg_Parse(msgContent);
                         }
                         
                         // *** 确保私聊消息处理后立即保存 ***
                         await QQ_Save_Msg();
                         console.log('私聊消息处理完成，已保存到备份');
                     }
                 } catch (error) {
                     console.error('处理私聊消息时出错:', error);
                 }
             }

             /**
              * *** 新增：强制保存所有动态相关数据 ***
              */
             async function QQ_Force_Save_All_Data() {
                 try {
                     console.log('开始强制保存所有数据...');
                     
                     // 保存动态数据
                     await QQ_Save_Moments();
                     console.log('✓ 动态数据已保存到世界书');
                     
                     // 保存消息数据（包括私聊和群聊）
                     await QQ_Save_Msg();
                     console.log('✓ 消息数据已保存到世界书');
                     
                     // *** 新增：额外保存群聊消息到专用存储 ***
                     await QQ_Force_Save_Group_Messages();
                     
                     console.log('所有数据保存完成');
                     
                     // 显示保存统计
                     if (typeof window.QQ_Show_Moments_Stats === 'function') {
                         window.QQ_Show_Moments_Stats();
                     }
                     
                 } catch (error) {
                     console.error('强制保存数据时出错:', error);
                 }
             }

             /**
              * *** 新增：强制保存群聊消息到专用存储 ***
              */
             async function QQ_Force_Save_Group_Messages() {
                 try {
                     console.log('开始强制保存群聊消息到专用存储...');
                     
                     // 检查QQ_msgjson.群聊中的所有群聊
                     if (QQ_msgjson.群聊 && typeof QQ_msgjson.群聊 === 'object') {
                         const groups = await loadGroupChatsFromWorldbook();
                         
                         for (const groupName in QQ_msgjson.群聊) {
                             const groupData = QQ_msgjson.群聊[groupName];
                             if (groupData && groupData.msgs && Array.isArray(groupData.msgs)) {
                                 // 找到对应的群聊存储
                                 const targetGroup = groups.find(g => g.name === groupName);
                                 if (targetGroup) {
                                     // 保存最近的消息（避免重复保存）
                                     const recentMessages = groupData.msgs.slice(-10); // 只处理最近10条消息
                                     
                                     for (const msg of recentMessages) {
                                         const parts = msg.split('--');
                                         if (parts.length >= 2) {
                                             const messageObj = {
                                                 sender: parts[0],
                                                 content: parts[1],
                                                 timestamp: parts.length >= 3 ? parts[2] : new Date().toLocaleTimeString('zh-CN', { hour12: false })
                                             };
                                             
                                             // 使用现有的saveGroupMessage函数（已经有去重逻辑）
                                             saveGroupMessage(targetGroup.id, messageObj);
                                         }
                                     }
                                     
                                     // 更新最后消息
                                     if (groupData.msgs.length > 0) {
                                         const lastMsg = groupData.msgs[groupData.msgs.length - 1];
                                         const lastMsgParts = lastMsg.split('--');
                                         if (lastMsgParts.length >= 2) {
                                             await updateGroupLastMessage(targetGroup.id, lastMsgParts[1]);
                                         }
                                     }
                                     
                                     console.log(`✓ 群聊 ${groupName} 的消息已强制保存到专用存储`);
                                 } else {
                                     console.log(`⚠ 群聊 ${groupName} 在专用存储中不存在，跳过保存`);
                                 }
                             }
                         }
                     }
                     
                     console.log('群聊消息强制保存完成');
                     
                 } catch (error) {
                     console.error('强制保存群聊消息时出错:', error);
                 }
             }

             // *** 新增：添加到全局作用域便于调试 ***
             window.QQ_Force_Save_All_Data = QQ_Force_Save_All_Data;

             /**
              * *** 新增：检查动态评论保存状态的调试函数 ***
              */
             function QQ_Check_Comment_Backup_Status() {
                 console.log('=== 动态评论备份状态检查 ===');
                 
                 if (!QQ_MomentsData || !Array.isArray(QQ_MomentsData)) {
                     console.log('⚠️ QQ_MomentsData不存在或不是数组');
                     return;
                 }
                 
                 // 检查内存中的动态数据
                 console.log(`内存中动态数量: ${QQ_MomentsData.length}`);
                 
                 let totalComments = 0;
                 let momentsWithComments = 0;
                 
                 QQ_MomentsData.forEach((moment, index) => {
                     if (moment.comments && moment.comments.length > 0) {
                         totalComments += moment.comments.length;
                         momentsWithComments++;
                         console.log(`动态 ${index + 1} (${moment.userName}): ${moment.comments.length}条评论`);
                         
                         // 显示最近的几条评论
                         const recentComments = moment.comments.slice(-3);
                         recentComments.forEach((comment, commentIndex) => {
                             console.log(`  - ${comment.name}: ${comment.content} (${comment.timestamp})`);
                         });
                     }
                 });
                 
                 console.log(`总计: ${momentsWithComments}个动态有评论，共${totalComments}条评论`);
                 
                 // 检查世界书中的备份
                 if (worldbook && entries) {
                     const momentEntry = entries.find(entry => entry.comment === "手机-动态内容存储");
                     if (momentEntry) {
                         try {
                             const backupData = JSON.parse(momentEntry.content);
                             let backupComments = 0;
                             let backupMomentsWithComments = 0;
                             
                             backupData.forEach(moment => {
                                 if (moment.comments && moment.comments.length > 0) {
                                     backupComments += moment.comments.length;
                                     backupMomentsWithComments++;
                                 }
                             });
                             
                             console.log(`世界书备份: ${backupData.length}个动态，${backupMomentsWithComments}个有评论，共${backupComments}条评论`);
                             console.log('✓ 世界书备份存在且有效');
                         } catch (error) {
                             console.error('世界书备份数据解析失败:', error);
                         }
                     } else {
                         console.warn('未找到动态内容的世界书备份条目');
                     }
                 } else {
                     console.warn('无法访问世界书或entries');
                 }
                 
                 console.log('=== 检查完成 ===');
             }

                         // *** 添加到全局作用域便于调试 ***
            window.QQ_Check_Comment_Backup_Status = QQ_Check_Comment_Backup_Status;
            
            /**
             * *** 新增：测试互动设置功能的调试工具 ***
             */
            function QQ_Test_Interactive_Settings() {
                console.log('=== 互动设置功能测试 ===');
                
                try {
                    // 获取当前设置
                    const currentSettings = QQ_GetInteractiveSettings();
                    console.log('📋 当前设置:', currentSettings);
                    
                    // 测试不同类型的消息
                    const testMessages = [
                        '&&想要拥抱你',          // 特殊符号
                        '我想拥抱你和抚摸你',     // 默认关键词（需要启用）
                        '想你了',               // 可能的自定义关键词
                        '今天天气真好',          // 普通消息
                        '*伸出双手*想要拥抱',    // 动作模式
                    ];
                    
                    console.log('🧪 测试消息检测结果:');
                    testMessages.forEach(message => {
                        const result = QQ_DetectInteractiveIntent(message);
                        console.log(`消息: "${message}"`);
                        console.log(`结果:`, result);
                        console.log('---');
                    });
                    
                    // 显示触发统计
                    console.log('📊 触发机制状态:');
                    console.log(`🎯 特殊符号触发: 永久启用`);
                    console.log(`🔍 关键词触发: ${currentSettings.enableKeywordTrigger ? '已启用' : '已禁用'}`);
                    console.log(`📝 默认关键词: ${currentSettings.enableDefaultKeywords ? '已启用' : '已禁用'}`);
                    console.log(`🏷️ 自定义关键词: ${currentSettings.customKeywords.length}个`);
                    if (currentSettings.customKeywords.length > 0) {
                        console.log(`   关键词列表: ${currentSettings.customKeywords.join(', ')}`);
                    }
                    
                    // 功能检查
                    console.log('🔧 功能状态检查:');
                    console.log(`• 获取设置函数: ${typeof QQ_GetInteractiveSettings === 'function' ? '✅' : '❌'}`);
                    console.log(`• 保存设置函数: ${typeof QQ_SaveInteractiveSettings === 'function' ? '✅' : '❌'}`);
                    console.log(`• 显示设置界面: ${typeof QQ_ShowInteractiveSettings === 'function' ? '✅' : '❌'}`);
                    console.log(`• 更新状态显示: ${typeof QQ_UpdateInteractiveStatus === 'function' ? '✅' : '❌'}`);
                    console.log(`• 互动检测函数: ${typeof QQ_DetectInteractiveIntent === 'function' ? '✅' : '❌'}`);
                    
                } catch (error) {
                    console.error('❌ 测试过程中出现错误:', error);
                }
                
                console.log('=== 测试完成 ===');
                console.log('💡 提示: 可以通过 QQ_ShowInteractiveSettings() 打开设置界面');
            }
            
            // *** 添加到全局作用域便于调试 ***
            window.QQ_Test_Interactive_Settings = QQ_Test_Interactive_Settings;

            /**
             * *** 新增：检查互动内容保存状态的调试函数 ***
             */
            function QQ_Check_Interactive_Backup_Status() {
                console.log('=== 互动内容备份状态检查 ===');
                
                // 检查内存中的互动空间数据
                const memorySpaces = Object.keys(QQ_InteractiveSpaces || {}).length;
                const memoryCharSpaces = Object.keys(QQ_CharacterSpaces || {}).length;
                console.log(`内存中公共互动空间: ${memorySpaces}个`);
                console.log(`内存中角色互动空间: ${memoryCharSpaces}个`);
                
                if (worldbook && entries) {
                    // 检查世界书中的公共互动备份
                    const publicEntry = entries.find(entry => entry.comment === "角色-互动空间备份");
                    if (publicEntry) {
                        try {
                            const publicData = JSON.parse(publicEntry.content);
                            console.log(`✅ 世界书公共互动备份: ${publicData.length}个互动内容`);
                            
                            // 显示最近几个公共互动的详情
                            if (publicData.length > 0) {
                                console.log('最近的公共互动:');
                                publicData.slice(0, 3).forEach((item, index) => {
                                    console.log(`  ${index + 1}. ID: ${item.id}, 时间: ${item.timestamp}`);
                                    console.log(`     内容: ${item.content.substring(0, 50)}...`);
                                });
                            }
                        } catch (error) {
                            console.error('❌ 解析公共互动备份失败:', error);
                        }
                    } else {
                        console.warn('⚠ 未找到公共互动备份条目');
                    }
                    
                    // 检查角色专属互动备份
                    const characterEntries = entries.filter(entry => 
                        entry.comment && entry.comment.startsWith("角色-互动空间备份-")
                    );
                    
                    console.log(`📋 找到${characterEntries.length}个角色互动备份条目:`);
                    characterEntries.forEach(entry => {
                        const characterName = entry.comment.replace("角色-互动空间备份-", "");
                        try {
                            const charData = JSON.parse(entry.content);
                            console.log(`  • ${characterName}: ${charData.length}个互动内容`);
                            
                            // 显示该角色最近的互动
                            if (charData.length > 0) {
                                const latest = charData[0];
                                console.log(`    最新: ${latest.timestamp} - ${latest.content.substring(0, 30)}...`);
                            }
                        } catch (error) {
                            console.error(`❌ 解析角色${characterName}互动备份失败:`, error);
                        }
                    });
                    
                    if (characterEntries.length === 0) {
                        console.warn('⚠ 未找到任何角色互动备份条目');
                    }
                    
                } else {
                    console.warn('❌ 无法访问世界书或entries');
                }
                
                console.log('=== 互动内容检查完成 ===');
            }

            // *** 添加到全局作用域便于调试 ***
            window.QQ_Check_Interactive_Backup_Status = QQ_Check_Interactive_Backup_Status;

             /**
              * *** 新增：测试增强AI回复功能 ***
              */
             function QQ_Test_Enhanced_AI_Response() {
                 console.log('=== 🔥 超强化AI回复功能测试 🔥 ===');
                 
                 // 测试动态评论的超强指导
                 console.log('📱 动态评论AI超强指导:');
                 console.log('✅ 强制要求: 4名角色回复 + 2名角色私聊');
                 console.log('✅ 内容标准: 评论2-3句话，私聊3-4句话');
                 console.log('✅ 质量保证: 情感表达+具体反应+互动引导');
                 console.log('✅ 差异化: 不同角色完全不同的语气和关注点');
                 
                 // 测试普通消息的超强指导  
                 console.log('💬 普通消息AI超强指导:');
                 console.log('✅ 强制要求: 3-4名角色回复，每个4-5句话起步');
                 console.log('✅ 内容标准: 必须包含提问+建议+邀请+关心+个人感受');
                 console.log('✅ 扩展互动: 2名角色私聊深入 + 丰富动态输出');
                 console.log('✅ 禁止行为: 简短回复、敷衍内容、角色同质化');
                 
                 // 显示超强化设置状态
                 console.log('🚨 超强化设置状态:');
                 console.log('- 动态评论: 强制4角色评论 + 2角色私聊');
                 console.log('- 普通消息: 强制3-4角色回复(4-5句话) + 2角色私聊 + 动态');
                 console.log('- 内容长度: 评论2-3句，回复4-5句，私聊3-4句');
                 console.log('- 违规处理: 不符合标准将被视为无效');
                 console.log('- 强制要素: 情感+反应+引导+个性+互动');
                 
                 // 提供测试建议
                 console.log('🧪 超强化测试建议:');
                 console.log('1. 发布动态并评论，应看到4个角色评论+2个私聊');
                 console.log('2. 发送普通消息，应看到3-4个角色深度回复+私聊+动态');
                 console.log('3. 检查每个回复是否达到强制长度要求');
                 console.log('4. 观察角色回复是否有明显个性差异');
                 console.log('5. 验证是否包含提问、建议、邀请等互动要素');
                 
                 console.log('🎯 预期改进效果:');
                 console.log('- 回复数量: 从1-2个增加到3-4个');
                 console.log('- 回复长度: 从简短增加到4-5句话');
                 console.log('- 私聊频率: 大幅增加，至少2个角色私聊');
                 console.log('- 互动质量: 包含具体的提问和引导');
                 console.log('- 角色差异: 不同语气、关注点、表达方式');
                 
                 console.log('🔥 超强化AI回复功能已激活！预期效果大幅提升！');
                 
                 // 返回测试状态
                 return {
                     dynamicCommentRequirements: '强制4名角色评论 + 2名角色私聊，内容丰富',
                     normalMessageRequirements: '强制3-4名角色回复 + 2名角色私聊 + 动态输出',
                     contentStandard: '评论2-3句话，回复4-5句话，私聊3-4句话',
                     qualityRequirements: '情感表达+具体反应+互动引导+个性差异',
                     enhancementLevel: '超强化已激活',
                     expectedImprovement: '回复内容将显著增加，互动性大幅提升'
                 };
             }

             // *** 添加到全局作用域便于调试 ***
             window.QQ_Test_Enhanced_AI_Response = QQ_Test_Enhanced_AI_Response;

             /**
              * *** 新增：查看互动空间世界书备份信息 ***
              */
             function QQ_Show_Interactive_Spaces_Backup() {
                 console.log("🌟 互动空间世界书备份查询 🌟");
                 
                 try {
                     if (!worldbook || !worldbook.entries) {
                         console.log("❌ 世界书功能不可用或未初始化");
                         return;
                     }
                     
                     // 查找所有互动空间相关的世界书条目
                     const interactiveEntries = worldbook.entries.filter(entry => 
                         entry.comment && (
                             entry.comment.includes('互动空间') || 
                             entry.comment === 'QQ_互动空间备份' ||
                             entry.comment === 'QQ_角色互动空间备份' ||
                             entry.comment.startsWith('QQ_互动空间备份_')
                         )
                     );
                     
                     console.log(`📚 共找到 ${interactiveEntries.length} 个互动空间相关的世界书条目：`);
                     
                     interactiveEntries.forEach((entry, index) => {
                         console.log(`\n📖 条目 ${index + 1}: ${entry.comment}`);
                         console.log(`🔑 关键词: ${entry.key ? entry.key.join(', ') : '无'}`);
                         console.log(`📄 启用状态: ${entry.enabled ? '✅ 启用' : '❌ 禁用'}`);
                         console.log(`📊 内容长度: ${entry.content ? entry.content.length : 0} 字符`);
                         
                         if (entry.content) {
                             try {
                                 const data = JSON.parse(entry.content);
                                 if (data.spaces) {
                                     const spaceCount = Object.keys(data.spaces).length;
                                     console.log(`🏠 公共互动空间数量: ${spaceCount}`);
                                 }
                                 if (data.characterSpaces) {
                                     const characterCount = Object.keys(data.characterSpaces).length;
                                     const totalSpaces = Object.values(data.characterSpaces).reduce((sum, char) => sum + Object.keys(char).length, 0);
                                     console.log(`👥 角色数量: ${characterCount}, 总空间数: ${totalSpaces}`);
                                 }
                                 if (data.lastUpdated) {
                                     console.log(`⏰ 最后更新: ${data.lastUpdated}`);
                                 }
                                 if (data.version) {
                                     console.log(`📌 版本: ${data.version}`);
                                 }
                             } catch (parseError) {
                                 console.log(`⚠️ 内容解析失败: ${parseError.message}`);
                             }
                         } else {
                             console.log("📄 内容为空");
                         }
                     });
                     
                     // 显示内存中的互动空间状态
                     console.log("\n💾 内存中的互动空间状态:");
                     if (window.QQ_InteractiveSpaces) {
                         const memorySpaceCount = Object.keys(QQ_InteractiveSpaces).length;
                         console.log(`🏠 公共互动空间 (内存): ${memorySpaceCount} 个`);
                     }
                     if (window.QQ_CharacterSpaces) {
                         const memoryCharacterCount = Object.keys(QQ_CharacterSpaces).length;
                         const memoryTotalSpaces = Object.values(QQ_CharacterSpaces).reduce((sum, char) => sum + Object.keys(char).length, 0);
                         console.log(`👥 角色互动空间 (内存): ${memoryCharacterCount} 个角色, ${memoryTotalSpaces} 个空间`);
                     }
                     
                     console.log("\n🔧 手动操作说明:");
                     console.log("- 执行 QQ_Show_Interactive_Spaces_Backup() 查看此信息");
                     console.log("- 在SillyTavern世界书中查找以下条目:");
                     console.log("  • QQ_互动空间备份 (公共互动空间)");
                     console.log("  • QQ_角色互动空间备份 (角色专属互动空间)");
                     console.log("  • QQ_互动空间备份_{角色名} (单角色互动空间)");
                     
                     return {
                         totalEntries: interactiveEntries.length,
                         entries: interactiveEntries.map(e => ({
                             comment: e.comment,
                             enabled: e.enabled,
                             contentLength: e.content ? e.content.length : 0
                         }))
                     };
                     
                 } catch (error) {
                     console.error("查询互动空间备份时发生错误:", error);
                     return null;
                 }
             }

             // *** 添加到全局作用域便于调试 ***
             window.QQ_Show_Interactive_Spaces_Backup = QQ_Show_Interactive_Spaces_Backup;

             /**
              * *** 新增：检查群聊消息保存状态的调试函数 ***
              */
             function QQ_Check_Group_Message_Backup_Status() {
                 console.log('=== 群聊消息备份状态检查 ===');
                 
                 // 检查QQ_msgjson.群聊中的数据
                 if (QQ_msgjson.群聊 && typeof QQ_msgjson.群聊 === 'object') {
                     const groupNames = Object.keys(QQ_msgjson.群聊);
                     console.log(`QQ_msgjson.群聊中有 ${groupNames.length} 个群聊:`);
                     
                     let totalMessages = 0;
                     groupNames.forEach(groupName => {
                         const groupData = QQ_msgjson.群聊[groupName];
                         const msgCount = groupData && groupData.msgs ? groupData.msgs.length : 0;
                         totalMessages += msgCount;
                         console.log(`  - ${groupName}: ${msgCount}条消息`);
                         
                         // 显示最近几条消息
                         if (msgCount > 0) {
                             const recentMsgs = groupData.msgs.slice(-3);
                             recentMsgs.forEach(msg => {
                                 console.log(`    ${msg}`);
                             });
                         }
                     });
                     
                     console.log(`总计: ${totalMessages}条群聊消息`);
                 } else {
                     console.log('QQ_msgjson.群聊 为空或不存在');
                 }
                 
                 // 检查QQ_Groups数组
                 console.log(`QQ_Groups数组: [${QQ_Groups.join(', ')}] (${QQ_Groups.length}个)`);
                 
                 // 检查世界书备份
                 if (worldbook && entries) {
                     const chatEntry = entries.find(entry => entry.comment === "QQ聊天备份数据");
                     if (chatEntry) {
                         try {
                             const backupData = JSON.parse(chatEntry.content);
                             if (backupData.群聊) {
                                 const backupGroupNames = Object.keys(backupData.群聊);
                                 let backupTotalMessages = 0;
                                 
                                 backupGroupNames.forEach(groupName => {
                                     const groupData = backupData.群聊[groupName];
                                     const msgCount = groupData && groupData.msgs ? groupData.msgs.length : 0;
                                     backupTotalMessages += msgCount;
                                 });
                                 
                                 console.log(`世界书备份: ${backupGroupNames.length}个群聊，${backupTotalMessages}条消息`);
                                 console.log('✓ 世界书群聊备份存在且有效');
                             } else {
                                 console.log('世界书备份中无群聊数据');
                             }
                         } catch (error) {
                             console.error('世界书备份数据解析失败:', error);
                         }
                     } else {
                         console.warn('未找到聊天备份的世界书条目');
                     }
                 } else {
                     console.warn('无法访问世界书或entries');
                 }
                 
                 // 异步检查群聊专用存储
                 loadGroupChatsFromWorldbook().then(groups => {
                     console.log(`群聊专用存储: ${groups.length}个群聊`);
                     groups.forEach(group => {
                         console.log(`  - ${group.name} (ID: ${group.id})`);
                     });
                 }).catch(error => {
                     console.error('检查群聊专用存储失败:', error);
                 });
                 
                 console.log('=== 群聊检查完成 ===');
             }

             // *** 添加到全局作用域便于调试 ***
             window.QQ_Check_Group_Message_Backup_Status = QQ_Check_Group_Message_Backup_Status;

             /**
              * *** 新增：测试互动内容优化功能的调试函数 ***
              */
             function QQ_Test_Interactive_Optimization() {
                 console.log('=== 互动内容优化功能测试 ===');
                 
                 // 测试用例
                 const testCases = [
                     {
                         content: '小明过来吧，我想和你聊聊',
                         primaryChar: '小明',
                         expected: '角色专属空间（小明主导）'
                     },
                     {
                         content: '【小明】【小红】【小蓝】大家一起玩游戏吧',
                         primaryChar: '小明',
                         expected: '公共空间（明显多人）'
                     },
                     {
                         content: '和小明单独聊天，顺便【小红】也来一下',
                         primaryChar: '小明',
                         expected: '角色专属空间（小明主导私密互动）'
                     },
                     {
                         content: '小红和小蓝以及小绿一起唱歌',
                         primaryChar: '小红',
                         expected: '公共空间（多人活动）'
                     },
                     {
                         content: '我来了！过来抱抱你',
                         primaryChar: '小明',
                         expected: '角色专属空间（单人互动）'
                     }
                 ];
                 
                 testCases.forEach((testCase, index) => {
                     console.log(`\n测试案例 ${index + 1}:`);
                     console.log(`内容: "${testCase.content}"`);
                     console.log(`主要角色: ${testCase.primaryChar}`);
                     console.log(`预期结果: ${testCase.expected}`);
                     
                     const isMultiCharacter = QQ_DetectMultiCharacterInteraction(testCase.content, testCase.primaryChar);
                     const actualResult = isMultiCharacter ? '公共空间' : '角色专属空间';
                     console.log(`实际结果: ${actualResult}`);
                     console.log(`✓ 测试${actualResult.includes(testCase.expected.includes('公共') ? '公共' : '角色') ? '通过' : '失败'}`);
                 });
                 
                 console.log('\n=== 测试完成 ===');
                 console.log('提示：你可以使用 QQ_Test_Interactive_Content_Detection("测试内容", "角色名") 来测试特定内容');
             }
             
             /**
              * *** 新增：测试特定互动内容的检测结果 ***
              */
             function QQ_Test_Interactive_Content_Detection(content, primaryCharacter = null) {
                 console.log(`\n=== 测试互动内容检测 ===`);
                 console.log(`内容: "${content}"`);
                 console.log(`主要角色: ${primaryCharacter || '无'}`);
                 
                 // 1. 测试是否为互动内容
                 const isInteractive = QQ_IsInteractiveContent(content);
                 console.log(`是否为互动内容: ${isInteractive ? '是' : '否'}`);
                 
                 if (isInteractive) {
                     // 2. 测试多角色检测
                     const isMultiCharacter = QQ_DetectMultiCharacterInteraction(content, primaryCharacter);
                     console.log(`是否为多角色互动: ${isMultiCharacter ? '是' : '否'}`);
                     console.log(`推荐存储位置: ${isMultiCharacter ? '公共互动空间' : (primaryCharacter ? primaryCharacter + '的专属空间' : '角色专属空间')}`);
                     
                     // 3. 测试场景命名
                     const sceneName = primaryCharacter ? 
                         `${primaryCharacter}·${QQ_GetSceneFromContent(content)}` :
                         QQ_GetSpaceName(content);
                     console.log(`建议空间名称: "${sceneName}"`);
                 }
                 
                 console.log('=== 测试结束 ===\n');
             }
             
             // *** 添加到全局作用域便于调试 ***
             window.QQ_Test_Interactive_Optimization = QQ_Test_Interactive_Optimization;
             window.QQ_Test_Interactive_Content_Detection = QQ_Test_Interactive_Content_Detection;
            
            /**
             * *** 新增：测试互动内容严格检测修复 ***
             */


             /**
              * *** 新增：检查两阶段发送机制状态的调试函数 ***
              */
             function QQ_Check_Two_Stage_Send_Status() {
                 console.log('=== 两阶段发送机制状态检查 ===');
                 
                 // 检查缓存消息状态
                 console.log(`缓存消息状态: ${QQ_CacheSendMsg ? '有缓存' : '无缓存'}`);
                 if (QQ_CacheSendMsg) {
                     console.log(`缓存内容: "${QQ_CacheSendMsg}"`);
                     
                     // 解析缓存消息
                     const namevalue = QQ_GetValueName(QQ_CacheSendMsg);
                     if (namevalue && namevalue.length > 0) {
                         console.log(`解析到 ${namevalue.length} 条缓存消息:`);
                         namevalue.forEach((match, index) => {
                             const type = QQ_Groups.includes(match.name) ? '群聊' : '私聊';
                             console.log(`  ${index + 1}. ${type} - ${match.name}: "${match.value}"`);
                         });
                     } else {
                         console.log('缓存消息解析失败');
                     }
                 }
                 
                 // 检查最近的消息保存状态
                 console.log('\n=== 最近消息保存状态 ===');
                 
                 // 检查私聊消息
                 console.log('私聊消息数量:', Object.keys(QQ_msgjson.私聊).length);
                 Object.entries(QQ_msgjson.私聊).forEach(([chatKey, messages]) => {
                     if (Array.isArray(messages) && messages.length > 0) {
                         const lastMsg = messages[messages.length - 1];
                         console.log(`  ${chatKey}: 最后消息 "${lastMsg}"`);
                     }
                 });
                 
                 // 检查群聊消息
                 console.log('群聊消息数量:', Object.keys(QQ_msgjson.群聊).length);
                 Object.entries(QQ_msgjson.群聊).forEach(([groupName, groupData]) => {
                     if (groupData && groupData.msgs && Array.isArray(groupData.msgs) && groupData.msgs.length > 0) {
                         const lastMsg = groupData.msgs[groupData.msgs.length - 1];
                         console.log(`  ${groupName}: 最后消息 "${lastMsg}"`);
                     }
                 });
                 
                 console.log('\n=== 检查完成 ===');
                 console.log('提示：可以使用 QQ_Test_Cache_Message_Parsing("测试内容") 来测试消息解析');
             }
             
             /**
              * *** 新增：测试缓存消息解析的调试函数 ***
              */
             function QQ_Test_Cache_Message_Parsing(testContent) {
                 console.log(`\n=== 测试缓存消息解析 ===`);
                 console.log(`测试内容: "${testContent}"`);
                 
                 const namevalue = QQ_GetValueName(testContent);
                 if (namevalue && namevalue.length > 0) {
                     console.log(`✓ 解析成功，共 ${namevalue.length} 条消息:`);
                     namevalue.forEach((match, index) => {
                         const type = QQ_Groups.includes(match.name) ? '群聊' : '私聊';
                         console.log(`  ${index + 1}. ${type} - 对象: "${match.name}", 内容: "${match.value}"`);
                     });
                 } else {
                     console.log('❌ 解析失败，无法识别消息格式');
                     console.log('提示：确保消息格式为 "目标名字：消息内容" 或类似格式');
                 }
                 
                 console.log('=== 测试结束 ===\n');
             }
             
             // *** 添加到全局作用域便于调试 ***
             window.QQ_Check_Two_Stage_Send_Status = QQ_Check_Two_Stage_Send_Status;
             window.QQ_Test_Cache_Message_Parsing = QQ_Test_Cache_Message_Parsing;

             /**
              * 测试时间功能
              * 显示当前时间信息和时间上下文生成
              */
             function QQ_Test_Time_Feature() {
                 console.log('=== 时间功能测试 ===');
                 
                 const now = new Date();
                 console.log('原始时间对象:', now);
                 
                 const currentTime = {
                     time: now.toLocaleTimeString('zh-CN', { hour12: false, hour: '2-digit', minute: '2-digit' }),
                     date: now.toLocaleDateString('zh-CN', { year: 'numeric', month: 'long', day: 'numeric' }),
                     weekday: now.toLocaleDateString('zh-CN', { weekday: 'long' }),
                     period: QQ_GetTimePeriod(now.getHours()),
                     season: QQ_GetSeason(now.getMonth() + 1)
                 };
                 
                 console.log('格式化时间信息:');
                 console.log('- 时间:', currentTime.time);
                 console.log('- 日期:', currentTime.date);
                 console.log('- 星期:', currentTime.weekday);
                 console.log('- 时段:', currentTime.period);
                 console.log('- 季节:', currentTime.season);
                 
                 // 更明确的时间描述，避免AI混淆12小时制和24小时制
                 const hour = now.getHours();
                 const minute = now.getMinutes();
                 const clarifiedTime = `${currentTime.period}${hour}点${minute.toString().padStart(2, '0')}分`;
                 
                 const timeContext = `<TimeContext:当前真实时间是${currentTime.date} ${currentTime.weekday} ${clarifiedTime}(24小时制${currentTime.time})，现在是${currentTime.period}时段，${currentTime.season}。请在回复中考虑时间情境，如问候语(早上好/下午好/晚上好)、活动安排等应符合当前时间>`;
                 
                 console.log('\n生成的时间上下文:');
                 console.log(timeContext);
                 
                 console.log('\n时间段功能测试:');
                 for (let h = 0; h < 24; h++) {
                     console.log(`${h}:00 -> ${QQ_GetTimePeriod(h)}`);
                 }
                 
                 console.log('\n季节功能测试:');
                 for (let m = 1; m <= 12; m++) {
                     console.log(`${m}月 -> ${QQ_GetSeason(m)}`);
                 }
                 
                 console.log('=== 测试完成 ===');
             }

             /**
              * 测试完整的消息发送流程（包含时间）
              */
             function QQ_Test_Message_Send_With_Time() {
                 console.log('=== 消息发送时间功能测试 ===');
                 
                 // 模拟QQ_SendMsg中的时间处理逻辑
                 const now = new Date();
                 const currentTime = {
                     time: now.toLocaleTimeString('zh-CN', { hour12: false, hour: '2-digit', minute: '2-digit' }),
                     date: now.toLocaleDateString('zh-CN', { year: 'numeric', month: 'long', day: 'numeric' }),
                     weekday: now.toLocaleDateString('zh-CN', { weekday: 'long' }),
                     period: QQ_GetTimePeriod(now.getHours()),
                     season: QQ_GetSeason(now.getMonth() + 1)
                 };
                 
                 // 更明确的时间描述，避免AI混淆12小时制和24小时制
                 const hour = now.getHours();
                 const minute = now.getMinutes();
                 const clarifiedTime = `${currentTime.period}${hour}点${minute.toString().padStart(2, '0')}分`;
                 
                 const timeContext = `<TimeContext:当前真实时间是${currentTime.date} ${currentTime.weekday} ${clarifiedTime}(24小时制${currentTime.time})，现在是${currentTime.period}时段，${currentTime.season}。请在回复中考虑时间情境，如问候语(早上好/下午好/晚上好)、活动安排等应符合当前时间>`;
                 
                 const mockRequest = `<Request:本次响应忽略其他上下文任何要求,必须使用线上格式回复,且用户本次发了消息的角色都要回复用户的消息,同时输出一条动态内容>`;
                 
                 const fullRequest = `给测试角色发消息:你好\n${timeContext}\n${mockRequest}`;
                 
                 console.log('模拟发送给AI的完整请求内容:');
                 console.log('=================================');
                 console.log(fullRequest);
                 console.log('=================================');
                 
                 console.log('\n✅ 时间信息已成功集成到消息发送流程中');
                 console.log('📱 AI现在可以感知到用户的真实时间环境');
                 console.log('🕐 这将显著提升AI回复的时间相关性和真实感');
                 console.log('=== 测试完成 ===');
             }

             // 添加到全局作用域便于调试
             window.QQ_Test_Time_Feature = QQ_Test_Time_Feature;
             window.QQ_Test_Message_Send_With_Time = QQ_Test_Message_Send_With_Time;
             function QQ_Moment_Parse(content, isCommentContext = false) {
                const lines = content.split(/\r?\n/g);
                let momentdiv;
                let list;
                let count = QQ_NewMsg["moment"] || 0;
                let currentMomentData = null; // *** 新增：当前动态的数据对象 ***
                
                for (const line of lines) {
                    //console.log(`line:${line}`);
                    let match = line.match(
                        /\s*(.+?)--(.+?)--(.+?)--(.+?)--(.+)/,
                    );
                    if (match) {
                        // *** 新增：在评论上下文中跳过完整动态格式 ***
                        if (isCommentContext) {
                            console.log('在评论上下文中检测到完整动态格式，已跳过:', line);
                            continue;
                        }
                        
                        // 是新动态内容
                        console.log(`匹配到动态内容:${match[0]}`);
                        
                        // *** 保存上一个动态数据 ***
                        if (currentMomentData && momentdiv) {
                            QQ_MomentsData.unshift(currentMomentData); // 新动态添加到数组开头
                            count += 1;
                            $("#space_contents").prepend(momentdiv);
                        }
                        
                        let fakeimg = "";
                        let message = match[2];
                        const matches = message.matchAll(/\[img-(.+?)\]/g);
                        if (matches) {
                            for (const m of matches) {
                                message = message.replace(m[0], "");
                                fakeimg += `\n<div class="space_fakeimg">${m[1]}</div>`;
                            }
                        }
                        
                        const randomPhone = QQ_CharSettings.readValue(match[1], "手机型号") 
                            ? QQ_CharSettings.readValue(match[1], "手机型号")
                            : QQ_GetRandomPhone();
                        
                        // *** 新增：创建动态数据对象 ***
                        const momentId = `${match[1]}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                        currentMomentData = {
                            id: momentId, // 使用更可靠的唯一ID
                            userName: match[1],
                            message: message,
                            timestampText: match[3],
                            timestamp: new Date().toISOString(), // 保存完整时间戳用于排序
                            additionalInfo: match[4],
                            randomPhone: randomPhone,
                            extraContent: match[5] || '',
                            imgcontent: fakeimg,
                            comments: [], // 初始化评论数组
                            // 新增：点赞相关字段
                            likes: {
                                count: parseInt(match[5]) || 0, // 点赞总数
                                userLiked: false, // 用户是否已点赞
                                likedBy: [], // 点赞用户列表
                                lastLikeTime: null // 最后点赞时间
                            }
                        };
                        
                        momentdiv = $("<div>", { 
                            class: "user_moment",
                            "data-moment-id": momentId // 添加动态ID属性
                        });
                        momentdiv.html(
                            _.template(moment_page)({
                                userName: match[1],
                                message: message,
                                timestamp: match[3],
                                additionalInfo: match[4],
                                randomPhone: randomPhone,
                                extraContent: match[5],
                                imgcontent: fakeimg,
                                momentId: momentId, // 传递动态ID到模板
                                // 新增：点赞相关数据
                                likeCount: currentMomentData.likes.count,
                                likedByUser: currentMomentData.likes.userLiked
                            }),
                        );
                        list = momentdiv.find(".user_leave_message_list");
                        continue;
                    }
                    match = line.match(/^\s*(.+?)(?::|：|--)(.+)$/m);
                    if (match && momentdiv && list && currentMomentData) {
                        // 是评论内容
                        //console.log(`评论人:${match[1]}  评论内容:${match[2]}`)
                        
                        // *** 新增：保存评论到数据对象 ***
                        const commentData = {
                            name: match[1],
                            content: match[2],
                            timestamp: new Date().toISOString()
                        };
                        currentMomentData.comments.push(commentData);
                        
                        // *** 新增：应用评论显示上限 ***
                        if (list.find('.user_leave_message').length >= 8) {
                            list.find('.user_leave_message').first().remove();
                        }
                        
                        let messageDiv = $("<div>", {
                            class: "user_leave_message",
                        });
                        messageDiv.html(
                            `<span><strong>${match[1]}</strong>：${match[2]}</span>`,
                        );
                        list.append(messageDiv);
                    }
                }
                
                // *** 保存最后一个动态数据 ***
                if (currentMomentData && momentdiv) {
                    QQ_MomentsData.unshift(currentMomentData);
                    count += 1;
                    $("#space_contents").prepend(momentdiv);
                }
                
                QQ_NewMsg["moment"] = count;
                QQ_SetNewTips(count);
                
                // *** 新增：自动保存动态内容 ***
                if (QQ_MomentsData.length > 0) {
                    setTimeout(async () => {
                        await QQ_Save_Moments();
                        console.log('动态解析完成，已保存到世界书备份');
                    }, 1000); // 延迟保存，确保所有处理完成
                }
            }
            function QQ_GetRandomHead() {
                // return `http://sharkpan.xyz/f/${random_head_list[Math.floor(Math.random() * random_head_list.length)]
                //   }`;
                if (QQ_RandomHead.length === 0) return null; // 处理空数组
                let minCount = Infinity;
                const candidates = [];
                // 一次遍历找到最小值和候选对象
                for (const obj of QQ_RandomHead) {
                    if (obj.count < minCount) {
                        minCount = obj.count;
                        candidates.length = 0; // 清空数组，重置候选
                        candidates.push(obj);
                    } else if (obj.count === minCount) {
                        candidates.push(obj);
                    }
                }
                // 随机选择一个（即使只有一个元素也适用）
                const selected =
                    candidates[Math.floor(Math.random() * candidates.length)];
                selected.count++; // 直接修改原对象
                return selected.url;
            }
            let Phone = [
                "小米",
                "华为",
                "苹果",
                "三星",
                "魅族",
                "一加",
                "oppo",
                "vivo",
                "真我",
                "红米",
            ];
            let Phone_lvl = ["pro", "max", "mate", "ultra", "plus"];
            function QQ_GetRandomPhone() {
                let name = Phone[Math.floor(Math.random() * Phone.length)];
                name += random(6, 19);
                let count = random(1, Phone_lvl.length);
                let a = [];
                for (let i = 0; i < count; i++) {
                    let randomresult = Phone_lvl[random(0, Phone_lvl.length)];
                    if (!a.includes(randomresult)) {
                        a.push(randomresult);
                    }
                }
                name += " " + a.join(" ");
                return name;
            }
                        /**
             * 根据角色名获取头像URL
             * @param {string} name - 角色名
             * @returns {string} - 头像URL，如果找不到则返回空字符串
             */
             function GetCharHead(name) {
                // 确保 QQ_Char 对象存在，并且包含该角色的信息和头像
                if (typeof QQ_Char !== 'undefined' && QQ_Char[name] && QQ_Char[name].head) {
                    return QQ_Char[name].head;
                }
                // 如果找不到，返回空字符串，让后续逻辑处理默认头像
                return "";
            }
             /**
             * 聊天-添加新消息
             * @param {*} dom - 消息内容容器的DOM元素
             * @param {*} content - 消息内容字符串
             * @param {*} name - 角色/群聊名称
             * @param {*} isNew - 是否为新消息
             */
            function QQ_Chat_AddMsg(dom, content, name, isNew, skipScrollAndCount = false) {
                console.log(`QQ_Chat_AddMsg: 添加消息 "${content}" 到聊天页面 "${name}", isNew: ${isNew}`);
                
                // *** 分页控制：检查当前消息数量 ***
                if (!skipScrollAndCount) {
                    const chatKey = name;
                    if (!chatDisplayCounts[chatKey]) {
                        chatDisplayCounts[chatKey] = 0;
                    }
                    
                    // 获取当前聊天容器中的消息数量
                    const currentMsgCount = $(dom).children().not('.load-more-messages').length;
                    if (currentMsgCount >= CHAT_DISPLAY_LIMIT && isNew) {
                        // 如果已达上限且是新消息，移除最旧的消息
                        $(dom).children().not('.load-more-messages').first().remove();
                        chatDisplayCounts[chatKey] = CHAT_DISPLAY_LIMIT - 1;
                    }
                }
                
                // *** 核心改造：判断是否为系统消息 ***
                if (content.startsWith("系统消息--")) {
                    const sysMsgText = content.split("--")[2]; // 提取真实的消息内容
                    const msgDiv = $("<div>", { class: "system-message" }).text(sysMsgText);
                    $(dom).append(msgDiv);
                } else {
                    // --- 修复：使用正确的模板系统 ---
                    let sp = content.split("--");
                    
                    if (sp.length < 2) {
                        console.log(`消息格式不正确: ${content}`);
                        return;
                    }
                    
                    const sender = sp[0];
                    const messageContent = sp[1];
                    const timestamp = sp.length >= 3 ? sp[2] : "";
                    
                    console.log(`消息发送者: ${sender}, 内容: ${messageContent}, 时间: ${timestamp}`);
                    
                    // 判断是否为用户消息
                    const isUser = sender == `${UserName}`;
                    
                    let messageHtml;
                    
                    if (isUser) {
                        // 用户消息 - 使用用户消息模板（右侧气泡，用户头像）
                        const specialContent = QQ_Chat_SpecialMsg(messageContent, sender, QQ_Groups.includes(name), true);
                        messageHtml = _.template(chat_user_message)({
                            content: specialContent || messageContent
                        });
                        console.log('使用用户消息模板');
                    } else {
                        // 角色消息 - 使用角色消息模板（左侧气泡，角色头像）
                        const specialContent = QQ_Chat_SpecialMsg(messageContent, sender, QQ_Groups.includes(name), false);
                        messageHtml = _.template(chat_char_msg)({
                            content: specialContent || messageContent,
                            name: sender,
                            isgroup: QQ_Groups.includes(name)
                        });
                        console.log('使用角色消息模板，角色名:', sender);
                    }
                    
                    // 添加到聊天界面
                    $(dom).append(messageHtml);
                    console.log(`消息已添加到DOM: ${sender}: ${messageContent}`);
                }
                
                // 更新显示计数
                if (!skipScrollAndCount) {
                    const chatKey = name;
                    chatDisplayCounts[chatKey] = $(dom).children().not('.load-more-messages').length;
                }
                             
                // 滚动到底部（无论是否为新消息，确保用户能看到最新内容）
                if (!skipScrollAndCount && dom && dom.scrollHeight) {
                    $(dom).scrollTop(dom.scrollHeight);
                    console.log(`聊天区域已滚动到底部`);
                }
            }
            function QQ_Chat_AddUserMsg(element, msg) {
                const match = msg.match(/(.+?)--(.+)/);
                if (!match) {
                    return;
                }
                const content = QQ_Chat_SpecialMsg(
                    match[2],
                    `${UserName}`,
                    false,
                    true,
                );
                const html = _.template(chat_user_message)({ content });
                $(element).append(html);
            }
            /**
             * 处理特殊格式消息
             * @param msg 消息内容
             * @param isgroup 是否是群聊
             * @returns 处理后的消息
             */
            function QQ_Chat_SpecialMsg(msg, username, isgroup, mysend) {
                const match = msg.match(/\[(.+?)[\|-](.+?)\]/);
                const xxx = msg.match(/(.+?)\[/);
                const xx = msg.match(/\](.+)/);
                let additionalText = "";
                if (xxx) {
                    additionalText = xxx[1];
                }
                if (xx) {
                    console.log(`前后都有`);
                    additionalText = additionalText
                        ? additionalText + `<br>${xx[1]}`
                        : xx[1];
                }
                if (!match) {
                    // 使用普通消息模板
                    //console.log(`自己的消息,使用的普通模板`);
                    return _.template(chat_normal_message)({
                        message: msg,
                        isgroup: isgroup || false,
                        username: username,
                    });
                }
                const type = match[1];
                if (type == "bqb") {
                    // 使用表情包消息模板
                    console.log(`表情包链接:${QQ_GetEmoji(match[2])}`);
                    return _.template(chat_emoji_message)({
                        emojiUrl: QQ_GetEmoji(match[2]),
                        additionalText: additionalText,
                        isgroup: isgroup || false,
                        username: username,
                    });
                } else if (type == "转账" || type == "zz") {
                    // 使用转账消息模板
                    return _.template(chat_transfer_message)({
                        amount: match[2],
                    });
                } else if (type == "yy") {
                    let file = chat_char_voice_message;
                    if (mysend) {
                        file = chat_my_voice_message;
                    }
                    return _.template(file)({
                        content: match[2],
                        time: Math.ceil(match[2].length / 4).toString(),
                        isgroup: isgroup || false,
                        username: username,
                    });
                } else if (
                    [
                        "img",
                        "image",
                        "video",
                        "imgs",
                        "images",
                        "file",
                        "files",
                        "图片",
                        "视频",
                        "tp",
                    ].includes(type)
                ) {
                    return _.template(chat_fakeimg_message)({
                        isgroup: isgroup || false,
                        username: username,
                        content: match[2],
                        additionalText: additionalText
                            ? `<span style="margin-top: 5px; display: block">${additionalText}</span>`
                            : "",
                    });
                } else if (["music", "音乐"].includes(type)) {
                    let sp = match[2].split("$");
                    let musicname = "";
                    let musicauthor = "";
                    if (sp.length >= 2) {
                        musicname = sp[0];
                        musicauthor = sp[1];
                    }
                    //console.log(`加入音乐:${musicname}----${musicauthor}`);
                    return _.template(chat_music_message)({
                        isgroup: isgroup || false,
                        username: username,
                        musicname: musicname,
                        musicauthor: musicauthor,
                    });
                }
                return "";
            }
            function QQ_MySendSpecial(content) {
                let match = content.match(/\[?(.+?)-(.+?)]?$/m);
                if (match) {
                    let type = match[1];
                    if (["yy", "语音"].includes(type)) {
                        content = `[yy-${match[2]}]`;
                    } else if (["表情包", "表情", "bqb", "bq"].includes(type)) {
                        content = `[bqb-${match[2]}]`;
                    } else if (
                        [
                            "img",
                            "image",
                            "video",
                            "imgs",
                            "images",
                            "file",
                            "files",
                            "图片",
                            "视频",
                            "tp",
                        ].includes(type)
                    ) {
                        content = `[img-${match[2]}]`;
                    }
                }
                return content;
            }
            /**
             * 获取表情包
             * @param name 表情包名称
             * @returns 表情包URL
             */
            function QQ_GetEmoji(name) {
                if (!QQ_emoji.has(name)) {
                    return;
                }
                return QQ_emoji.get(name);
            }
            // 当前正在设置的聊天对象
            let currentSettingChatName = "";
            /**
             * 设置聊天页设置
             * @param event 事件对象
             */
            function QQ_SetChatPageSetting(event) {
                console.log("点击了设置聊天页设置");
                let element = event.currentTarget;
                // 获取当前聊天页的名称
                const chatPageElement = $(element).closest(".QQ_chat_page");
                if (chatPageElement.length === 0) {
                    console.error("无法获取当前聊天页");
                    return;
                }
                currentSettingChatName =
                    chatPageElement.attr("data-name") ?? "";
                console.log(
                    `打开聊天设置页面，当前聊天对象: ${currentSettingChatName}`,
                );
                // 添加遮罩层和弹窗到页面
                if ($(".popup-overlay").length === 0) {
                    $(".card").append('<div class="popup-overlay"></div>');
                }
                if ($(".chat-setting-popup").length === 0) {
                    $(".card").append(
                        chat_page_setting.replace(
                            "${username}",
                            currentSettingChatName,
                        ),
                    );
                    const bubblecolorPicker =
                        document.getElementById("bubble-color");
                    if (bubblecolorPicker) {
                        console.log(`开始监听`);
                        bubblecolorPicker.addEventListener("input", (event) => {
                            const color = event.target.value;
                            $("#bubble-color-input").val(color || "#ffffff");
                            $("#chat-setting-preview").each(function () {
                                this.style.setProperty(
                                    "background-color",
                                    color,
                                    "important",
                                );
                            });
                        });
                    }
                    const TextcolorPicker =
                        document.getElementById("text-color");
                    if (TextcolorPicker) {
                        console.log(`开始监听`);
                        TextcolorPicker.addEventListener("input", (event) => {
                            const color = event.target.value;
                            $("#text-color-input").val(color || "#ffffff");
                            $("#chat-setting-preview").each(function () {
                                const spans = this.querySelectorAll("span");
                                spans.forEach((span) => {
                                    span.style.setProperty(
                                        "color",
                                        color,
                                        "important",
                                    );
                                });
                            });
                        });
                    }
                }
                // 填充已有设置
                loadCurrentSettings(currentSettingChatName);
                // 显示弹窗和遮罩层
                $(".popup-overlay").show();
                $(".chat-setting-popup").show();
            }
            /**
             * 加载当前设置到弹窗
             * @param chatName 聊天对象名称
             */
            function loadCurrentSettings(chatName) {
                const setting = GetChatCharSettingByName(chatName);
                // 填充表单
                let bubbleColor = QQ_CharSettings.readValue(
                    chatName,
                    "气泡颜色",
                );
                let TextColor = QQ_CharSettings.readValue(chatName, "字体颜色");
                let chatBg = QQ_CharSettings.readValue(chatName, "聊天壁纸");
                if (bubbleColor && bubbleColor[0] !== "#") {
                    bubbleColor = "#" + bubbleColor;
                }
                if (TextColor && TextColor[0] !== "#") {
                    TextColor = "#" + TextColor;
                }
                $("#bubble-color").val(bubbleColor || "#ffffff");
                $("#bubble-color-input").val(bubbleColor || "#ffffff");
                $("#text-color").val(TextColor || "#ffffff");
                $("#text-color-input").val(TextColor || "#ffffff");
                $("#chat-bg").val(chatBg || "");
                $("#chat-setting-preview").each(function () {
                    this.style.setProperty(
                        "background-color",
                        bubbleColor,
                        "important",
                    );
                    const spans = this.querySelectorAll("span");
                    spans.forEach((span) => {
                        span.style.setProperty("color", TextColor, "important");
                    });
                });
            }
            function closeSettingPopup() {
                $(".popup-overlay").hide();
                $(".chat-setting-popup").hide();
            }
            /**
             * 保存设置并关闭弹窗
             */
            async function saveSettingAndClose() {
                if (!currentSettingChatName) {
                    console.error("未知的聊天对象");
                    return;
                }
                // 获取设置值
                const bubbleColor = $("#bubble-color-input").val() || "";
                const TextColor = $("#text-color-input").val() || "";
                const chatBg = $("#chat-bg").val() || "";
                console.log(`保存聊天设置: ${currentSettingChatName}`, {
                    bubbleColor,
                    TextColor,
                    chatBg,
                });
                QQ_CharSettings.writeValue(
                    currentSettingChatName,
                    "气泡颜色",
                    bubbleColor,
                );
                QQ_CharSettings.writeValue(
                    currentSettingChatName,
                    "字体颜色",
                    TextColor,
                );
                QQ_CharSettings.writeValue(
                    currentSettingChatName,
                    "聊天壁纸",
                    chatBg,
                );
                const result = QQ_CharSettings.getAllText();
                for (let entry of entries) {
                    if (
                        entry.comment == "手机-角色" ||
                        entry.comment == "手机界面-角色"
                    ) {
                        await setLorebookEntries(worldbook, [
                            { uid: entry.uid, content: result },
                        ]);
                        break;
                    }
                }
                SetCssVariable(currentSettingChatName, "MsgColor", bubbleColor);
                SetCssVariable(currentSettingChatName, "TextColor", TextColor);
                SetCssVariable(
                    currentSettingChatName,
                    "BackGroundImg",
                    `url('${chatBg}')`,
                );
                // 关闭弹窗
                closeSettingPopup();
            }
            function updateTime() {
                const timeElement = document.getElementById("time");
                if (!timeElement) {
                    return;
                }
                const now = new Date();
                const hours = String(now.getHours()).padStart(2, "0");
                const minutes = String(now.getMinutes()).padStart(2, "0");
                //const seconds = String(now.getSeconds()).padStart(2, '0');
                timeElement.textContent = `${hours}:${minutes}`;
                // const dayElement = document.getElementById("day");
                // dayElement.textContent = `${now.getMonth() + 1}月${now.getDate()}日`;
            }
            function App_Load(App_Name) {
                $("#Home_page").hide();
                $("#App_page").show();
                App_HideAll();
                $(`#App_${App_Name}`).show();
            }
            function App_HideAll() {
                const AppNames = ["QQ", "twitter", "discord"];
                for (const name of AppNames) {
                    $(`#App_${name}`).hide();
                }
            }
            // 每秒更新一次时间
            setInterval(updateTime, 1000);
            updateTime();
            
            /**
             * 初始化联络人搜索功能
             */
            async function initContactSearch() {
                console.log("初始化联络人搜索功能");
                
                const searchInput = document.getElementById('contact_search_input');
                const clearBtn = document.getElementById('search_clear_btn');
                const floatingSearchBox = document.getElementById('floating_search_box');
                
                // 检查是否已经初始化过
                if (searchInput && searchInput.hasAttribute('data-initialized')) {
                    console.log("搜索功能已经初始化过，跳过");
                    return;
                }
                
                if (!searchInput) {
                    console.error("搜索输入框未找到 (ID: contact_search_input)");
                    return;
                }
                if (!clearBtn) {
                    console.error("清除按钮未找到 (ID: search_clear_btn)");
                    return;
                }
                if (!floatingSearchBox) {
                    console.error("搜索框容器未找到 (ID: floating_search_box)");
                    return;
                }
                
                // 防抖函数，避免频繁搜索
                let searchTimeout;
                function debounceSearch(searchTerm) {
                    clearTimeout(searchTimeout);
                    searchTimeout = setTimeout(() => {
                        filterContacts(searchTerm);
                    }, 300); // 延迟300ms执行搜索
                }
                
                // 输入框事件监听
                searchInput.addEventListener('input', function(e) {
                    const searchTerm = e.target.value.trim();
                    console.log(`搜索输入: "${searchTerm}"`);
                    
                    // 显示/隐藏清除按钮并更新样式
                    if (searchTerm.length > 0) {
                        clearBtn.style.display = 'block';
                        floatingSearchBox.style.borderColor = 'rgba(25, 154, 255, 0.6)';
                        floatingSearchBox.style.backgroundColor = 'rgba(239, 243, 255, 0.95)';
                    } else {
                        clearBtn.style.display = 'none';
                        floatingSearchBox.style.borderColor = 'rgba(25, 154, 255, 0.2)';
                        floatingSearchBox.style.backgroundColor = 'rgba(239, 243, 255, 0.9)';
                    }
                    
                    // 执行防抖搜索
                    debounceSearch(searchTerm);
                });
                
                // 清除按钮事件监听
                clearBtn.addEventListener('click', function() {
                    searchInput.value = '';
                    clearBtn.style.display = 'none';
                    floatingSearchBox.style.borderColor = 'rgba(25, 154, 255, 0.2)';
                    floatingSearchBox.style.backgroundColor = 'rgba(239, 243, 255, 0.9)';
                    
                    // 清除搜索，立即执行
                    clearTimeout(searchTimeout);
                    filterContacts('');
                    
                    // 重新获得焦点
                    searchInput.focus();
                });
                
                // 搜索框获得焦点时的效果
                searchInput.addEventListener('focus', function() {
                    floatingSearchBox.style.boxShadow = '0 2px 8px rgba(25, 154, 255, 0.3)';
                });
                
                // 搜索框失去焦点时的效果
                searchInput.addEventListener('blur', function() {
                    floatingSearchBox.style.boxShadow = 'none';
                });
                
                // 支持键盘快捷键（Escape 清除搜索）
                searchInput.addEventListener('keydown', function(e) {
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        this.value = '';
                        clearBtn.style.display = 'none';
                        floatingSearchBox.style.borderColor = 'rgba(25, 154, 255, 0.2)';
                        floatingSearchBox.style.backgroundColor = 'rgba(239, 243, 255, 0.9)';
                        clearTimeout(searchTimeout);
                        filterContacts('');
                    }
                });
                
                // 标记搜索功能已初始化
                searchInput.setAttribute('data-initialized', 'true');
                console.log("联络人搜索功能初始化完成");
                
                // 确保群聊功能也已初始化
                if (typeof reinitGroupChat === 'function') {
                    reinitGroupChat();
                }
                
                // 搜索功能初始化不需要重新加载群聊数据
                console.log('initContactSearch: 搜索功能已初始化');
                
                // 初始化联系人分组功能
                if (typeof initContactGroups === 'function') {
                    initContactGroups();
                }
                
                // 检查联络人列表是否存在
                setTimeout(() => {
                    const contactsList = document.querySelector('#QQ_home_chars');
                    const contacts = contactsList ? contactsList.querySelectorAll('.QQ_home_usermsg') : [];
                    console.log(`当前联络人数量: ${contacts.length}`);
                    
                    // 如果没有联络人，可以在控制台看到相关信息
                    if (contacts.length === 0) {
                        console.warn("当前没有联络人数据，搜索功能可能无法显示效果");
                        console.log("请确保世界书中有联络人数据，或者手动添加一些联络人来测试搜索功能");
                    }
                }, 1000);
            }
            
            /**
             * 过滤联络人列表（支持分组）
             * @param {string} searchTerm 搜索关键词
             */
            function filterContacts(searchTerm) {
                const contactsList = document.querySelector('#QQ_home_chars');
                if (!contactsList) {
                    console.error("联络人列表未找到");
                    return;
                }
                
                // 预处理搜索词
                const search = searchTerm.toLowerCase().trim();
                const isEmpty = search === '';
                let totalVisibleCount = 0;
                
                // 添加或移除搜索状态CSS类
                if (isEmpty) {
                    contactsList.classList.remove('searching');
                } else {
                    contactsList.classList.add('searching');
                }
                
                // 处理分组中的联系人
                const contactGroups = contactsList.querySelectorAll('.contact-group');
                contactGroups.forEach(groupElement => {
                    const groupContent = groupElement.querySelector('.group-content');
                    const contacts = groupContent ? groupContent.querySelectorAll('.QQ_home_usermsg') : [];
                    let groupVisibleCount = 0;
                    
                    contacts.forEach(contact => {
                        const isVisible = filterSingleContact(contact, search, searchTerm, isEmpty);
                        if (isVisible) {
                            groupVisibleCount++;
                            totalVisibleCount++;
                        }
                    });
                    
                    // 显示/隐藏分组（如果分组内有匹配的联系人就显示分组）
                    if (!isEmpty) {
                        if (groupVisibleCount > 0) {
                            groupElement.style.display = '';
                            // 如果分组是折叠状态且有搜索结果，展开分组
                            const groupToggle = groupElement.querySelector('.group-toggle');
                            const groupContentDiv = groupElement.querySelector('.group-content');
                            if (groupToggle && groupToggle.classList.contains('collapsed')) {
                                groupToggle.classList.remove('collapsed');
                                groupContentDiv.classList.remove('collapsed');
                                groupContentDiv.classList.add('expanded');
                            }
                        } else {
                            groupElement.style.display = 'none';
                        }
                    } else {
                        // 搜索为空时显示所有分组
                        groupElement.style.display = '';
                    }
                });
                
                // 处理未分组的联系人
                const ungroupedSection = contactsList.querySelector('.ungrouped-contacts');
                if (ungroupedSection) {
                    const ungroupedContacts = ungroupedSection.querySelectorAll('.QQ_home_usermsg');
                    let ungroupedVisibleCount = 0;
                    
                    ungroupedContacts.forEach(contact => {
                        const isVisible = filterSingleContact(contact, search, searchTerm, isEmpty);
                        if (isVisible) {
                            ungroupedVisibleCount++;
                            totalVisibleCount++;
                        }
                    });
                    
                    // 显示/隐藏未分组区域
                    if (!isEmpty) {
                        ungroupedSection.style.display = ungroupedVisibleCount > 0 ? '' : 'none';
                    } else {
                        ungroupedSection.style.display = '';
                    }
                }
                
                // 处理独立的联系人（如果没有分组系统）
                const independentContacts = contactsList.querySelectorAll('.QQ_home_usermsg:not(.contact-group .QQ_home_usermsg):not(.ungrouped-contacts .QQ_home_usermsg)');
                independentContacts.forEach(contact => {
                    const isVisible = filterSingleContact(contact, search, searchTerm, isEmpty);
                    if (isVisible) {
                        totalVisibleCount++;
                    }
                });
                
                // 在控制台输出搜索结果（调试用）
                if (!isEmpty) {
                    console.log(`搜索"${searchTerm}": 找到 ${totalVisibleCount} 个联络人`);
                }
                
                // 如果没有找到任何匹配项，可以显示提示（可选）
                if (!isEmpty && totalVisibleCount === 0) {
                    console.log("没有找到匹配的联络人");
                }
            }
            
            /**
             * 过滤单个联系人
             * @param {Element} contact 联系人元素
             * @param {string} search 搜索词（小写）
             * @param {string} searchTerm 原始搜索词
             * @param {boolean} isEmpty 是否为空搜索
             * @returns {boolean} 是否显示该联系人
             */
            function filterSingleContact(contact, search, searchTerm, isEmpty) {
                const nameElement = contact.querySelector('.QQ_home_name');
                const lastMsgElement = contact.querySelector('.QQ_home_lastmsg');
                
                if (!nameElement) {
                    console.warn("联络人项目缺少姓名元素", contact);
                    return false;
                }
                
                // 获取原始文本内容
                const originalName = nameElement.getAttribute('data-original-text') || nameElement.textContent;
                const name = originalName.toLowerCase();
                const lastMsg = lastMsgElement ? lastMsgElement.textContent.toLowerCase() : '';
                
                // 检查是否匹配搜索条件
                const nameMatches = isEmpty || name.includes(search);
                const msgMatches = isEmpty || lastMsg.includes(search);
                const isMatch = nameMatches || msgMatches;
                
                if (isMatch) {
                    // 显示联络人
                    contact.style.display = '';
                    
                    // 处理高亮显示
                    if (!isEmpty && nameMatches) {
                        highlightContactSearchTerm(nameElement, searchTerm, originalName);
                    } else {
                        // 恢复原始文本，移除高亮
                        if (nameElement.getAttribute('data-original-text')) {
                            nameElement.innerHTML = originalName;
                        }
                    }
                    
                    return true;
                } else {
                    // 隐藏不匹配的联络人
                    contact.style.display = 'none';
                    return false;
                }
            }
            
            /**
             * 联系人搜索高亮功能
             * @param {Element} element 要高亮的元素
             * @param {string} searchTerm 搜索词
             * @param {string} originalText 原始文本
             */
            function highlightContactSearchTerm(element, searchTerm, originalText) {
                if (!searchTerm || searchTerm.trim() === '') {
                    element.innerHTML = originalText;
                    return;
                }
                
                // 保存原始文本
                if (!element.getAttribute('data-original-text')) {
                    element.setAttribute('data-original-text', originalText);
                }
                
                // 创建高亮HTML
                const regex = new RegExp(`(${searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
                const highlightedText = originalText.replace(regex, '<span style="background-color: #FFE066; color: #333; font-weight: bold; padding: 1px 2px; border-radius: 2px;">$1</span>');
                
                element.innerHTML = highlightedText;
            }
            
            /**
             * 高亮搜索词
             * @param {Element} element 要高亮的元素
             * @param {string} searchTerm 搜索词
             */
            function highlightSearchTerm(element, searchTerm) {
                // 保存原始文本（如果还没有保存）
                if (!element.getAttribute('data-original-text')) {
                    element.setAttribute('data-original-text', element.textContent);
                }
                
                const originalText = element.getAttribute('data-original-text');
                
                // 如果搜索词为空，恢复原始文本
                if (!searchTerm || searchTerm.trim() === '') {
                    element.innerHTML = originalText;
                    return;
                }
                
                // 转义特殊字符，防止正则表达式错误
                const escapedSearchTerm = searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const regex = new RegExp(`(${escapedSearchTerm})`, 'gi');
                const highlightedText = originalText.replace(regex, '<span class="search-highlight">$1</span>');
                
                element.innerHTML = highlightedText;
            }
        </script>

        <!-- 群聊管理下拉菜单 -->
        <div id="group_management_dropdown" class="group-management-dropdown" style="display: none;">
            <div class="group-management-header">
                <div class="group-management-title">群聊成员</div>
                <svg class="group-settings-icon" onclick="showGroupSettings()" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12,15.5A3.5,3.5 0 0,1 8.5,12A3.5,3.5 0 0,1 12,8.5A3.5,3.5 0 0,1 15.5,12A3.5,3.5 0 0,1 12,15.5M19.43,12.97C19.47,12.65 19.5,12.33 19.5,12C19.5,11.67 19.47,11.34 19.43,11.03L21.54,9.37C21.73,9.22 21.78,8.95 21.66,8.73L19.66,5.27C19.54,5.05 19.27,4.96 19.05,5.05L16.56,6.05C16.04,5.66 15.5,5.32 14.87,5.07L14.5,2.42C14.46,2.18 14.25,2 14,2H10C9.75,2 9.54,2.18 9.5,2.42L9.13,5.07C8.5,5.32 7.96,5.66 7.44,6.05L4.95,5.05C4.73,4.96 4.46,5.05 4.34,5.27L2.34,8.73C2.22,8.95 2.27,9.22 2.46,9.37L4.57,11.03C4.53,11.34 4.5,11.67 4.5,12C4.5,12.33 4.53,12.65 4.57,12.97L2.46,14.63C2.27,14.78 2.22,15.05 2.34,15.27L4.34,18.73C4.46,18.95 4.73,19.03 4.95,18.95L7.44,17.94C7.96,18.34 8.5,18.68 9.13,18.93L9.5,21.58C9.54,21.82 9.75,22 10,22H14C14.25,22 14.46,21.82 14.5,21.58L14.87,18.93C15.5,18.68 16.04,18.34 16.56,17.94L19.05,18.95C19.27,19.03 19.54,18.95 19.66,18.73L21.66,15.27C21.78,15.05 21.73,14.78 21.54,14.63L19.43,12.97Z"/>
                </svg>
            </div>
            <div class="group-members-list" id="group_members_display">
                <!-- 群成员列表将在这里动态生成 -->
            </div>
        </div>
        
        <!-- 群聊设置模态窗口 -->
        <div id="group_settings_modal" class="group-settings-modal">
            <div class="group-settings-content">
                <div class="group-settings-header">
                    <h3 class="group-settings-title">群聊设置</h3>
                </div>
                <div class="group-settings-body">
                    <div class="group-settings-section">
                        <div class="group-settings-section-title">群聊名称</div>
                        <input type="text" id="group_name_edit" class="group-settings-input" placeholder="输入群聊名称">
                    </div>
                    <div class="group-settings-section">
                        <div class="group-settings-section-title">群聊头像</div>
                        <div class="group-settings-avatar-container">
                            <div class="group-settings-avatar-preview" id="group_settings_avatar_preview" onclick="showGroupAvatarSelector()">
                                <div class="group-settings-default-avatar">群</div>
                            </div>
                            <div class="group-settings-avatar-text" onclick="showGroupAvatarSelector()">点击更换头像</div>
                        </div>
                    </div>
                    <div class="group-settings-section">
                        <div class="group-settings-section-title">群成员管理</div>
                        <div class="group-settings-member-list" id="group_members_edit">
                            <!-- 群成员编辑列表将在这里动态生成 -->
                        </div>
                    </div>
                </div>
                <div class="group-settings-actions">
                    <button class="group-settings-btn group-settings-cancel-btn" onclick="closeGroupSettings()">取消</button>
                    <button class="group-settings-btn group-settings-save-btn" onclick="saveGroupSettings()">保存</button>
                    <button class="group-settings-btn group-settings-delete-btn" onclick="deleteCurrentGroup()">删除群聊</button>
                </div>
            </div>
        </div>

        <!-- 群聊创建弹窗系统 -->
        <!-- 第一层弹窗：选择创建类型 -->
        <div id="group_chat_modal" class="group-chat-modal" style="display: none;">
            <div class="group-chat-dialog">
                <div class="group-chat-header">
                    新建
                </div>
                <div class="group-chat-content">
                    <div class="group-chat-option" onclick="openGroupCreateModal()">
                        <svg class="group-chat-option-icon" viewBox="0 0 1024 1024">
                            <path d="M320 896c-35.2 0-64-28.8-64-64V288c0-35.2 28.8-64 64-64s64 28.8 64 64v544c0 35.2-28.8 64-64 64zM704 896c-35.2 0-64-28.8-64-64V288c0-35.2 28.8-64 64-64s64 28.8 64 64v544c0 35.2-28.8 64-64 64zM512 1024c-106.039 0-192-85.961-192-192s85.961-192 192-192 192 85.961 192 192-85.961 192-192 192z m0-128c70.692 0 128-57.308 128-128s-57.308-128-128-128-128 57.308-128 128 57.308 128 128 128z"/>
                        </svg>
                        <span class="group-chat-option-text">发起群聊</span>
                    </div>
                    <div class="group-chat-option" onclick="openContactGroupModal()">
                        <svg class="group-chat-option-icon" viewBox="0 0 1024 1024">
                            <path d="M853.333 256H682.667c0-47.147-38.187-85.333-85.333-85.333H426.667c-47.147 0-85.333 38.187-85.333 85.333H170.667C123.52 256 85.333 294.187 85.333 341.333v426.667c0 47.147 38.187 85.333 85.333 85.333h682.667c47.147 0 85.333-38.187 85.333-85.333V341.333c0-47.147-38.187-85.333-85.333-85.333zM426.667 256h170.667v85.333H426.667V256zm426.667 512H170.667V341.333h170.667v42.667c0 23.573 19.093 42.667 42.667 42.667s42.667-19.093 42.667-42.667v-42.667h170.667v42.667c0 23.573 19.093 42.667 42.667 42.667s42.667-19.093 42.667-42.667v-42.667h170.667V768z"/>
                        </svg>
                        <span class="group-chat-option-text">新建分组</span>
                    </div>
                    <div class="group-chat-option" onclick="closeGroupChatModal()">
                        <svg class="group-chat-option-icon" viewBox="0 0 1024 1024">
                            <path d="M628.64 183.936a64 64 0 0 1 90.368 90.368L557.312 435.84l161.696 161.472a64 64 0 1 1-90.368 90.368L466.944 526.208 305.472 687.68a64 64 0 1 1-90.368-90.368L376.576 435.84 214.88 274.368a64 64 0 0 1 90.368-90.368l161.696 161.472 161.696-161.472z"/>
                        </svg>
                        <span class="group-chat-option-text">添加朋友</span>
                    </div>
                    <div class="group-chat-option" onclick="closeGroupChatModal()">
                        <svg class="group-chat-option-icon" viewBox="0 0 1024 1024">
                            <path d="M304 176h416c79.4 0 144 64.6 144 144v384c0 79.4-64.6 144-144 144H304c-79.4 0-144-64.6-144-144V320c0-79.4 64.6-144 144-144z m0 64c-44.2 0-80 35.8-80 80v384c0 44.2 35.8 80 80 80h416c44.2 0 80-35.8 80-80V320c0-44.2-35.8-80-80-80H304z"/>
                        </svg>
                        <span class="group-chat-option-text">扫一扫</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- 第二层弹窗：创建群聊 -->
        <div id="group_create_modal" class="group-create-modal" style="display: none;">
            <div class="group-create-dialog">
                <div class="group-create-header">
                    <span class="group-create-title">发起群聊</span>
                    <span class="group-create-close" onclick="closeGroupCreateModal()">&times;</span>
                </div>
                <div class="group-create-content">
                    <div class="group-name-section">
                        <label class="group-name-label">群聊名称</label>
                        <input 
                            type="text" 
                            id="group_name_input" 
                            class="group-name-input" 
                            placeholder="请输入群聊名称"
                            maxlength="20"
                        >
                    </div>
                    <div class="group-avatar-section">
                        <label class="group-avatar-label">群聊头像</label>
                        <div class="group-avatar-selector">
                            <div class="group-avatar-preview" id="group_avatar_preview" onclick="showAvatarSelector()">
                                <div class="default-group-avatar">+</div>
                            </div>
                            <div class="group-avatar-text" onclick="showAvatarSelector()">点击设置头像</div>
                        </div>
                    </div>
                    <div class="group-members-section">
                        <div class="group-members-label">选择群成员</div>
                        <div class="group-member-search">
                            <span class="group-search-icon">🔍</span>
                            <input 
                                type="text" 
                                class="group-search-input" 
                                id="group_member_search" 
                                placeholder="搜索联系人..."
                                oninput="filterGroupMembers()"
                                onkeydown="handleGroupSearchKeydown(event)"
                            >
                            <span class="group-search-clear" id="group_search_clear" onclick="clearGroupSearch()">✕</span>
                        </div>
                        <div class="contact-list-container">
                            <div id="contact_list_for_group">
                                <!-- 这里将动态加载联系人列表 -->
                            </div>
                        </div>
                    </div>
                </div>
                <div class="group-create-actions">
                    <button class="group-action-btn group-cancel-btn" onclick="closeGroupCreateModal()">
                        取消
                    </button>
                    <button class="group-action-btn group-confirm-btn" id="group_confirm_btn" onclick="createGroupChat()">
                        创建群聊
                    </button>
                </div>
            </div>
        </div>

        <!-- 头像选择弹窗 -->
        <div id="avatar_selector_modal" class="avatar-selector-modal" style="display: none;">
            <div class="avatar-selector-dialog">
                <div class="avatar-selector-header">
                    <span class="avatar-selector-title">选择群聊头像</span>
                    <span class="avatar-selector-close" onclick="closeAvatarSelector()">&times;</span>
                </div>
                <div class="avatar-selector-content">
                    <div class="avatar-selector-tabs">
                        <div class="avatar-tab active" onclick="switchAvatarTab('preset')">预设头像</div>
                        <div class="avatar-tab" onclick="switchAvatarTab('upload')">上传头像</div>
                        <div class="avatar-tab" onclick="switchAvatarTab('url')">输入链接</div>
                    </div>
                    <div class="avatar-selector-body">
                        <!-- 预设头像选项 -->
                        <div id="preset_avatars" class="avatar-options active">
                            <div class="preset-avatar-grid">
                                <!-- 这里会动态加载预设头像 -->
                            </div>
                        </div>
                        <!-- 上传头像选项 -->
                        <div id="upload_avatars" class="avatar-options">
                            <div class="upload-zone" onclick="triggerFileUpload()">
                                <div class="upload-icon">📁</div>
                                <div class="upload-text">点击上传图片</div>
                                <div class="upload-hint">支持 JPG、PNG 格式</div>
                            </div>
                            <input type="file" id="avatar_upload_input" accept="image/*" style="display: none;" onchange="handleAvatarUpload(event)">
                        </div>
                        <!-- 输入链接选项 -->
                        <div id="url_avatars" class="avatar-options">
                            <div class="url-input-zone">
                                <div class="url-input-title">输入图片链接</div>
                                <input 
                                    type="url" 
                                    id="avatar_url_input" 
                                    class="url-input" 
                                    placeholder="请输入图片链接 (如: https://catbox.moe/...)"
                                    oninput="handleAvatarUrlInput()"
                                >
                                <div class="url-input-hint">
                                    推荐使用 <a href="https://catbox.moe" target="_blank" style="color: #199AFF;">catbox.moe</a> 等图床服务
                                </div>
                                <div id="url_preview_container" class="url-preview-container" style="display: none;">
                                    <div class="url-preview-title">预览</div>
                                    <img id="url_preview_image" class="url-preview-image" alt="预览图片">
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="avatar-selector-actions">
                    <button class="avatar-action-btn avatar-cancel-btn" onclick="closeAvatarSelector()">
                        取消
                    </button>
                    <button class="avatar-action-btn avatar-confirm-btn" id="avatar_confirm_btn" onclick="confirmAvatarSelection()">
                        确认
                    </button>
                </div>
            </div>
        </div>

        <!-- 新建分组弹窗 -->
        <div id="new_group_modal" class="new-group-modal">
            <div class="new-group-dialog">
                <div class="new-group-title">新建分组</div>
                <input 
                    type="text" 
                    id="new_group_name_input"
                    class="new-group-input" 
                    placeholder="请输入分组名称"
                    maxlength="15"
                    onkeydown="handleNewGroupKeydown(event)"
                >
                <div class="new-group-actions">
                    <button class="new-group-btn new-group-cancel" onclick="closeNewGroupModal()">
                        取消
                    </button>
                                    <button class="new-group-btn new-group-confirm" onclick="createNewContactGroup()">
                    创建
                </button>
                </div>
            </div>
        </div>

        <!-- 添加成员弹窗 -->
        <div id="add_member_modal" class="add-member-modal" style="display: none;">
            <div class="add-member-dialog">
                <div class="add-member-header">
                    <h3 class="add-member-title">选择群成员</h3>
                    <span class="add-member-close" onclick="closeAddMemberModal()">&times;</span>
                </div>
                <div class="add-member-content">
                    <div class="add-member-search">
                        <input 
                            type="text" 
                            class="add-member-search-input" 
                            id="add_member_search_input"
                            placeholder="搜索联系人..."
                            oninput="filterAddMemberContacts()"
                        >
                        <span class="add-member-search-icon">🔍</span>
                    </div>
                    <div class="add-member-contact-list" id="add_member_contact_list">
                        <!-- 联系人列表将在这里动态生成 -->
                    </div>
                </div>
                <div class="add-member-actions">
                    <button class="add-member-btn add-member-cancel-btn" onclick="closeAddMemberModal()">
                        取消
                    </button>
                    <button class="add-member-btn add-member-confirm-btn" id="add_member_confirm_btn" onclick="confirmAddMembers()" disabled>
                        添加成员
                    </button>
                </div>
            </div>
        </div>

        <script>
            // 群聊创建功能JavaScript代码
            
            /**
             * 显示群聊选项弹窗
             */
            function showGroupChatModal() {
                console.log('showGroupChatModal 函数被调用');
                const modal = document.getElementById('group_chat_modal');
                console.log('弹窗元素:', modal);
                
                if (modal) {
                    console.log('显示弹窗...');
                    modal.style.display = 'flex';
                    modal.style.zIndex = '9999';
                    
                    // 添加背景点击关闭功能
                    modal.addEventListener('click', function(e) {
                        if (e.target === modal) {
                            closeGroupChatModal();
                        }
                    });
                    
                    console.log('弹窗已显示，当前样式:', modal.style.display);
                } else {
                    console.error('未找到弹窗元素 (ID: group_chat_modal)');
                    alert('弹窗元素未找到，请检查页面结构');
                }
            }
            
            /**
             * 关闭群聊选项弹窗
             */
            function closeGroupChatModal() {
                const modal = document.getElementById('group_chat_modal');
                if (modal) {
                    modal.style.display = 'none';
                }
            }
            
            /**
             * 打开群聊创建弹窗
             */
            function openGroupCreateModal() {
                // 先关闭第一层弹窗
                closeGroupChatModal();
                
                // 延迟一点时间再显示第二层弹窗，让动画更流畅
                setTimeout(() => {
                    const modal = document.getElementById('group_create_modal');
                    if (modal) {
                        modal.style.display = 'flex';
                        
                        // 加载联系人列表
                        loadContactsForGroup();
                        
                        // 重置表单和搜索
                        document.getElementById('group_name_input').value = '';
                        const searchInput = document.getElementById('group_member_search');
                        if (searchInput) {
                            searchInput.value = '';
                        }
                        const clearBtn = document.getElementById('group_search_clear');
                        if (clearBtn) {
                            clearBtn.classList.remove('show');
                        }
                        updateConfirmButtonState();
                        
                        // 添加背景点击关闭功能
                        modal.addEventListener('click', function(e) {
                            if (e.target === modal) {
                                closeGroupCreateModal();
                            }
                        });
                    }
                }, 150);
            }
            
            /**
             * 关闭群聊创建弹窗
             */
            function closeGroupCreateModal() {
                const modal = document.getElementById('group_create_modal');
                if (modal) {
                    modal.style.display = 'none';
                }
            }
            
            /**
             * 加载联系人列表到群聊创建弹窗
             */
            function loadContactsForGroup() {
                const contactListContainer = document.getElementById('contact_list_for_group');
                const homeChars = document.getElementById('QQ_home_chars');
                
                if (!contactListContainer || !homeChars) return;
                
                // 清空之前的内容
                contactListContainer.innerHTML = '';
                
                // 获取所有联系人
                const contacts = homeChars.querySelectorAll('.QQ_home_usermsg');
                
                if (contacts.length === 0) {
                    contactListContainer.innerHTML = '<div style="text-align: center; color: #999; padding: 20px;">暂无联系人</div>';
                    return;
                }
                
                // 为每个联系人创建复选框项（排除群聊）
                contacts.forEach((contact, index) => {
                    const nameElement = contact.querySelector('.QQ_home_name');
                    const headElement = contact.querySelector('.QQ_home_head');
                    
                    if (!nameElement) return;
                    
                    // 跳过群聊类型的联系人
                    if (contact.hasAttribute('data-group-type')) {
                        return;
                    }
                    
                    const contactName = nameElement.textContent.trim();
                    
                    // 获取头像样式 - 直接复制原始元素的所有样式
                    let avatarStyle = '';
                    let hasRealAvatar = false;
                    
                    if (headElement) {
                        // 直接获取内联样式
                        const inlineStyle = headElement.getAttribute('style') || '';
                        
                        // 获取计算样式
                        const computedStyle = window.getComputedStyle(headElement);
                        const backgroundImage = computedStyle.backgroundImage;
                        const backgroundColor = computedStyle.backgroundColor;
                        
                        // console.log('头像调试信息:', {
                        //     inlineStyle,
                        //     backgroundImage,
                        //     backgroundColor,
                        //     contactName
                        // });
                        
                        if (inlineStyle && inlineStyle.includes('background')) {
                            // 优先使用内联样式
                            avatarStyle = inlineStyle;
                            hasRealAvatar = inlineStyle.includes('background-image');
                        } else if (backgroundImage && backgroundImage !== 'none') {
                            avatarStyle = `background-image: ${backgroundImage}; background-size: cover; background-position: center;`;
                            hasRealAvatar = true;
                        } else if (backgroundColor && backgroundColor !== 'rgba(0, 0, 0, 0)' && backgroundColor !== 'transparent') {
                            avatarStyle = `background-color: ${backgroundColor};`;
                        }
                        
                        // 如果没有找到有效的背景，使用默认颜色
                        if (!avatarStyle || avatarStyle === '') {
                            const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8', '#F7DC6F'];
                            const color = colors[index % colors.length];
                            avatarStyle = `background-color: ${color};`;
                        }
                    } else {
                        // 默认头像颜色
                        const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8', '#F7DC6F'];
                        const color = colors[index % colors.length];
                        avatarStyle = `background-color: ${color};`;
                    }
                    
                    const contactItem = document.createElement('div');
                    contactItem.className = 'contact-item';
                    contactItem.setAttribute('data-contact-name', contactName);
                    contactItem.setAttribute('data-contact-index', index);
                    contactItem.onclick = () => toggleContactSelection(contactItem);
                    
                    contactItem.innerHTML = `
                        <input 
                            type="checkbox" 
                            id="contact_${index}" 
                            class="contact-checkbox"
                            data-contact-name="${contactName}"
                        >
                        <div class="contact-avatar" style="${avatarStyle}">
                            ${!hasRealAvatar ? 
                                `<span style="color: white; font-size: 12px; font-weight: bold; display: flex; align-items: center; justify-content: center; height: 100%;">${contactName.charAt(0)}</span>` : 
                                ''
                            }
                        </div>
                        <span class="contact-name">${contactName}</span>
                    `;
                    
                    contactListContainer.appendChild(contactItem);
                });
            }
            
            /**
             * 切换联系人选择状态
             */
            function toggleContactSelection(contactItem) {
                const checkbox = contactItem.querySelector('.contact-checkbox');
                
                if (contactItem.classList.contains('selected')) {
                    // 取消选择
                    contactItem.classList.remove('selected');
                    if (checkbox) checkbox.checked = false;
                } else {
                    // 选择
                    contactItem.classList.add('selected');
                    if (checkbox) checkbox.checked = true;
                }
                
                updateConfirmButtonState();
                
                // 添加选择状态的调试信息
                const contactName = contactItem.getAttribute('data-contact-name');
                const isSelected = contactItem.classList.contains('selected');
                console.log(`联系人 "${contactName}" 选择状态: ${isSelected ? '已选中' : '未选中'}`);
            }
            
            /**
             * 高亮搜索关键字
             */
            function highlightSearchTerm(text, searchTerm) {
                if (!searchTerm || searchTerm.trim() === '') {
                    return text;
                }
                
                const regex = new RegExp(`(${searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
                return text.replace(regex, '<span style="background-color: #FFE066; color: #333; font-weight: bold; padding: 1px 2px; border-radius: 2px;">$1</span>');
            }
            
            /**
             * 群聊成员搜索功能
             */
            function filterGroupMembers() {
                const searchInput = document.getElementById('group_member_search');
                const clearBtn = document.getElementById('group_search_clear');
                const contactItems = document.querySelectorAll('#contact_list_for_group .contact-item');
                const contactListContainer = document.getElementById('contact_list_for_group');
                
                if (!searchInput || !contactItems.length) return;
                
                const searchTerm = searchInput.value.toLowerCase().trim();
                const originalSearchTerm = searchInput.value.trim(); // 保持原始大小写
                
                // 显示/隐藏清除按钮
                if (searchTerm.length > 0) {
                    clearBtn.classList.add('show');
                } else {
                    clearBtn.classList.remove('show');
                }
                
                let visibleCount = 0;
                
                contactItems.forEach(item => {
                    const originalContactName = item.getAttribute('data-contact-name');
                    const contactName = originalContactName.toLowerCase();
                    const nameElement = item.querySelector('.contact-name');
                    
                    if (contactName.includes(searchTerm)) {
                        item.style.display = 'flex';
                        visibleCount++;
                        
                        // 高亮匹配的关键字
                        if (searchTerm.length > 0) {
                            nameElement.innerHTML = highlightSearchTerm(originalContactName, originalSearchTerm);
                        } else {
                            nameElement.textContent = originalContactName;
                        }
                    } else {
                        item.style.display = 'none';
                        // 重置文本内容
                        nameElement.textContent = originalContactName;
                    }
                });
                
                // 显示无搜索结果提示
                let noResultsDiv = contactListContainer.querySelector('.no-results');
                if (visibleCount === 0 && searchTerm.length > 0) {
                    if (!noResultsDiv) {
                        noResultsDiv = document.createElement('div');
                        noResultsDiv.className = 'no-results';
                        noResultsDiv.textContent = '未找到匹配的联系人';
                        contactListContainer.appendChild(noResultsDiv);
                    }
                    noResultsDiv.style.display = 'block';
                } else if (noResultsDiv) {
                    noResultsDiv.style.display = 'none';
                }
            }
            
            /**
             * 清除群聊成员搜索
             */
            function clearGroupSearch() {
                const searchInput = document.getElementById('group_member_search');
                const clearBtn = document.getElementById('group_search_clear');
                
                if (searchInput) {
                    searchInput.value = '';
                    searchInput.focus();
                }
                
                if (clearBtn) {
                    clearBtn.classList.remove('show');
                }
                
                // 清除所有高亮并显示所有联系人
                const contactItems = document.querySelectorAll('#contact_list_for_group .contact-item');
                contactItems.forEach(item => {
                    const nameElement = item.querySelector('.contact-name');
                    const originalName = item.getAttribute('data-contact-name');
                    
                    item.style.display = 'flex';
                    nameElement.textContent = originalName; // 清除高亮
                });
                
                // 隐藏无结果提示
                const noResultsDiv = document.getElementById('contact_list_for_group').querySelector('.no-results');
                if (noResultsDiv) {
                    noResultsDiv.style.display = 'none';
                }
            }
            
            /**
             * 处理群聊搜索键盘事件
             */
            function handleGroupSearchKeydown(event) {
                if (event.key === 'Escape') {
                    clearGroupSearch();
                } else if (event.key === 'Enter') {
                    // 如果只有一个可见的联系人，直接选择它
                    const visibleItems = document.querySelectorAll('#contact_list_for_group .contact-item[style*="flex"], #contact_list_for_group .contact-item:not([style*="none"])');
                    if (visibleItems.length === 1) {
                        toggleContactSelection(visibleItems[0]);
                    }
                }
            }
            
            /**
             * 更新确认按钮状态
             */
            function updateConfirmButtonState() {
                const confirmBtn = document.getElementById('group_confirm_btn');
                const groupNameInput = document.getElementById('group_name_input');
                const selectedItems = document.querySelectorAll('#contact_list_for_group .contact-item.selected');
                
                if (!confirmBtn || !groupNameInput) return;
                
                const hasName = groupNameInput.value.trim().length > 0;
                const hasMembers = selectedItems.length > 0;
                
                confirmBtn.disabled = !(hasName && hasMembers);
                
                console.log('更新群聊确认按钮状态:', {
                    hasName,
                    hasMembers,
                    disabled: confirmBtn.disabled,
                    nameLength: groupNameInput.value.trim().length,
                    selectedCount: selectedItems.length
                });
            }
            
            // 这个函数已被下面更完整的版本替代，已删除重复定义
            
            /**
             * 生成群聊头像（使用群成员头像组合或默认样式）
             */
            function generateGroupAvatar(members) {
                // 简单的群聊头像生成：使用渐变背景
                const colors = [
                    'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                    'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)',
                    'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)',
                    'linear-gradient(135deg, #43e97b 0%, #38f9d7 100%)',
                    'linear-gradient(135deg, #fa709a 0%, #fee140 100%)',
                    'linear-gradient(135deg, #a8edea 0%, #fed6e3 100%)',
                    'linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%)',
                    'linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%)'
                ];
                return colors[Math.floor(Math.random() * colors.length)];
            }
            
            /**
             * 获取当前时间字符串
             */
            function getCurrentTime() {
                const now = new Date();
                const hours = now.getHours().toString().padStart(2, '0');
                const minutes = now.getMinutes().toString().padStart(2, '0');
                return `${hours}:${minutes}`;
            }
            
            // 注意：addGroupToContactList和addGroupToMessageList函数已删除
            // 现在统一使用AddNewGroup函数，它会自动处理联系人列表和消息列表的同步
            
            /**
             * 保存群聊数据到本地存储
             */
            async function saveGroupToStorage(groupData) {
                // 新版本：保存到世界书而不是localStorage
                console.log('saveGroupToStorage被调用，转发到世界书保存');
                console.log('群聊数据:', groupData);
                
                const success = await addGroupToWorldbook(groupData);
                if (success) {
                    console.log('群聊已成功保存到世界书');
                } else {
                    console.error('保存群聊到世界书失败');
                }
                return success;
            }
            
            /**
             * 从本地存储加载群聊数据
             */
             async function loadGroupChatsFromWorldbook() {
                console.log('=== loadGroupChatsFromWorldbook被调用（从独立群聊条目） ===');
                console.log('当前worldbook:', typeof worldbook, worldbook ? '存在' : '不存在');
                
                const groups = [];
                
                console.log('群聊加载：采用与私聊相同的模式，不清理现有项目');
                
                try {
                    // 使用与动态内容存储相同的简单检查
                    if (!worldbook || !entries) {
                        console.warn('世界书功能不可用，无法加载群聊数据');
                            return groups;
                    }
                    
                    console.log('当前entries:', typeof entries, entries ? entries.length : 'undefined');

                    // 查找所有群聊条目 - 使用唯一comment前缀查找
                    const groupEntries = entries.filter(e => e.comment && e.comment.startsWith("手机-群聊-"));
                    console.log('找到的群聊条目数量:', groupEntries.length);
                    
                    if (groupEntries.length === 0) {
                        console.log('没有找到群聊条目，函数执行结束');
                        return groups; // 既然没有群聊，就直接返回
                    }
                    
                    groupEntries.forEach(entry => {
                        if (entry && entry.content) {
                            console.log('>>> 开始处理群聊条目:', entry.key);
                            
                            // 从comment中提取原始群聊名称，用于生成稳定的ID
                            const originalGroupName = entry.comment.replace('手机-群聊-', '');
                            const lines = entry.content.split('\n');
                            let groupData = null;
                            
                            for (const line of lines) {
                                const trimmed = line.trim();
                                if (trimmed.startsWith('[') && trimmed.endsWith(']')) {
                                    const name = trimmed.slice(1, -1);
                                    groupData = { 
                                        name, 
                                        type: 'group',
                                        // 使用comment中的原始名称生成ID，保持稳定性
                                        id: `group_${originalGroupName.replace(/[^a-zA-Z0-9\u4e00-\u9fff]/g, '_')}`
                                    };
                                } else if (groupData && trimmed.includes('类型=群聊')) {
                                    continue;
                                } else if (groupData && trimmed.startsWith('成员=')) {
                                    groupData.members = trimmed.substring(3).split(/[,，]/).map(m => m.trim()).filter(m => m);
                                } else if (groupData && trimmed.startsWith('描述=')) {
                                    groupData.description = trimmed.substring(3);
                                } else if (groupData && trimmed.startsWith('头像=')) {
                                    const avatarReference = trimmed.substring(3);
                                    if (avatarReference.startsWith('data:')) {
                                        groupData.avatar = avatarReference;
                                        groupData.avatarData = avatarReference;
                                    } else {
                                        groupData.avatar = avatarReference;
                                    }
                                }
                            }
                            
                            if (groupData && groupData.name && groupData.members && groupData.members.length > 0) {
                                console.log('解析群聊数据成功:', groupData.name);
                                groups.push(groupData);
                                
                                if (!QQ_Groups.includes(groupData.name)) {
                                    QQ_Groups.push(groupData.name);
                                }
                                
                                // **修复：检查群聊是否已在界面中存在，避免重复创建**
                                const existingGroupElement = $(`.QQ_home_usermsg[data-name='${groupData.name}'][data-group-type='true']`);
                                const groupAlreadyExists = existingGroupElement.length > 0;
                                
                                if (!QQ_msgjson.群聊[groupData.name]) {
                                    QQ_msgjson.群聊[groupData.name] = {
                                        members: groupData.members || [],
                                        msgs: []
                                    };
                                    console.log('在QQ_msgjson.群聊中初始化群聊数据:', groupData.name);
                                } else {
                                    console.log('群聊数据已存在，更新成员列表:', groupData.name);
                                    QQ_msgjson.群聊[groupData.name].members = groupData.members || [];
                                }
                                
                                // **强化修复：只有当群聊不存在且没有初始化过时才调用AddNewGroup，避免重复创建和系统消息**
                                if (!groupAlreadyExists) {
                                    // *** 额外检查：确保这个群聊在当前会话中没有被初始化过 ***
                                    if (!QQ_GroupInitializedSet.has(groupData.name)) {
                                        console.log('群聊不存在且未初始化，调用AddNewGroup函数添加群聊:', groupData.name);
                                    AddNewGroup(groupData.name, groupData.avatar || 'https://files.catbox.moe/skngqq.jpg', groupData.members, groupData.description);
                                    } else {
                                        console.log('群聊在当前会话中已初始化，跳过重复创建:', groupData.name);
                                        // 如果已经初始化过，说明数据已经正确设置，不需要重新创建
                                        // 只需要确保数据同步和标记存在
                                        QQ_GroupInitializedSet.add(groupData.name); // 确保标记存在
                                    }
                                } else {
                                    console.log('群聊已存在于界面中，跳过AddNewGroup调用:', groupData.name);
                                    // 界面存在时也要标记为已初始化，防止后续重复添加初始消息
                                    QQ_GroupInitializedSet.add(groupData.name);
                                }
                                
                                // *** 修复：在加载群聊后立即更新最后消息显示 ***
                                setTimeout(() => {
                                    updateGroupLastMessageDisplay(groupData.name);
                                }, 300);
                                
                               

                            } else {
                                console.log('群聊数据不完整，跳过。解析到的数据:', groupData);
                            }
                        }
                    });
                } catch (error) {
                    console.error('从独立世界书条目加载群聊数据失败:', error);
                }
                
                console.log('从独立世界书条目加载群聊数据完成:', groups.length, '个群聊');
                console.log(`最终QQ_Groups列表:`, QQ_Groups);
                
                return groups;
            }
            
            // 初始化群聊功能的函数
            function initGroupChatFeature() {
                console.log('正在初始化群聊功能...');
                
                // 联系人页面的'+'按钮
                const contactsAddBtn = document.getElementById('contacts_add_btn');
                if (contactsAddBtn) {
                    console.log('找到联系人页面的+按钮，绑定事件...');
                    contactsAddBtn.onclick = function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('联系人页面+按钮被点击');
                        showGroupChatModal();
                    };
                } else {
                    console.warn('未找到联系人页面的+按钮 (ID: contacts_add_btn)');
                }
                
                // 消息页面的'+'按钮
                const messagesAddBtn = document.getElementById('messages_add_btn');
                if (messagesAddBtn) {
                    console.log('找到消息页面的+按钮，绑定事件...');
                    messagesAddBtn.onclick = function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('消息页面+按钮被点击');
                        showGroupChatModal();
                    };
                } else {
                    console.warn('未找到消息页面的+按钮 (ID: messages_add_btn)');
                }
                
                // 群聊名称输入框事件监听
                const groupNameInput = document.getElementById('group_name_input');
                if (groupNameInput) {
                    groupNameInput.addEventListener('input', updateConfirmButtonState);
                    groupNameInput.addEventListener('keydown', function(e) {
                        if (e.key === 'Enter' && !document.getElementById('group_confirm_btn').disabled) {
                            createGroupChat();
                        }
                    });
                }
                
                console.log('群聊功能初始化完成');
            }
            
            // 防止重复加载的标志
            let groupChatInitialized = false;
            
            // QQ_Groups数组保护机制
            function protectQQGroups() {
                if (!Array.isArray(QQ_Groups)) {
                    console.warn('QQ_Groups不是数组，重新初始化');
                    QQ_Groups = [];
                }
            } 
            
            // 启动保护机制
            protectQQGroups();
            
            // 简化的QQ_Groups完整性检查（不重新加载群聊到界面）
            function ensureQQGroupsIntegrity() {
                if (groupChatInitialized && QQ_Groups.length === 0) {
                    console.warn('检测到QQ_Groups为空，但不自动重新加载（避免重复）');
                    console.log('当前页面群聊应该保持可见，问题可能在其他地方');
                    
                    // 仅检查现有界面元素并恢复QQ_Groups
                    const contactsGroups = document.querySelectorAll('#QQ_home_chars [data-group-type="true"]');
                    const messageGroups = document.querySelectorAll('#QQ_message_list_chars [data-group-type="true"]');
                    
                    contactsGroups.forEach(element => {
                        const groupName = element.getAttribute('data-group-name');
                        if (groupName && !QQ_Groups.includes(groupName)) {
                            QQ_Groups.push(groupName);
                            console.log(`从联系人界面恢复群聊到QQ_Groups: ${groupName}`);
                        }
                    });
                    
                    messageGroups.forEach(element => {
                        const groupName = element.getAttribute('data-group-name');
                        if (groupName && !QQ_Groups.includes(groupName)) {
                            QQ_Groups.push(groupName);
                            console.log(`从消息界面恢复群聊到QQ_Groups: ${groupName}`);
                        }
                    });
                    
                    console.log('QQ_Groups恢复后:', QQ_Groups);
                }
            }
            
            // 点击群聊时的完整性检查
            function ensureQQGroupsIntegrityOnClick(groupName) {
                console.log(`群聊 ${groupName} 被点击，检查QQ_Groups完整性`);
                
                // 确保点击的群聊在QQ_Groups中
                if (!QQ_Groups.includes(groupName)) {
                    console.warn(`群聊 ${groupName} 不在QQ_Groups中，添加中...`);
                    QQ_Groups.push(groupName);
                }
                
                // 确保QQ_msgjson中有该群聊的数据结构
                if (!QQ_msgjson.群聊) {
                    QQ_msgjson.群聊 = {};
                }
                if (!QQ_msgjson.群聊[groupName]) {
                    console.log(`在QQ_msgjson.群聊中初始化群聊数据: ${groupName}`);
                    QQ_msgjson.群聊[groupName] = {
                        members: [],
                        msgs: []
                    };
                }
                
                console.log(`群聊 ${groupName} 完整性检查完成`);
            }
            
            // 统一的头像处理函数
            function processGroupAvatar(groupData) {
                console.log('处理群头像:', groupData.name, '头像数据:', groupData.avatar);
                
                // 统一的头像数据处理逻辑
                let avatarDisplay = '';
                const avatarSrc = groupData.avatarData || groupData.avatar;
                
                if (avatarSrc && (avatarSrc.startsWith('data:') || avatarSrc.startsWith('http'))) {
                    // base64数据或网络链接，直接使用
                    avatarDisplay = `<img src="${avatarSrc}" style="width: 100%; height: 100%; object-fit: cover; border-radius: 50%;">`;
                    console.log('使用头像图片，类型:', avatarSrc.startsWith('data:') ? 'base64' : 'URL');
                } else {
                    // 默认显示"群"字
                    avatarDisplay = '群';
                    console.log('使用默认群字头像');
                }
                
                return avatarDisplay;
            }
            
            // 统一的初始化函数
            async function initGroupChatOnce() {
                if (groupChatInitialized) {
                    console.log('群聊功能已初始化，跳过重复初始化');
                    return;
                }
                
                console.log('开始初始化群聊功能...');
                initGroupChatFeature();
                
                // 检查界面是否有群聊元素
                const contactsGroups = document.querySelectorAll('#QQ_home_chars [data-group-type="true"]');
                const messageGroups = document.querySelectorAll('#QQ_message_list_chars [data-group-type="true"]');
                
                console.log('当前界面状态检查:');
                console.log('- QQ_Groups数组长度:', QQ_Groups.length);
                console.log('- 联系人界面群聊元素数量:', contactsGroups.length);
                console.log('- 消息界面群聊元素数量:', messageGroups.length);
                console.log('- worldbook状态:', !!worldbook);
                console.log('- entries状态:', !!entries);
                
                // 如果有群聊数据但界面没有显示，强制重新加载
                if (worldbook && entries) {
                    if (QQ_Groups.length > 0 && contactsGroups.length === 0) {
                        console.log('发现群聊数据但界面未显示，强制重新加载到界面');
                        await loadGroupChatsFromWorldbook();
                    } else if (QQ_Groups.length === 0) {
                        console.log('首次初始化：从世界书加载群聊');
                        await loadGroupChatsFromWorldbook();
                    } else {
                        console.log('群聊数据和界面状态正常，跳过加载');
                    }
                } else {
                    console.log('worldbook或entries未准备好，跳过群聊加载');
                }
                
                groupChatInitialized = true;
                console.log('群聊功能初始化完成');
            }
            
            // 重置群聊初始化状态（用于调试）
            window.resetGroupChatState = function() {
                groupChatInitialized = false;
                console.log('群聊状态已重置');
            };
            
            // 强制重新加载群聊到界面（用于调试）
            window.forceReloadGroupChats = async function() {
                console.log('强制重新加载群聊...');
                if (!worldbook || !entries) {
                    console.error('worldbook或entries未准备好');
                    return;
                }
                try {
                    await loadGroupChatsFromWorldbook();
                    console.log('群聊强制重新加载完成');
                } catch (error) {
                    console.error('强制重新加载群聊失败:', error);
                }
            };
            
            // 单一的初始化调用点
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initGroupChatOnce);
            } else {
                // 延迟执行，确保worldbook和entries都已准备好
                setTimeout(initGroupChatOnce, 1000);
            }
            
            // 添加全局测试函数，便于调试
            window.testGroupChat = function() {
                console.log('测试群聊功能...');
                showGroupChatModal();
            };
            
            // 添加键盘快捷键测试（Ctrl+G）
            document.addEventListener('keydown', function(e) {
                if (e.ctrlKey && e.key === 'g') {
                    e.preventDefault();
                    console.log('通过快捷键调用群聊功能');
                    showGroupChatModal();
                }
            });
            
            // ==================== 联系人分组功能 ====================
            
            // 分组数据存储 - 使用var避免TDZ问题
            var contactGroups = [];
            var draggedElement = null;
            var draggedFromGroup = null;
            
            /**
             * 获取当前角色ID用于数据隔离
             */
            /**
             * *** 增强版：获取当前角色ID函数 - 添加详细调试信息 ***
             */
            function getCurrentCharacterId() {
                try {
                    let result = null;
                    let source = '';
                    
                    // 方式1：优先使用SillyTavern的characterId
                    if (window.SillyTavern && window.SillyTavern.characterId !== undefined) {
                        result = window.SillyTavern.characterId;
                        source = 'SillyTavern.characterId';
                    }
                    
                    // 方式2：尝试调用SillyTavern的getContext方法
                    else if (window.SillyTavern && typeof window.SillyTavern.getContext === 'function') {
                        const context = window.SillyTavern.getContext();
                        if (context && context.characterId !== undefined) {
                            result = context.characterId;
                            source = 'SillyTavern.getContext().characterId';
                        }
                    }
                    
                    // 方式3：从window.this_chid获取（酒馆内部变量）
                    else if (window.this_chid !== undefined) {
                        result = window.this_chid;
                        source = 'window.this_chid';
                    }
                    
                    // 方式4：从URL参数获取
                    else {
                        const urlParams = new URLSearchParams(window.location.search);
                        const charId = urlParams.get('charId') || urlParams.get('characterId');
                        if (charId) {
                            result = charId;
                            source = 'URL参数';
                        }
                    }
                    
                    // 方式5：使用当前角色名
                    if (!result && window.currentCharacterName) {
                        result = window.currentCharacterName;
                        source = 'window.currentCharacterName';
                    }
                    
                    // 方式6：从header中的角色名获取
                    if (!result) {
                        const headerName = document.querySelector('.QQ_home_nick')?.textContent?.trim();
                        if (headerName) {
                            result = headerName;
                            source = '页面header角色名';
                        }
                    }
                    
                    // 最后的备用方案
                    if (!result) {
                        result = 'default';
                        source = '默认值';
                    }
                    
                    console.log(`🆔 获取角色ID: "${result}" (来源: ${source})`);
                    return result;
                } catch (error) {
                    console.warn('获取角色ID失败，使用默认值:', error);
                    return 'default';
                }
            }
            
            // 全局变量记录当前角色ID，用于检测角色切换
            let currentCharId = null;
            
            /**
             * 检测角色是否切换，如果切换则重新加载分组数据
             */
            function checkCharacterChange() {
                const newCharId = getCurrentCharacterId();
                if (currentCharId !== newCharId) {
                    console.log(`检测到角色切换: ${currentCharId} -> ${newCharId}`);
                    currentCharId = newCharId;
                    loadGroupsFromStorage();
                    renderContactGroups();
                }
            }
            
            /**
             * *** 已移除：getCharacterGroupsKey函数 ***
             * 现在统一使用世界书存储，不再需要localStorage key
             */
            
            /**
             * 从世界书加载分组（按角色隔离）
             */
            async function loadGroupsFromStorage() {
                try {
                    const charId = getCurrentCharacterId() || 'default';
                    console.log(`从世界书加载分组，角色ID: ${charId}`);
                    
                    // *** 简化加载：参考群聊模式，直接从entries查找 ***
                    if (!worldbook || !entries) {
                        console.warn('世界书功能不可用，使用空分组数据');
                        contactGroups.length = 0;
                        return;
                    }
                    
                    const comment = `QQ_分组备份_${charId}`;
                    const targetEntry = entries.find(entry => entry.comment === comment);
                    
                    if (targetEntry && targetEntry.content) {
                        try {
                            const groups = JSON.parse(targetEntry.content);
                            if (Array.isArray(groups)) {
                                contactGroups.length = 0; // 清空现有数组
                                contactGroups.push(...groups); // 添加从世界书加载的数据
                                console.log(`✅ 从世界书直接加载了 ${groups.length} 个分组`);
                            } else {
                                console.warn('世界书分组数据格式无效，使用空数组');
                                contactGroups.length = 0;
                            }
                        } catch (parseError) {
                            console.error('解析世界书分组数据失败:', parseError);
                            contactGroups.length = 0;
                        }
                    } else {
                        console.log('世界书中没有找到分组数据，使用默认空数组');
                        contactGroups.length = 0;
                    }
                } catch (error) {
                    console.error('从世界书加载分组时出错:', error);
                    contactGroups.length = 0;
                }
            }
            
            // 立即初始化contactGroups
            loadGroupsFromStorage().catch(error => {
                console.error('初始化分组数据失败:', error);
            });
            
            /**
             * *** 新增：强制重新加载分组数据 ***
             * 用于在分组操作后立即刷新最新数据
             */
            window.QQ_ForceReloadContactGroups = async function() {
                try {
                    const characterId = getCurrentCharacterId() || 'default';
                    console.log(`🔄 强制从世界书重新加载分组数据，角色ID: ${characterId}`);
                    
                    // 清空内存缓存
                    contactGroups.length = 0;
                    
                    // *** 简化加载：直接使用loadGroupsFromStorage ***
                    await loadGroupsFromStorage();
                    
                    console.log(`✅ 从世界书重新加载了 ${contactGroups.length} 个分组`);
                    if (contactGroups.length > 0) {
                        console.log('📊 分组详情:', contactGroups.map(g => `${g.name}(${g.contacts.length}人)`).join(', '));
                    }
                    
                    return contactGroups;
                } catch (error) {
                    console.error('💥 强制重新加载分组数据失败:', error);
                    return [];
                }
            };
            
            /**
             * 保存分组到世界书（按角色隔离）- 修复版
             */
            /**
             * 保存分组到世界书（按角色隔离）- 增强版
             */
            async function saveGroupsToStorage() {
                try {
                    const charId = getCurrentCharacterId() || 'default';
                    console.log(`🔄 保存分组到世界书，角色ID: ${charId}`);
                    console.log(`📊 当前分组数据: ${contactGroups.length}个分组`, contactGroups.map(g => `${g.name}(${g.contacts.length}人)`));
                    
                    // *** 检查世界书状态 ***
                    if (!worldbook || !entries) {
                        console.error('❌ 世界书功能不可用，无法保存分组数据');
                        return false;
                    }
                    
                    // *** 简化保存：参考群聊模式，直接操作世界书条目 ***
                    const comment = `QQ_分组备份_${charId}`;
                    let targetEntry = entries.find(entry => entry.comment === comment);
                    
                    // 准备保存的数据
                    const jsonData = JSON.stringify(contactGroups, null, 2);
                    
                    if (targetEntry) {
                        // 使用setLorebookEntries更新现有条目
                        await setLorebookEntries(worldbook, [{
                            uid: targetEntry.uid,
                            content: jsonData,
                        }]);
                        console.log(`✅ 分组数据已更新到现有世界书条目: ${comment}`);
                        
                        // 更新本地entries中的对应条目
                        targetEntry.content = jsonData;
                    } else {
                        // 使用createLorebookEntry创建新条目（参考群聊和动态的成功实现）
                        await createLorebookEntry(worldbook, {
                            comment: comment,
                            key: [`此世界书永不触发_分组_${charId}`],
                            content: jsonData,
                            position: "at_depth_as_system",
                            type: "selective", // 绿灯：选择性触发
                            depth: 0,
                            exclude_recursion: true,
                            order: 9998, // 顺序9998，低于动态9999
                            enabled: true,
                        });
                        console.log(`✅ 分组数据已保存到新世界书条目: ${comment}`);
                        
                        // 重新获取entries以包含新创建的条目
                        entries = await getLorebookEntries(worldbook);
                    }
                    
                    // 触发世界书保存
                    await QQ_SafeSaveWorldInfo(`角色${charId}的分组数据`);
                    
                    // *** 修复验证逻辑：重新获取最新的entries数据 ***
                    entries = await getLorebookEntries(worldbook);
                    const verifyEntry = entries.find(entry => entry.comment === comment);
                    
                    if (verifyEntry && verifyEntry.content && verifyEntry.content.includes('"name"')) {
                        console.log(`✅ 分组数据保存验证成功：${contactGroups.length}个分组`);
                        console.log(`📊 世界书条目内容长度: ${verifyEntry.content.length} 字符`);
                        return true;
                    } else {
                        console.error('❌ 分组数据保存验证失败');
                        console.error('验证条目:', verifyEntry ? '找到条目但内容异常' : '未找到条目');
                        // 即使验证失败，如果操作没有抛出异常，我们仍然认为保存可能成功了
                        console.log('⚠️ 尽管验证失败，但保存操作已执行，可能数据已保存');
                        return true; // 改为返回true，避免误报失败
                    }
                    
                } catch (error) {
                    console.error('❌ 保存分组到世界书时出错:', error);
                    return false;
                }
            }
            
            /**
             * 初始化分组功能
             */
            async function initContactGroups() {
                // 初始化当前角色ID
                currentCharId = getCurrentCharacterId();
                
                await loadGroupsFromStorage();
                await renderContactGroups();
                initGroupDragAndDrop();
                
                // 启动角色切换检测
                setInterval(checkCharacterChange, 1000); // 每秒检测一次角色切换
                
                console.log(`分组功能已初始化，当前角色ID: ${currentCharId}`);
            }
            
            /**
             * 初始化拖拽功能
             */
            function initGroupDragAndDrop() {
                // 这里可以添加拖拽相关的初始化代码
                console.log('分组拖拽功能已初始化');
            }
            
            /**
             * 显示新建分组弹窗
             */
            function showNewGroupModal() {
                const modal = document.getElementById('new_group_modal');
                const input = document.getElementById('new_group_name_input');
                
                if (modal && input) {
                    modal.style.display = 'flex';
                    input.value = '';
                    input.focus();
                    
                    // 添加背景点击关闭
                    modal.addEventListener('click', function(e) {
                        if (e.target === modal) {
                            closeNewGroupModal();
                        }
                    });
                }
            }
            
            /**
             * 关闭新建分组弹窗
             */
            function closeNewGroupModal() {
                const modal = document.getElementById('new_group_modal');
                if (modal) {
                    modal.style.display = 'none';
                }
            }
            
            /**
             * 创建新的联系人分组
             */
            async function createNewContactGroup() {
                console.log('🆕 开始创建新分组...');
                
                // *** 关键优化：先从世界书重新加载分组数据 ***
                await QQ_ForceReloadContactGroups();
                
                const input = document.getElementById('new_group_name_input');
                if (!input) {
                    console.error('未找到分组名称输入框元素');
                    alert('界面元素未找到，请刷新页面重试');
                    return;
                }
                
                const groupName = input.value.trim();
                if (!groupName) {
                    alert('请输入分组名称');
                    return;
                }
                
                // 检查分组名是否重复
                if (contactGroups.some(group => group.name === groupName)) {
                    alert('分组名称已存在');
                    return;
                }
                
                // *** 增强：获取角色ID调试信息 ***
                const charId = getCurrentCharacterId() || 'default';
                console.log(`🎭 创建分组，当前角色: ${charId}`);
                
                // 创建新分组
                const newGroup = {
                    id: 'group_' + Date.now(),
                    name: groupName,
                    contacts: [],
                    collapsed: false,
                    order: contactGroups.length
                };
                
                // *** 增强：记录原始状态，以备回滚 ***
                const originalGroups = [...contactGroups];
                
                contactGroups.push(newGroup);
                
                // *** 修复：确保保存完成后再关闭弹窗和显示消息 ***
                try {
                    const saveResult = await saveGroupsToStorage();
                    if (saveResult) {
                        console.log('✅ 新分组保存到世界书成功');
                        
                        closeNewGroupModal();
                        alert('分组"' + groupName + '"创建成功！');
                        
                        console.log('创建新分组成功:', newGroup);
                        
                        // *** 修复：在用户点击确认后立即刷新界面 ***
                        await QQ_ForceReloadContactGroups();
                        await renderContactGroups();
                        console.log('分组创建界面刷新完成');
                    } else {
                        throw new Error('保存函数返回失败');
                    }
                    
                } catch (error) {
                    console.error('❌ 保存新分组失败:', error);
                    
                    // *** 增强：错误回滚机制 ***
                    contactGroups.length = 0;
                    contactGroups.push(...originalGroups);
                    console.log('🔄 已回滚到创建前状态');
                    
                    alert('分组创建失败，请重试: ' + error.message);
                }
            }
            
            /**
             * 处理新建分组输入框的按键事件
             */
            function handleNewGroupKeydown(event) {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    createNewContactGroup();
                } else if (event.key === 'Escape') {
                    event.preventDefault();
                    closeNewGroupModal();
                }
            }
            
            /**
             * *** 新增：分组同步调试工具 ***
             */
            function QQ_Debug_Groups_Sync() {
                const charId = getCurrentCharacterId() || 'default';
                console.log('=== 分组同步状态调试 ===');
                console.log(`🎭 当前角色ID: "${charId}"`);
                console.log(`📱 内存中分组数据: ${contactGroups.length}个分组`);
                console.log('📊 分组详情:', contactGroups.map(g => `${g.name}(${g.contacts.length}人)`));
                
                // 检查世界书条目
                const expectedComment = `QQ_分组备份_${charId}`;
                const worldbookEntry = entries?.find(entry => entry.comment === expectedComment);
                
                if (worldbookEntry) {
                    console.log(`✅ 找到世界书条目: ${expectedComment}`);
                    try {
                        const worldbookData = JSON.parse(worldbookEntry.content);
                        console.log(`📚 世界书中分组数据: ${Array.isArray(worldbookData) ? worldbookData.length : '0'}个分组`);
                        console.log('📊 世界书分组详情:', Array.isArray(worldbookData) ? worldbookData.map(g => `${g.name}(${g.contacts?.length || 0}人)`) : '无数据');
                        
                        // 检查数据一致性
                        if (contactGroups.length === worldbookData.length) {
                            console.log('✅ 内存和世界书数据数量一致');
                        } else {
                            console.warn('⚠️ 内存和世界书数据数量不一致');
                        }
                    } catch (e) {
                        console.error('❌ 世界书数据解析失败:', e);
                    }
                } else {
                    console.warn(`⚠️ 未找到世界书条目: ${expectedComment}`);
                }
                
                console.log('=== 调试完成 ===');
                return {
                    characterId: charId,
                    memoryGroups: contactGroups.length,
                    worldbookEntry: !!worldbookEntry,
                    comment: expectedComment
                };
            }
            
            // 确保函数全局可用
            window.createNewContactGroup = createNewContactGroup;
            window.closeNewGroupModal = closeNewGroupModal;
            window.showNewGroupModal = showNewGroupModal;
            window.handleNewGroupKeydown = handleNewGroupKeydown;
            window.openContactGroupModal = openContactGroupModal;
            window.QQ_Debug_Groups_Sync = QQ_Debug_Groups_Sync;
            
            /**
             * 渲染分组界面
             */
            async function renderContactGroups() {
                const contactsContainer = document.getElementById('QQ_home_chars');
                if (!contactsContainer) return;
                
                // *** 移除重复的重新加载，因为调用者已经负责加载数据 ***
                console.log(`🎨 开始渲染分组界面，当前有 ${contactGroups.length} 个分组`);

                // 使用jQuery来保存群聊和私聊联系人，确保事件绑定不丢失
                const $originalGroupChats = $(contactsContainer).find('.QQ_home_usermsg[data-group-type="true"]');
                const $originalContacts = $(contactsContainer).find('.QQ_home_usermsg:not([data-group-type="true"])');

                // 清空容器，但用jQuery的方式
                $(contactsContainer).empty();

                // 步骤1: 基于最新的QQ_Groups数据过滤并添加群聊，确保它们总在最上方
                if ($originalGroupChats.length > 0) {
                    const $groupChatSection = $('<div></div>');
                    $originalGroupChats.each(function() {
                        const groupName = $(this).attr('data-name');
                        // *** 关键修复：只添加仍在QQ_Groups中的群聊 ***
                        if (groupName && QQ_Groups.includes(groupName)) {
                            console.log('✅ 保留群聊在联系人界面:', groupName);
                            $(this).appendTo($groupChatSection);
                        } else {
                            console.log('❌ 跳过已删除的群聊:', groupName);
                        }
                    });
                    
                    // 只有当有有效群聊时才添加到界面
                    if ($groupChatSection.children().length > 0) {
                        $groupChatSection.appendTo($(contactsContainer));
                    }
                }

                // 步骤2: 渲染私聊的自定义分组
                contactGroups.sort((a, b) => a.order - b.order).forEach(group => {
                    const groupElement = createGroupElement(group);
                    contactsContainer.appendChild(groupElement);
                });

                // 步骤3: 渲染未分组的私聊联系人
                const $ungroupedContacts = $originalContacts.filter(function() {
                    const contactName = $(this).find('.QQ_home_name').text().trim();
                    return !isContactInAnyGroup(contactName);
                });

                if ($ungroupedContacts.length > 0) {
                    const $ungroupedSection = $(`
                        <div class="ungrouped-contacts">
                            <div class="ungrouped-header">未分组联系人</div>
                        </div>
                    `);
                    
                    const $dropZone = $('<div class="drop-zone ungrouped-drop-zone" data-group-id="ungrouped"></div>');

                    $ungroupedContacts.each(function() {
                        $(this).attr('draggable', 'true');
                        $(this).appendTo($ungroupedSection);
                    });

                    $dropZone.appendTo($ungroupedSection);
                    $ungroupedSection.appendTo($(contactsContainer));
                }
            }
            
            /**
             * 创建分组元素
             */
            function createGroupElement(group) {
                const groupDiv = document.createElement('div');
                groupDiv.className = 'contact-group';
                groupDiv.setAttribute('data-group-id', group.id);
                
                const isCollapsed = group.collapsed;
                const contactCount = group.contacts.length;
                
                groupDiv.innerHTML = `
                    <div class="group-header" onclick="toggleGroup('${group.id}')">
                        <span class="group-drag-handle" onmousedown="startGroupDrag(event, '${group.id}')">⋮⋮</span>
                        <span class="group-toggle ${isCollapsed ? 'collapsed' : ''}">▼</span>
                        <span class="group-name" onclick="editGroupName(event, '${group.id}')" data-group-id="${group.id}">${group.name}</span>
                        <span class="group-count">${contactCount}</span>
                        <span class="group-delete-btn" onclick="deleteContactGroup(event, '${group.id}')">×</span>
                    </div>
                    <div class="group-content ${isCollapsed ? 'collapsed' : 'expanded'}">
                        ${group.contacts.map(contact => {
                            // 确保联系人可以拖拽
                            const contactHtml = contact.html.replace(
                                'class="QQ_home_usermsg"',
                                'class="QQ_home_usermsg" draggable="true"'
                            );
                            return contactHtml;
                        }).join('')}
                    </div>
                    <div class="drop-zone" data-group-id="${group.id}"></div>
                `;
                
                return groupDiv;
            }
            
            /**
             * 检查联系人是否在任何分组中
             */
            function isContactInAnyGroup(contactName) {
                return contactGroups.some(group => 
                    group.contacts.some(contact => contact.name === contactName)
                );
            }
            
            /**
             * 切换分组折叠状态
             */
            async function toggleGroup(groupId) {
                // *** 关键优化：先从世界书重新加载分组数据 ***
                await QQ_ForceReloadContactGroups();
                
                const group = contactGroups.find(g => g.id === groupId);
                if (!group) return;
                
                group.collapsed = !group.collapsed;
                await saveGroupsToStorage();
                
                const groupElement = document.querySelector(`[data-group-id="${groupId}"]`);
                const toggle = groupElement.querySelector('.group-toggle');
                const content = groupElement.querySelector('.group-content');
                
                if (group.collapsed) {
                    toggle.classList.add('collapsed');
                    content.classList.remove('expanded');
                    content.classList.add('collapsed');
                } else {
                    toggle.classList.remove('collapsed');
                    content.classList.remove('collapsed');
                    content.classList.add('expanded');
                }
            }
            
            /**
             * 编辑分组名称
             */
            function editGroupName(event, groupId) {
                event.stopPropagation();
                
                const groupNameElement = event.target;
                const currentName = groupNameElement.textContent;
                
                // 创建输入框
                const input = document.createElement('input');
                input.type = 'text';
                input.value = currentName;
                input.className = 'group-name editing';
                input.maxLength = 15;
                
                // 替换元素
                groupNameElement.replaceWith(input);
                input.focus();
                input.select();
                
                // 处理保存
                const saveEdit = async () => {
                    const newName = input.value.trim();
                    if (newName && newName !== currentName) {
                        // *** 关键优化：先从世界书重新加载分组数据 ***
                        await QQ_ForceReloadContactGroups();
                        
                        // 检查重名
                        if (contactGroups.some(g => g.id !== groupId && g.name === newName)) {
                            alert('分组名称已存在');
                            input.focus();
                            return;
                        }
                        
                        // 更新分组名
                        const group = contactGroups.find(g => g.id === groupId);
                        if (group) {
                            group.name = newName;
                            console.log(`🏷️ 分组重命名: ${currentName} → ${newName}`);
                            await saveGroupsToStorage();
                        }
                    }
                    
                    // 恢复显示
                    const newSpan = document.createElement('span');
                    newSpan.className = 'group-name';
                    newSpan.setAttribute('data-group-id', groupId);
                    newSpan.textContent = newName || currentName;
                    newSpan.onclick = (e) => editGroupName(e, groupId);
                    input.replaceWith(newSpan);
                };
                
                // 绑定事件
                input.addEventListener('blur', saveEdit);
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        saveEdit();
                    } else if (e.key === 'Escape') {
                        const newSpan = document.createElement('span');
                        newSpan.className = 'group-name';
                        newSpan.setAttribute('data-group-id', groupId);
                        newSpan.textContent = currentName;
                        newSpan.onclick = (e) => editGroupName(e, groupId);
                        input.replaceWith(newSpan);
                    }
                });
            }
            
            /**
             * 删除联系人分组
             */
            async function deleteContactGroup(event, groupId) {
                event.stopPropagation();
                
                // *** 关键优化：先从世界书重新加载分组数据 ***
                await QQ_ForceReloadContactGroups();
                
                const group = contactGroups.find(g => g.id === groupId);
                if (!group) return;
                
                if (confirm(`确定要删除分组"${group.name}"吗？\n分组中的联系人将移动到未分组区域。`)) {
                    console.log(`🗑️ 删除分组: ${group.name} (${group.contacts.length}人)`);
                    
                    // *** 增强：获取角色ID调试信息 ***
                    const charId = getCurrentCharacterId() || 'default';
                    console.log(`🎭 删除分组，当前角色: ${charId}`);
                    
                    // *** 增强：记录原始状态，以备回滚 ***
                    const originalGroups = [...contactGroups];
                    
                    // *** 修复：确保删除和保存操作正确完成 ***
                    try {
                        // 移除分组
                        contactGroups = contactGroups.filter(g => g.id !== groupId);
                        const saveResult = await saveGroupsToStorage();
                        
                        if (saveResult) {
                            console.log('✅ 分组删除并保存到世界书成功');
                            
                            // *** 修复：立即刷新界面显示最新状态 ***
                            await QQ_ForceReloadContactGroups();
                            await renderContactGroups();
                            console.log('分组删除界面刷新完成');
                        } else {
                            throw new Error('保存函数返回失败');
                        }
                        
                    } catch (error) {
                        console.error('❌ 删除分组失败:', error);
                        
                        // *** 增强：错误回滚机制 ***
                        contactGroups.length = 0;
                        contactGroups.push(...originalGroups);
                        console.log('🔄 已回滚到删除前状态');
                        
                        alert('删除分组失败，请重试: ' + error.message);
                    }
                }
            }
            
            /**
             * 初始化拖拽功能
             */
            function initGroupDragAndDrop() {
                // 添加联系人拖拽支持
                document.addEventListener('dragstart', handleContactDragStart);
                document.addEventListener('dragover', handleDragOver);
                document.addEventListener('drop', handleContactDrop);
                document.addEventListener('dragend', handleDragEnd);
                
                // 为现有联系人添加拖拽属性
                setTimeout(() => {
                    const contacts = document.querySelectorAll('.QQ_home_usermsg:not([data-group-type])');
                    contacts.forEach(contact => {
                        contact.draggable = true;
                        contact.addEventListener('dragstart', handleContactDragStart);
                    });
                }, 200);
                
                console.log('拖拽功能初始化完成');
            }
            
            /**
             * 联系人拖拽开始
             */
            function handleContactDragStart(event) {
                const contact = event.target.closest('.QQ_home_usermsg');
                if (!contact) return;
                
                draggedElement = contact;
                contact.classList.add('dragging');
                
                // 查找联系人当前所在的分组
                const groupContent = contact.closest('.group-content');
                if (groupContent) {
                    const groupElement = groupContent.closest('.contact-group');
                    draggedFromGroup = groupElement ? groupElement.getAttribute('data-group-id') : null;
                } else {
                    draggedFromGroup = null; // 来自未分组区域
                }
                
                // 显示所有拖拽目标区域
                document.querySelectorAll('.drop-zone').forEach(zone => {
                    zone.classList.add('active');
                });
                
                event.dataTransfer.effectAllowed = 'move';
            }
            
            /**
             * 拖拽悬停处理
             */
            function handleDragOver(event) {
                event.preventDefault();
                event.dataTransfer.dropEffect = 'move';
                
                const dropZone = event.target.closest('.drop-zone');
                if (dropZone) {
                    dropZone.style.borderColor = '#199AFF';
                    dropZone.style.backgroundColor = 'rgba(25, 154, 255, 0.2)';
                }
            }
            
            /**
             * 联系人拖拽放置
             */
            async function handleContactDrop(event) {
                event.preventDefault();
                
                const dropZone = event.target.closest('.drop-zone');
                if (!dropZone || !draggedElement) return;
                
                // *** 关键优化：先从世界书重新加载分组数据 ***
                await QQ_ForceReloadContactGroups();
                
                const targetGroupId = dropZone.getAttribute('data-group-id');
                const contactName = draggedElement.querySelector('.QQ_home_name')?.textContent?.trim();
                
                if (!contactName) return;
                
                console.log(`🔄 拖拽联系人: ${contactName} → ${targetGroupId === 'ungrouped' ? '未分组' : '分组'}`);
                
                // 从原分组中移除联系人
                if (draggedFromGroup) {
                    const fromGroup = contactGroups.find(g => g.id === draggedFromGroup);
                    if (fromGroup) {
                        fromGroup.contacts = fromGroup.contacts.filter(c => c.name !== contactName);
                        console.log(`📤 从分组 "${fromGroup.name}" 移除 "${contactName}"`);
                    }
                }
                
                // 处理目标位置
                if (targetGroupId === 'ungrouped') {
                    // 拖拽到未分组区域，不需要添加到任何分组
                    console.log(`📍 联系人 "${contactName}" 已移动到未分组区域`);
                } else {
                    // 添加到目标分组
                    const targetGroup = contactGroups.find(g => g.id === targetGroupId);
                    if (targetGroup) {
                        // 检查是否已经存在
                        if (!targetGroup.contacts.some(c => c.name === contactName)) {
                            targetGroup.contacts.push({
                                name: contactName,
                                html: draggedElement.outerHTML
                            });
                            console.log(`📥 添加 "${contactName}" 到分组 "${targetGroup.name}"`);
                        }
                    }
                }
                
                // 保存并重新渲染
                await saveGroupsToStorage();
                renderContactGroups();
                
                // 重新初始化拖拽功能
                setTimeout(() => {
                    initGroupDragAndDrop();
                }, 100);
            }
            
            /**
             * 拖拽结束处理
             */
            function handleDragEnd(event) {
                // 清理拖拽状态
                if (draggedElement) {
                    draggedElement.classList.remove('dragging');
                    draggedElement = null;
                }
                draggedFromGroup = null;
                
                // 隐藏所有拖拽目标区域
                document.querySelectorAll('.drop-zone').forEach(zone => {
                    zone.classList.remove('active');
                    zone.style.borderColor = '';
                    zone.style.backgroundColor = '';
                });
            }
            
            /**
             * 开始分组拖拽
             */
            function startGroupDrag(event, groupId) {
                event.stopPropagation();
                // 分组拖拽功能将在后续实现
                console.log('开始拖拽分组:', groupId);
            }
            
            /**
             * *** 已移除：旧的localStorage存储函数 ***
             * 现在统一使用世界书存储机制
             */
            
            /**
             * 处理新建分组的键盘事件
             */
            function handleNewGroupKeydown(event) {
                if (event.key === 'Enter') {
                    createNewContactGroup();
                } else if (event.key === 'Escape') {
                    closeNewGroupModal();
                }
            }

            // ==================== 分组弹窗管理功能 ====================
            
            /**
             * 打开分组管理弹窗
             */
            function openContactGroupModal() {
                closeGroupChatModal();
                setTimeout(() => {
                    showNewGroupModal();
                }, 150);
            }

            // ==================== 群聊头像设置功能 ====================
            
            let selectedAvatarData = null; // 存储选中的头像数据
            
            // ==================== 群聊功能增强 ====================
            
            /**
             * 处理聊天标题点击 - 显示群成员列表
             */
            function handleChatTitleClick(element) {
                console.log('=== handleChatTitleClick 被调用 ===');
                
                // *** 调试：检查DOM元素的相关属性 ***
                console.log('点击的聊天标题:', element.textContent.trim());
                console.log('元素数据属性:', {
                    'data-name': element.getAttribute('data-name'),
                    'data-group-id': element.getAttribute('data-group-id')
                });
                
                const chatPageContainer = element.closest('.QQ_chat_page');
                if (!chatPageContainer) {
                    console.log('未找到聊天页面容器');
                    return;
                }
                
                console.log('聊天页面容器:', chatPageContainer);
                console.log('聊天页面容器的data-name:', chatPageContainer.getAttribute('data-name'));
                console.log('聊天页面容器的data-group-id:', chatPageContainer.getAttribute('data-group-id'));
                
                // *** 调试日志：检查多种获取聊天名称的方式 ***
                const chatName = element.textContent.trim();
                const dataName = element.getAttribute('data-name') || chatPageContainer.getAttribute('data-name');
                const groupId = element.getAttribute('data-group-id') || chatPageContainer.getAttribute('data-group-id');
                
                console.log('=== 聊天名称获取调试 ===');
                console.log('从textContent获取的名称:', chatName);
                console.log('从data-name属性获取的名称:', dataName);
                console.log('从data-group-id属性获取的ID:', groupId);
                
                // *** 调试日志：检查全局群聊数据 ***
                console.log('=== 全局数据调试 ===');
                console.log('QQ_Groups数组:', window.QQ_Groups);
                if (window.QQ_Groups && Array.isArray(window.QQ_Groups)) {
                    const matchingGroups = window.QQ_Groups.filter(g => 
                        g.name === chatName || 
                        g.name === dataName || 
                        g.id === groupId ||
                        chatName.includes(g.name) ||
                        (dataName && dataName.includes(g.name))
                    );
                    console.log('匹配的群聊数据:', matchingGroups);
                }
                
                console.log('最终使用的聊天名称:', chatName);
                
                // 检查是否是群聊
                const isGroupChat = checkIfGroupChat(chatName);
                if (isGroupChat) {
                    // 群聊逻辑
                const cleanGroupName = chatName.replace(/\s*\(\d+人\)\s*$/, '').trim();
                
                // 从QQ_msgjson.群聊中获取群聊数据
                let groupData = null;
                if (QQ_msgjson && QQ_msgjson.群聊 && QQ_msgjson.群聊[cleanGroupName]) {
                    const msgGroupData = QQ_msgjson.群聊[cleanGroupName];
                    groupData = {
                        name: cleanGroupName,
                        members: msgGroupData.members || [],
                        avatar: 'https://files.catbox.moe/skngqq.jpg' // 默认头像
                    };
                }
                
                // 如果没有找到群聊数据，创建一个基本的数据结构
                if (!groupData) {
                    groupData = {
                        name: cleanGroupName,
                        members: ['成员1', '成员2', '成员3'], // 示例成员
                        avatar: 'https://files.catbox.moe/skngqq.jpg'
                    };
                    console.warn(`群聊 ${cleanGroupName} 数据未找到，使用默认数据`);
                }
                
                // 调用群聊管理菜单
                console.log('显示群聊管理菜单:', groupData);
                showGroupManagementMenu(groupData, element);
                } else {
                    // 私聊逻辑 - 先显示角色精灵
                    console.log('这是私聊，显示角色精灵');
                    QQ_ShowCharacterSpirit(chatName);
                }
            }
            
            /**
             * 检查是否为群聊（统一使用QQ_Groups数组）
             */
            function checkIfGroupChat(chatName) {
                // 移除标题中的人数信息，只保留群名
                const cleanChatName = chatName.replace(/\s*\(\d+人\)\s*$/, '').trim();
                
                // 使用QQ_Groups数组检查，确保与其他地方的逻辑一致
                return QQ_Groups.includes(cleanChatName);
            }
            
            /**
             * 加载群成员列表
             */
            function loadGroupMembers(groupName, memberListContainer) {
                // 获取群成员数据（这里可以从localStorage或其他数据源获取）
                const groupMembers = getGroupMembers(groupName);
                
                // 清空容器
                memberListContainer.innerHTML = '';
                
                if (groupMembers.length === 0) {
                    memberListContainer.innerHTML = '<div class="no-members">暂无群成员</div>';
                    return;
                }
                
                // 渲染成员列表
                groupMembers.forEach(member => {
                    const memberItem = document.createElement('div');
                    memberItem.className = 'group-member-item';
                    memberItem.innerHTML = `
                        <div class="member-avatar" style="background-image: url('${member.avatar}')"></div>
                        <div class="member-name">${member.name}</div>
                    `;
                    memberListContainer.appendChild(memberItem);
                });
            }
            
            /**
             * 获取群成员数据（从QQ_msgjson.群聊中获取）
             */
            function getGroupMembers(groupName) {
                // 移除可能的人数标识
                const cleanGroupName = groupName.replace(/\s*\(\d+人\)\s*$/, '').trim();
                
                try {
                    // 直接从QQ_msgjson.群聊中获取群聊数据
                    if (QQ_msgjson && QQ_msgjson.群聊 && QQ_msgjson.群聊[cleanGroupName]) {
                        const groupData = QQ_msgjson.群聊[cleanGroupName];
                        
                        if (groupData.members && Array.isArray(groupData.members)) {
                            console.log(`从QQ_msgjson获取群成员: ${cleanGroupName}`, groupData.members);
                            
                            // 获取随机头像列表
                            const avatarList = QQ_RandomHeadList || [
                                'http://sharkpan.xyz/f/EJeUD/Image_1737026320652.jpg',
                                'http://sharkpan.xyz/f/Y8pt1/Image_1737026296736.jpg',
                                'http://sharkpan.xyz/f/QWWc6/Image_1737026308451.jpg',
                                'http://sharkpan.xyz/f/Z8LIW/Image_1737026306601.jpg',
                                'http://sharkpan.xyz/f/W8lhW/Image_1737026313246.jpg'
                            ];
                            
                            return groupData.members.map((memberName, index) => ({
                                name: memberName,
                                avatar: avatarList[index % avatarList.length]
                            }));
                        }
                    }
                    
                    console.warn(`群聊 ${cleanGroupName} 的成员信息未找到，使用示例成员`);
                } catch (error) {
                    console.error('从QQ_msgjson获取群成员失败:', error);
                }
                
                // 如果没有数据，生成一些示例成员
                return generateSampleMembers(cleanGroupName);
            }
            
            /**
             * 生成示例群成员
             */
            function generateSampleMembers(groupName) {
                const sampleMembers = [
                    { name: '群主', avatar: 'http://sharkpan.xyz/f/EJeUD/Image_1737026320652.jpg' },
                    { name: '管理员', avatar: 'http://sharkpan.xyz/f/Y8pt1/Image_1737026296736.jpg' },
                    { name: '成员A', avatar: 'http://sharkpan.xyz/f/QWWc6/Image_1737026308451.jpg' },
                    { name: '成员B', avatar: 'http://sharkpan.xyz/f/Z8LIW/Image_1737026306601.jpg' },
                    { name: '成员C', avatar: 'http://sharkpan.xyz/f/W8lhW/Image_1737026313246.jpg' }
                ];
                
                // 新版本：不再使用localStorage保存群成员数据
                console.log('生成示例群成员（仅内存）:', sampleMembers);
                
                return sampleMembers;
            }
            
            /**
             * 确保消息隔离 - 只发送给当前群组
             */
            function sendGroupMessage(groupName, message) {
                const timestamp = new Date().toLocaleTimeString('zh-CN', { 
                    hour12: false, 
                    hour: '2-digit', 
                    minute: '2-digit' 
                });
                
                // 获取当前群成员
                const members = getGroupMembers(groupName);
                
                // 模拟群成员回复（随机选择1-2个成员回复）
                setTimeout(() => {
                    const replyCount = Math.floor(Math.random() * 2) + 1;
                    const repliedMembers = [];
                    
                    for (let i = 0; i < replyCount; i++) {
                        const randomMember = members[Math.floor(Math.random() * members.length)];
                        if (!repliedMembers.includes(randomMember.name)) {
                            repliedMembers.push(randomMember.name);
                            
                            // 生成回复消息
                            const replyMessage = generateGroupReply(message);
                            
                            // 添加到聊天界面（这里需要根据实际的消息渲染函数调用）
                            console.log(`${randomMember.name}在群"${groupName}"中回复: ${replyMessage}`);
                        }
                    }
                }, Math.random() * 3000 + 1000); // 1-4秒后回复
            }
            
            /**
             * 生成群聊回复内容
             */
            function generateGroupReply(originalMessage) {
                const replies = [
                    '同意！',
                    '哈哈哈',
                    '好的',
                    '收到',
                    '确实如此',
                    '我也觉得',
                    '说得对',
                    '+1',
                    '支持',
                    '赞同'
                ];
                
                return replies[Math.floor(Math.random() * replies.length)];
            }
            
            // 全局注册函数
            window.handleChatTitleClick = handleChatTitleClick;
            window.sendGroupMessage = sendGroupMessage;
            
            /**
             * 显示头像选择器
             */
            function showAvatarSelector() {
                console.log('显示头像选择器');
                const modal = document.getElementById('avatar_selector_modal');
                if (modal) {
                    modal.style.display = 'flex';
                    
                    // 初始化预设头像
                    loadPresetAvatars();
                    
                    // 重置选择状态 - 暂时注释掉，让用户可以选择
                    // selectedAvatarData = null;
                    
                    // 初始状态下启用确认按钮
                    const confirmBtn = document.getElementById('avatar_confirm_btn');
                    if (confirmBtn) {
                        confirmBtn.disabled = false;
                    }
                    
                    updateAvatarConfirmButton();
                    
                    // 添加背景点击关闭功能
                    modal.addEventListener('click', function(e) {
                        if (e.target === modal) {
                            closeAvatarSelector();
                        }
                    });
                    
                    console.log('头像选择器已显示');
                }
            }
            
            /**
             * 关闭头像选择器
             */
            function closeAvatarSelector() {
                console.log('关闭头像选择器');
                const modal = document.getElementById('avatar_selector_modal');
                if (modal) {
                    modal.style.display = 'none';
                }
                
                // 清理群聊头像选择状态
                if (window.isSelectingGroupAvatar) {
                    window.isSelectingGroupAvatar = false;
                    window.currentAvatarGroup = null;
                }
                
                // 不要重置头像数据，让用户的选择保持
                // selectedAvatarData = null;
            }
            
            /**
             * 切换头像选择标签页
             */
            function switchAvatarTab(tabType) {
                console.log('切换到标签页:', tabType);
                
                // 更新标签状态
                document.querySelectorAll('.avatar-tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                document.querySelector(`.avatar-tab[onclick*="${tabType}"]`).classList.add('active');
                
                // 显示对应内容
                document.querySelectorAll('.avatar-options').forEach(option => {
                    option.classList.remove('active');
                });
                document.getElementById(tabType + '_avatars').classList.add('active');
                
                // 如果切换到URL标签页，清空之前的预览
                if (tabType === 'url') {
                    const urlInput = document.getElementById('avatar_url_input');
                    const previewContainer = document.getElementById('url_preview_container');
                    if (urlInput) urlInput.value = '';
                    if (previewContainer) previewContainer.style.display = 'none';
                }
            }
            
            /**
             * 处理头像URL输入
             */
            function handleAvatarUrlInput() {
                const urlInput = document.getElementById('avatar_url_input');
                const previewContainer = document.getElementById('url_preview_container');
                const previewImage = document.getElementById('url_preview_image');
                
                if (!urlInput || !previewContainer || !previewImage) return;
                
                const url = urlInput.value.trim();
                
                if (!url) {
                    previewContainer.style.display = 'none';
                    window.selectedAvatarData = null;
                    updateAvatarConfirmButton();
                    return;
                }
                
                // 简单的URL验证
                try {
                    new URL(url);
                } catch (e) {
                    previewContainer.style.display = 'none';
                    window.selectedAvatarData = null;
                    updateAvatarConfirmButton();
                    return;
                }
                
                // 检查是否是图片URL
                const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp'];
                const isImageUrl = imageExtensions.some(ext => 
                    url.toLowerCase().includes(ext) || 
                    url.toLowerCase().includes('image') ||
                    url.includes('catbox.moe') ||
                    url.includes('imgur.com') ||
                    url.includes('i.imgur.com')
                );
                
                if (!isImageUrl && !url.startsWith('data:image/')) {
                    console.warn('可能不是图片URL:', url);
                }
                
                // 显示预览
                previewImage.onload = function() {
                    console.log('图片加载成功:', url);
                    previewContainer.style.display = 'block';
                    
                    // 保存选中的头像数据
                    window.selectedAvatarData = {
                        type: 'url',
                        url: url
                    };
                    
                    console.log('URL头像数据已保存:', window.selectedAvatarData);
                    updateAvatarConfirmButton();
                };
                
                previewImage.onerror = function() {
                    console.error('图片加载失败:', url);
                    previewContainer.style.display = 'none';
                    window.selectedAvatarData = null;
                    updateAvatarConfirmButton();
                    
                    // 可以显示错误提示
                    const urlInput = document.getElementById('avatar_url_input');
                    if (urlInput) {
                        urlInput.style.borderColor = '#ff6b6b';
                        setTimeout(() => {
                            urlInput.style.borderColor = '';
                        }, 2000);
                    }
                };
                
                previewImage.src = url;
            }
            
            /**
             * 加载预设头像
             */
            function loadPresetAvatars() {
                const gridContainer = document.querySelector('.preset-avatar-grid');
                if (!gridContainer) return;
                
                // 预设头像的渐变色配置
                const avatarGradients = [
                    { start: '#FF6B6B', end: '#EE5A24', text: '群' },
                    { start: '#4ECDC4', end: '#44A08D', text: '聊' },
                    { start: '#45B7D1', end: '#96CEB4', text: '组' },
                    { start: '#FFA07A', end: '#FA8072', text: '团' },
                    { start: '#98D8C8', end: '#F7DC6F', text: '队' },
                    { start: '#BB8FCE', end: '#D2B4DE', text: '圈' },
                    { start: '#F8C471', end: '#F39C12', text: '社' },
                    { start: '#85C1E9', end: '#5DADE2', text: '会' },
                    { start: '#F1948A', end: '#EC7063', text: '友' },
                    { start: '#82E0AA', end: '#58D68D', text: '伴' },
                    { start: '#AED6F1', end: '#7FB3D3', text: '伙' },
                    { start: '#E8DAEF', end: '#D7BDE2', text: '集' }
                ];
                
                gridContainer.innerHTML = '';
                
                avatarGradients.forEach((gradient, index) => {
                    const avatarItem = document.createElement('div');
                    avatarItem.className = 'preset-avatar-item';
                    avatarItem.style.setProperty('--gradient-start', gradient.start);
                    avatarItem.style.setProperty('--gradient-end', gradient.end);
                    avatarItem.textContent = gradient.text;
                    
                    avatarItem.addEventListener('click', () => {
                        console.log('点击预设头像:', gradient);
                        
                        // 移除其他选中状态
                        document.querySelectorAll('.preset-avatar-item').forEach(item => {
                            item.classList.remove('selected');
                        });
                        
                        // 添加选中状态
                        avatarItem.classList.add('selected');
                        
                        // 保存选中的头像数据
                        window.selectedAvatarData = {
                            type: 'preset',
                            gradient: gradient,
                            text: gradient.text
                        };
                        
                        console.log('头像数据已保存:', window.selectedAvatarData);
                        updateAvatarConfirmButton();
                    });
                    
                    gridContainer.appendChild(avatarItem);
                });
            }
            
            /**
             * 触发文件上传
             */
            function triggerFileUpload() {
                document.getElementById('avatar_upload_input').click();
            }
            
            /**
             * 处理头像上传
             */
            function handleAvatarUpload(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                // 检查文件类型
                if (!file.type.startsWith('image/')) {
                    alert('请选择图片文件');
                    return;
                }
                
                // 检查文件大小 (5MB)
                if (file.size > 5 * 1024 * 1024) {
                    alert('图片文件不能超过5MB');
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = async function(e) {
                    console.log('原始图片大小:', e.target.result.length);
                    
                    // 压缩图片以避免localStorage配额问题
                    let imageData;
                    try {
                        imageData = await compressImage(file, 512, 0.8);
                        console.log('图片压缩完成，压缩后大小:', imageData.length);
                    } catch (error) {
                        console.warn('图片压缩失败，使用原图:', error);
                        imageData = e.target.result;
                    }
                    
                    // 直接使用压缩后的base64数据，避免localStorage存储
                    console.log('使用压缩后的base64数据，跳过localStorage存储');
                    
                    // *** 修复：统一的头像上传逻辑 ***
                    // 无论是创建群聊还是群聊设置，都使用相同的逻辑：先保存到selectedAvatarData，然后通过确认按钮统一处理
                    
                    // 群聊创建中的头像上传
                    const uploadZone = document.querySelector('.upload-zone');
                    if (uploadZone) {
                        uploadZone.innerHTML = `
                            <div class="uploaded-preview">
                                <img src="${imageData}" alt="预览" style="width: 120px; height: 120px; border-radius: 12px; object-fit: cover;">
                                <div class="upload-text" style="margin-top: 10px; color: #28a745;">✅ 图片已上传成功（已压缩）</div>
                                <button class="change-image-btn" onclick="triggerFileUpload()" style="margin-top: 8px; padding: 6px 12px; border: 1px solid #ddd; border-radius: 6px; background: white; cursor: pointer;">更换图片</button>
                                <div style="margin-top: 8px; font-size: 12px; color: #666; text-align: center;">
                                    图片已压缩并将直接保存到世界书中
                                </div>
                            </div>
                        `;
                    }
                    
                    // 保存选中的头像数据（使用压缩后的数据）
                    window.selectedAvatarData = {
                        type: 'upload',
                        imageData: imageData  // 直接保存压缩后的完整数据
                    };
                    
                    console.log('上传头像数据已保存:', {
                        type: window.selectedAvatarData.type,
                        hasImageData: !!window.selectedAvatarData.imageData,
                        dataSize: window.selectedAvatarData.imageData.length
                    });
                    
                    updateAvatarConfirmButton();
                };
                
                reader.readAsDataURL(file);
            }
            
            /**
             * 更新确认按钮状态
             */
            function updateAvatarConfirmButton() {
                const confirmBtn = document.getElementById('avatar_confirm_btn');
                if (confirmBtn) {
                    // 总是启用确认按钮，因为可以使用默认头像
                    confirmBtn.disabled = false;
                    console.log('更新头像确认按钮状态:', {
                        hasData: !!window.selectedAvatarData,
                        disabled: confirmBtn.disabled,
                        selectedData: window.selectedAvatarData
                    });
                }
            }
            
            /**
             * 确认头像选择（增强版：支持创建群聊和群聊设置）
             */
            function confirmAvatarSelection() {
                console.log('确认头像选择，当前选中的头像数据:', window.selectedAvatarData);
                console.log('是否在群聊设置中选择头像:', window.isSelectingGroupAvatar);
                
                // 如果没有选择头像，使用默认头像
                if (!window.selectedAvatarData) {
                    window.selectedAvatarData = {
                        type: 'preset',
                        gradient: { start: '#199AFF', end: '#0066CC' },
                        text: '群'
                    };
                    console.log('使用默认头像:', window.selectedAvatarData);
                }
                
                // *** 修复：支持群聊设置中的头像选择 ***
                if (window.isSelectingGroupAvatar) {
                    // 群聊设置中的头像选择
                    const settingsPreviewElement = document.getElementById('group_settings_avatar_preview');
                    const settingsTextElement = document.querySelector('.group-settings-avatar-text');
                    
                    if (settingsPreviewElement && settingsTextElement) {
                        if (window.selectedAvatarData.type === 'preset') {
                            // 预设头像
                            const gradient = window.selectedAvatarData.gradient;
                            settingsPreviewElement.style.background = `linear-gradient(135deg, ${gradient.start}, ${gradient.end})`;
                            settingsPreviewElement.style.backgroundImage = 'none';
                            settingsPreviewElement.innerHTML = `<div class="default-group-avatar">${window.selectedAvatarData.text}</div>`;
                            settingsTextElement.textContent = '已选择预设头像';
                        } else if (window.selectedAvatarData.type === 'upload') {
                            // 上传的头像
                            settingsPreviewElement.style.background = 'none';
                            settingsPreviewElement.style.backgroundImage = `url('${window.selectedAvatarData.imageData}')`;
                            settingsPreviewElement.style.backgroundSize = 'cover';
                            settingsPreviewElement.style.backgroundPosition = 'center';
                            settingsPreviewElement.style.backgroundRepeat = 'no-repeat';
                            settingsPreviewElement.innerHTML = '';
                            settingsTextElement.textContent = '已选择自定义头像';
                        }
                        
                        console.log('群聊设置头像预览已更新');
                    } else {
                        console.error('找不到群聊设置头像预览元素');
                    }
                    
                    // 清理群聊设置相关的标志
                    window.isSelectingGroupAvatar = false;
                    window.currentAvatarGroup = null;
                } else {
                    // 创建群聊时的头像选择（原逻辑）
                    const previewElement = document.getElementById('group_avatar_preview');
                    const textElement = document.querySelector('.group-avatar-text');
                    
                    if (!previewElement || !textElement) {
                        console.error('找不到创建群聊头像预览元素');
                        closeAvatarSelector();
                        return;
                    }
                    
                    if (window.selectedAvatarData.type === 'preset') {
                        // 预设头像
                        const gradient = window.selectedAvatarData.gradient;
                        previewElement.style.background = `linear-gradient(135deg, ${gradient.start}, ${gradient.end})`;
                        previewElement.style.backgroundImage = 'none';
                        previewElement.innerHTML = `<div class="default-group-avatar">${window.selectedAvatarData.text}</div>`;
                        textElement.textContent = '已设置预设头像';
                    } else if (window.selectedAvatarData.type === 'upload') {
                        // 上传的头像
                        previewElement.style.background = 'none';
                        previewElement.style.backgroundImage = `url('${window.selectedAvatarData.imageData}')`;
                        previewElement.style.backgroundSize = 'cover';
                        previewElement.style.backgroundPosition = 'center';
                        previewElement.innerHTML = '';
                        textElement.textContent = '已设置自定义头像';
                    }
                    
                    console.log('创建群聊头像预览已更新');
                }
                
                console.log('头像设置成功，关闭选择器');
                closeAvatarSelector();
            }

            // ==================== 群聊功能增强 ====================
            
            /**
             * 改进的群聊创建功能（带头像支持）
             */
            // 旧的createGroupChat函数已移除，现在使用window.createGroupChat（世界书逻辑）
            
            /**
             * 检查世界书中的群聊内容
             */
            function checkWorldbookGroups() {
                console.log('=== 检查世界书中的独立群聊条目 ===');
                
                if (!entries) {
                    console.log('entries未定义，无法检查群聊');
                    return;
                }
                
                // 查找所有群聊条目
                const groupEntries = entries.filter(e => e.comment === "手机-群聊" || (e.key && typeof e.key === 'string' && e.key.startsWith("手机-群聊-")));
                console.log(`找到 ${groupEntries.length} 个独立群聊条目:`);
                
                groupEntries.forEach((entry, index) => {
                    console.log(`群聊条目 ${index + 1}:`);
                    console.log('  - Key:', entry.key);
                    console.log('  - Comment:', entry.comment);
                    console.log('  - Content:', entry.content);
                    
                    // 解析群聊信息
                    const lines = entry.content.split('\n');
                    let groupName = '';
                    let members = [];
                    let avatar = '';
                    
                    for (const line of lines) {
                        const trimmed = line.trim();
                        if (trimmed.startsWith('[') && trimmed.endsWith(']')) {
                            groupName = trimmed.slice(1, -1);
                        } else if (trimmed.startsWith('成员=')) {
                            members = trimmed.substring(3).split(',').map(m => m.trim());
                        } else if (trimmed.startsWith('头像=')) {
                            avatar = trimmed.substring(3);
                        }
                    }
                    
                    console.log(`  - 群聊名称: ${groupName}`);
                    console.log(`  - 成员: ${members.join(', ')}`);
                    console.log(`  - 头像: ${avatar}`);
                });
            }

            /**
             * 清理重复的群聊（已禁用，允许同名群聊存在）
             */
            async function cleanupDuplicateGroups() {
                console.log('群聊重复清理功能已禁用，允许同名群聊存在');
                return; // 禁用此函数，允许同名群聊
                
                console.log('开始清理重复群聊');
                
                // 从世界书加载群聊数据进行清理
                const groups = await loadGroupChatsFromWorldbook();
                const uniqueGroups = [];
                const seenNames = new Set();
                
                for (const group of groups) {
                    if (!seenNames.has(group.name)) {
                        seenNames.add(group.name);
                        uniqueGroups.push(group);
                    } else {
                        console.log(`删除重复群聊: ${group.name} (ID: ${group.id})`);
                    }
                }
                
                if (uniqueGroups.length !== groups.length) {
                    // 新版本：不再使用localStorage，群聊数据在世界书中管理
                    console.log(`清理完成，从 ${groups.length} 个群聊减少到 ${uniqueGroups.length} 个`);
                }
                
                // 清理界面中的重复群聊元素
                const contactsContainer = document.getElementById('QQ_home_chars');
                if (contactsContainer) {
                    const groupElements = contactsContainer.querySelectorAll('[data-group-type="true"]');
                    const seenGroupNames = new Set();
                    
                    groupElements.forEach(element => {
                        const nameElement = element.querySelector('.QQ_home_name');
                        if (nameElement) {
                            const groupName = nameElement.textContent.trim();
                            if (seenGroupNames.has(groupName)) {
                                console.log(`删除重复的群聊界面元素: ${groupName}`);
                                element.remove();
                            } else {
                                seenGroupNames.add(groupName);
                            }
                        }
                    });
                }
                
                // 清理消息列表中的重复群聊元素
                const messagesContainer = document.getElementById('QQ_message_list_chars');
                if (messagesContainer) {
                    const groupElements = messagesContainer.querySelectorAll('[data-group-type="true"]');
                    const seenGroupNames = new Set();
                    
                    groupElements.forEach(element => {
                        const nameElement = element.querySelector('.QQ_home_name');
                        if (nameElement) {
                            const groupName = nameElement.textContent.trim();
                            if (seenGroupNames.has(groupName)) {
                                console.log(`删除重复的群聊消息元素: ${groupName}`);
                                element.remove();
                            } else {
                                seenGroupNames.add(groupName);
                            }
                        }
                    });
                }
            }

            /**
             * 将群聊添加到世界书
             */
            async function addGroupToWorldbook(groupData) {
                try {
                    console.log('=== 开始将群聊添加到独立的世界书条目 ===');
                    console.log('群聊数据:', groupData);
                    
                    // 使用与动态内容存储相同的简单检查
                    if (!worldbook || !entries) {
                        console.warn('世界书功能不可用，无法添加群聊到世界书');
                            return false;
                    }
                    
                    // 定义uniqueComment变量在函数开头，确保在所有分支中都可用
                    const uniqueComment = `手机-群聊-${groupData.name}`;
                    
                    // 查找现有的群聊条目
                    let groupEntry = null;
                    const groupEntryKey = `手机-群聊-${groupData.name}`;
                    
                    groupEntry = entries.find(e => 
                        e.comment === "手机-群聊" && e.content && e.content.includes(`[${groupData.name}]`)
                    );
                    
                    // 构建群聊条目内容 - 智能头像混合存储方案
                    let avatarReference = 'http://sharkpan.xyz/f/z0WU5/mmexport1736971020657.gif';
                    
                    if (groupData.avatar) {
                        console.log('开始处理头像数据，类型:', typeof groupData.avatar);
                        
                        if (typeof groupData.avatar === 'string') {
                            // 直接的字符串格式（可能是base64或URL）
                            if (groupData.avatar.startsWith('data:')) {
                                // Base64图像数据，使用IndexedDB或直接存储在世界书中
                                try {
                                    // 将base64直接存储在世界书中，避免localStorage限制
                                    avatarReference = groupData.avatar; // 直接使用base64
                                    console.log('Base64头像直接存储在世界书中，长度:', groupData.avatar.length);
                                } catch (e) {
                                    console.warn('头像处理失败，使用默认头像:', e);
                                    avatarReference = 'http://sharkpan.xyz/f/z0WU5/mmexport1736971020657.gif';
                                }
                            } else if (groupData.avatar.startsWith('http://') || groupData.avatar.startsWith('https://')) {
                                // 网络URL，直接使用
                                avatarReference = groupData.avatar;
                                console.log('使用网络链接头像:', avatarReference);
                            } else if (groupData.avatar.startsWith('avatar_')) {
                                // 已经是头像ID引用，直接使用
                                avatarReference = groupData.avatar;
                                console.log('使用已有的头像ID引用:', avatarReference);
                            } else {
                                console.log('未识别的头像格式，使用默认头像');
                                avatarReference = 'http://sharkpan.xyz/f/z0WU5/mmexport1736971020657.gif';
                            }
                        } else if (typeof groupData.avatar === 'object') {
                            // 对象格式的头像数据
                            if (groupData.avatar.type === 'url' && groupData.avatar.url) {
                                // 网络链接
                                avatarReference = groupData.avatar.url;
                                console.log('使用网络链接头像:', avatarReference);
                            } else if (groupData.avatar.type === 'upload') {
                                if (groupData.avatar.avatarId) {
                                    // 已有的头像ID引用
                                    avatarReference = groupData.avatar.avatarId;
                                    console.log('使用头像ID引用:', avatarReference);
                                } else if (groupData.avatar.imageData) {
                                    if (groupData.avatar.imageData.startsWith('data:')) {
                                        // Base64数据，直接存储
                                        try {
                                            avatarReference = groupData.avatar.imageData; // 直接使用base64
                                            console.log('Base64头像直接存储，长度:', groupData.avatar.imageData.length);
                                        } catch (e) {
                                            console.warn('头像处理失败，使用默认头像:', e);
                                            avatarReference = 'http://sharkpan.xyz/f/z0WU5/mmexport1736971020657.gif';
                                        }
                                    } else if (groupData.avatar.imageData.startsWith('http://') || groupData.avatar.imageData.startsWith('https://')) {
                                        // 网络链接
                                        avatarReference = groupData.avatar.imageData;
                                        console.log('使用网络链接头像:', avatarReference);
                                    } else {
                                        console.log('未识别的imageData格式，使用默认头像');
                                        avatarReference = 'http://sharkpan.xyz/f/z0WU5/mmexport1736971020657.gif';
                                    }
                                } else {
                                    console.log('upload类型但无有效数据，使用默认头像');
                                    avatarReference = 'http://sharkpan.xyz/f/z0WU5/mmexport1736971020657.gif';
                                }
                            } else {
                                console.log('未识别的头像对象类型，使用默认头像');
                                avatarReference = 'http://sharkpan.xyz/f/z0WU5/mmexport1736971020657.gif';
                            }
                        } else {
                            console.log('未识别的头像数据类型，使用默认头像');
                            avatarReference = 'http://sharkpan.xyz/f/z0WU5/mmexport1736971020657.gif';
                        }
                    } else {
                        console.log('无头像数据，使用默认头像');
                    }
                    
                    console.log('最终头像引用:', avatarReference);
                    
                    const groupContent = `[${groupData.name}]
类型=群聊
成员=${groupData.members.join(',')}
头像=${avatarReference}`;
                    
                    if (groupEntry) {
                        // 更新现有条目
                        console.log('更新现有群聊条目:', groupEntry.uid);
                        await setLorebookEntries(worldbook, [
                            {
                                uid: groupEntry.uid,
                                content: groupContent,
                            }
                        ]);
                    } else {
                        // 创建新的独立群聊条目
                        console.log('创建新的独立群聊条目');
                        
                        // 使用正确的createLorebookEntry函数，遵循项目标准设定
                        console.log('准备调用createLorebookEntry，参数:', { worldbook, uniqueComment, groupContent });
                        const createResult = await createLorebookEntry(worldbook, {
                            comment: uniqueComment, // 使用唯一的comment标识群聊
                            key: ["此世界书永不触发"], // 使用标准的永不触发关键词，与手机-角色保持一致
                            content: groupContent,
                            position: "at_depth_as_system",
                            type: "selective", // 绿灯：选择性触发
                            depth: 4, // 深度4，与其他手机格式保持一致
                            exclude_recursion: true, // 排除递归，遵循项目标准
                            order: 6000, // 顺序6000，高于格式条目（5560-5564）
                            enabled: true,
                        });
                        console.log('createLorebookEntry调用结果:', createResult);
                        
                        // 触发世界书保存
                        await QQ_SafeSaveWorldInfo("群聊创建数据");
                    }
                    
                    console.log('群聊已成功添加到独立的世界书条目');
                    
                    return true;
                } catch (error) {
                    console.error('添加群聊到世界书失败:', error);
                    return false;
                }
            }
            
            /**
             * 更新群聊成员到世界书
             */
            async function updateGroupMembersInWorldbook(groupName, members) {
                try {
                    console.log('更新群聊成员到独立世界书条目:', groupName, members);
                    
                    // 查找对应的群聊条目 - 使用唯一comment查找
                    let groupEntry = null;
                    const uniqueComment = `手机-群聊-${groupName}`;
                    
                    if (entries) {
                        groupEntry = entries.find(e => 
                            e.comment === uniqueComment
                        );
                    }
                    
                    if (!groupEntry) {
                        console.error('在世界书中未找到群聊条目:', groupName);
                        return false;
                    }
                    
                    // 解析现有内容
                    let content = groupEntry.content;
                    const lines = content.split('\n');
                    let updatedContent = '';
                    
                    // 保留其他属性，更新成员列表
                    let hasMembersLine = false;
                    for (const line of lines) {
                        if (line.startsWith('成员=')) {
                            updatedContent += `成员=${members.join(',')}\n`;
                            hasMembersLine = true;
                        } else if (line.trim()) {
                            updatedContent += line + '\n';
                        }
                    }
                    
                    // 如果没有成员行，添加一个
                    if (!hasMembersLine) {
                        updatedContent += `成员=${members.join(',')}\n`;
                    }
                    
                    // 更新世界书
                    await setLorebookEntries(worldbook, [
                        {
                            uid: groupEntry.uid,
                            content: updatedContent.trim(),
                        }
                    ]);
                    
                    // 重新加载entries以更新本地数据
                    entries = await getLorebookEntries(worldbook);
                    
                    // 同步更新本地数据结构
                    if (QQ_msgjson.群聊[groupName]) {
                        QQ_msgjson.群聊[groupName].members = members;
                        console.log('已同步更新 QQ_msgjson.群聊 中的成员列表');
                    }
                    
                    console.log('群聊成员已更新到独立世界书条目并同步本地数据');
                    return true;
                } catch (error) {
                    console.error('更新群聊成员到世界书失败:', error);
                    return false;
                }
            }

            /**
             * 更新群聊名称到世界书（超安全模式：先创建新条目，确认成功后再删除旧条目）
             */
            async function updateGroupNameInWorldbook(oldName, newName) {
                try {
                    console.log('更新群聊名称到世界书（简化版）:', oldName, '->', newName);
                    
                    // 使用与动态内容存储相同的简单检查
                    if (!worldbook || !entries) {
                        console.warn('世界书功能不可用，无法更新群聊名称');
                            return false;
                    }
                    
                    // 1. 查找旧群聊条目 - 使用唯一comment查找
                    let oldGroupEntry = null;
                    const oldUniqueComment = `手机-群聊-${oldName}`;
                    
                    if (entries) {
                        oldGroupEntry = entries.find(e => 
                            e.comment === oldUniqueComment
                        );
                    }
                    
                    if (!oldGroupEntry) {
                        console.error('在世界书中未找到群聊条目:', oldName);
                        console.error('当前所有群聊相关条目:');
                        if (entries) {
                            entries.filter(e => e.comment.startsWith("手机-群聊")).forEach((e, i) => {
                                console.error(`群聊条目 ${i}:`, {
                                    uid: e.uid,
                                    key: e.key,
                                    comment: e.comment,
                                    content: e.content?.substring(0, 100) + '...'
                                });
                            });
                        }
                        throw new Error(`找不到要更新的群聊条目: ${oldName}`);
                    }
                    
                    // 2. 备份旧条目的所有信息
                    const backupContent = oldGroupEntry.content;
                    const backupMembers = extractMembersFromContent(backupContent);
                    const backupAvatar = extractAvatarFromContent(backupContent);
                    
                    console.log('备份的群聊信息:', { backupMembers, backupAvatar });
                    
                    // 3. 创建新内容，只替换群聊名称
                    const newContent = `[${newName}]
类型=群聊
成员=${backupMembers}
头像=${backupAvatar}`;
                    
                    // 4. 直接在原条目上更新内容、comment和key（避免创建新条目的复杂性）
                    const newUniqueComment = `手机-群聊-${newName}`;
                    const newGroupEntryKey = `手机-群聊-${newName}`;
                    
                    console.log('直接更新现有条目:', oldGroupEntry.uid);
                    console.log('新comment:', newUniqueComment);
                    console.log('新key:', [newGroupEntryKey]);
                    console.log('新内容:', newContent.substring(0, 100) + '...');
                    
                    // 使用setLorebookEntries更新现有条目的comment、key和content
                    await setLorebookEntries(worldbook, [
                        {
                            uid: oldGroupEntry.uid,
                            comment: newUniqueComment,
                            key: [newGroupEntryKey],
                            content: newContent
                        }
                    ]);
                    
                    console.log('群聊条目更新成功');
                    
                    // 5. 重新加载entries以更新本地数据
                    entries = await getLorebookEntries(worldbook);
                    
                    // 6. 同步更新所有相关的数据结构
                    console.log('开始同步更新相关数据结构...');
                    
                    // 更新 QQ_Groups 数组
                    const oldNameIndex = QQ_Groups.indexOf(oldName);
                    if (oldNameIndex !== -1) {
                        QQ_Groups[oldNameIndex] = newName;
                        console.log('已更新 QQ_Groups 数组:', QQ_Groups);
                    }
                    
                    // 更新 QQ_msgjson.群聊 中的消息记录
                    if (QQ_msgjson.群聊[oldName]) {
                        QQ_msgjson.群聊[newName] = QQ_msgjson.群聊[oldName];
                        delete QQ_msgjson.群聊[oldName];
                        console.log('已迁移群聊消息记录:', oldName, '->', newName);
                    }
                    
                    // 重要：确保QQ_msgjson.群聊[newName]结构正确
                    if (!QQ_msgjson.群聊[newName]) {
                        QQ_msgjson.群聊[newName] = {
                            members: backupMembers.split(',').map(m => m.trim()),
                            msgs: []
                        };
                        console.log('重新初始化QQ_msgjson.群聊数据:', newName);
                    }
                    
                    // *** 修复：生成稳定的群聊ID，基于原始名称 ***
                    const originalGroupName = oldUniqueComment.replace('手机-群聊-', '');
                    const stableGroupId = `group_${originalGroupName.replace(/[^a-zA-Z0-9\u4e00-\u9fff]/g, '_')}`;
                    console.log('为群聊生成稳定ID:', stableGroupId, '(基于原始名称:', originalGroupName, ')');
                    
                    // 更新界面元素的 data 属性（名称更新，但ID保持稳定）
                    document.querySelectorAll(`[data-group-name="${oldName}"]`).forEach(element => {
                        element.setAttribute('data-group-name', newName);
                        // 确保使用稳定的群聊ID
                        if (element.hasAttribute('data-group-id')) {
                            element.setAttribute('data-group-id', stableGroupId);
                        }
                        console.log('已更新界面元素 data-group-name 和 data-group-id 属性');
                    });
                    
                    // 更新群聊页面的 data 属性
                    document.querySelectorAll(`[data-name="${oldName}"]`).forEach(element => {
                        element.setAttribute('data-name', newName);
                        // 确保使用稳定的群聊ID
                        if (element.hasAttribute('data-group-id')) {
                            element.setAttribute('data-group-id', stableGroupId);
                        }
                        console.log('已更新群聊页面 data-name 和 data-group-id 属性');
                    });
                    
                    console.log('群聊名称已成功更新到世界书并同步所有相关数据 (完整版)');
                    return true;
                    
                } catch (error) {
                    console.error('更新群聊名称到世界书失败:', error);
                    return false;
                }
            }
            
            /**
             * 从条目内容中提取成员列表
             */
            function extractMembersFromContent(content) {
                const memberMatch = content.match(/成员=(.+)/);
                return memberMatch ? memberMatch[1] : '';
            }
            
            /**
             * 从条目内容中提取头像信息
             */
            function extractAvatarFromContent(content) {
                const avatarMatch = content.match(/头像=(.+)/);
                return avatarMatch ? avatarMatch[1] : 'http://sharkpan.xyz/f/z0WU5/mmexport1736971020657.gif';
            }

            /**
             * 从世界书中删除群聊
             */
            async function removeGroupFromWorldbook(groupName) {
                try {
                    console.log('开始从独立世界书条目中删除群聊:', groupName);
                    
                    // 查找对应的群聊条目 - 使用唯一comment查找
                    let groupEntry = null;
                    let groupIndex = -1;
                    const uniqueComment = `手机-群聊-${groupName}`;
                    
                    if (entries) {
                        groupIndex = entries.findIndex(e => e.comment === uniqueComment);
                        if (groupIndex >= 0) {
                            groupEntry = entries[groupIndex];
                        }
                    }
                    
                    if (!groupEntry) {
                        console.error('在世界书中未找到群聊条目:', groupName);
                        return false;
                    }
                    
                    // 删除世界书条目
                    await deleteLorebookEntry(worldbook, groupEntry.uid);
                    
                    // 从本地entries数组中移除
                    if (groupIndex >= 0 && entries) {
                        entries.splice(groupIndex, 1);
                    }
                    
                    console.log('群聊已从独立世界书条目中删除');
                    return true;
                } catch (error) {
                    console.error('从世界书中删除群聊失败:', error);
                    return false;
                }
            }


            
            /**
             * 切换到群聊界面
             */
            function switchToGroupChat(groupData) {
                console.log('切换到群聊:', groupData.name);
                console.log('群聊成员:', groupData.members);
                
                // 设置当前活跃的群聊
                window.currentGroupChat = groupData;
                
                // 切换到聊天界面
                QQ_Nav('chat');
                
                // 延迟更新，确保页面已经切换
                setTimeout(() => {
                    // 确保群聊页面存在且是独立的
                    ensureGroupChatPage(groupData);
                    
                    // 更新聊天界面的头部信息
                    updateChatHeader(groupData);
                    
                    // 加载群聊消息历史
                    loadGroupChatHistory(groupData.id);
                    
                    // 更新聊天区域的标题
                    const chatUsername = document.getElementById('QQ_chat_username');
                    if (chatUsername) {
                        chatUsername.textContent = groupData.name;
                    }
                }, 100);
            }
            
            /**
             * 确保群聊页面存在且独立
             */
            function ensureGroupChatPage(groupData) {
                console.log('确保群聊页面存在:', groupData.name, 'ID:', groupData.id);
                
                // 隐藏所有现有的聊天页面
                $('.QQ_chat_page').hide();
                
                // 查找现有的群聊页面
                let groupChatPage = $(`.QQ_chat_page[data-group-id="${groupData.id}"]`);
                
                if (groupChatPage.length === 0) {
                    console.log('创建新的群聊页面:', groupData.name);
                    // 创建新的群聊页面
                    groupChatPage = createGroupChatPage(groupData);
                    $('#App_QQ').append(groupChatPage);
                } else {
                    console.log('使用现有群聊页面:', groupData.name);
                }
                
                // 显示当前群聊页面
                groupChatPage.show();
                
                return groupChatPage;
            }
            
            /**
             * 创建群聊专用页面
             */
            function createGroupChatPage(groupData) {
                console.log('创建群聊专用页面:', groupData.name);
                
                const pageHTML = `
                    <div class="QQ_chat_page group-chat-page" data-group-id="${groupData.id}" data-name="${groupData.name}" style="display: none;">
                        <div class="QQ_chat_head" style="display: flex; align-items: center; padding: 10px; background: white; border-bottom: 1px solid #eee;">
                            <div class="QQ_chat_head_back" style="margin-right: 15px; cursor: pointer;">
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="none">
                                    <path d="M15 18L9 12L15 6" stroke="#333" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                </svg>
                            </div>
                            <div class="QQ_chat_head_avatar" style="width: 40px; height: 40px; border-radius: 50%; margin-right: 12px; background: linear-gradient(135deg, #199AFF, #0066CC); display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">群</div>
                            <div style="flex: 1;">
                                <span id="QQ_chat_username" class="group-chat-clickable-name" style="font-size: 16px; font-weight: bold; cursor: pointer;">${groupData.name}</span>
                                <div style="font-size: 12px; color: #999; margin-top: 2px;">群聊 · ${groupData.members.length}人</div>
                            </div>
                        </div>
                        <div class="msgcontent" style="flex: 1; overflow-y: auto; padding: 10px; background: #f5f5f5;">
                            <!-- 群聊消息将在这里显示 -->
                        </div>
                        <div class="QQ_chat_input_area" style="padding: 10px; background: white; border-top: 1px solid #eee;">
                            <div style="display: flex; align-items: center;">
                                <input type="text" class="group-chat-input userInput" placeholder="输入消息..." style="flex: 1; padding: 8px 12px; border: 1px solid #ddd; border-radius: 20px; outline: none;">
                                <button class="group-chat-send-btn" style="margin-left: 10px; padding: 8px 16px; background: #007AFF; color: white; border: none; border-radius: 20px; cursor: pointer;">发送</button>
                            </div>
                        </div>
                    </div>
                `;
                
                const $page = $(pageHTML);
                
                // 绑定返回按钮事件
                $page.find('.QQ_chat_head_back').on('click', function() {
                    // 重新显示底部导航栏
                    $('.QQ_bottom_nav').show();
                    
                    console.log('群聊返回按钮被点击');
                    // 根据来源页面返回
                    const sourcePage = window.groupChatSourcePage || 'contacts';
                    if (sourcePage === 'messages') {
                        QQ_Nav('message');
                    } else {
                        QQ_Nav('people');
                    }
                    // 清除群聊状态
                    window.currentGroupChat = null;
                });
                
                // 绑定群聊名称点击事件
                $page.find('.group-chat-clickable-name').on('click', function() {
                    console.log('群聊名称被点击:', groupData.name);
                    showGroupManagementMenu(groupData, this);
                });
                
                // 绑定发送消息事件
                const $input = $page.find('.group-chat-input');
                const $sendBtn = $page.find('.group-chat-send-btn');
                

                
                // 修改为两阶段发送机制：Enter键缓存消息，点击发送按钮才真正发送
                $sendBtn.on('click', function() {
                    // 点击发送按钮时，使用QQ_SendMsg发送缓存的消息
                    const fakeEvent = { target: $page[0] };
                    QQ_SendMsg(fakeEvent);
                });
                
                // 使用统一的Enter键处理机制
                $input.on('keydown', function(e) {
                    QQ_EnterPress(e, this);
                });
                

                
                return $page;
            }
            
            /**
             * 添加新群聊（类似AddNewChar）
             */
            /**
             * 创建新群聊（基于世界书，类似私聊逻辑）
             */
            async function createNewGroup(groupName, members, avatarUrl) {
                console.log('=== 创建新群聊开始 ===');
                console.log('群聊名称:', groupName);
                console.log('成员列表:', members);
                console.log('头像URL:', avatarUrl);
                
                try {
                    // 1. 添加到世界书
                    const groupData = {
                        name: groupName,
                        members: members,
                        avatar: {
                            type: 'upload',
                            imageData: avatarUrl || 'http://sharkpan.xyz/f/z0WU5/mmexport1736971020657.gif'
                        }
                    };
                    
                    console.log('准备调用addGroupToWorldbook，数据:', groupData);
                    const success = await addGroupToWorldbook(groupData);
                    console.log('addGroupToWorldbook返回结果:', success);
                    
                    if (!success) {
                        throw new Error('添加到世界书失败');
                    }
                    
                    // 立即刷新entries，确保新创建的群聊能被加载
                    console.log('刷新entries以包含新创建的群聊');
                    try {
                        entries = await getLorebookEntries(worldbook);
                        console.log('entries刷新成功，新的条目数量:', entries ? entries.length : 'failed');
                    } catch (e) {
                        console.warn('刷新entries失败，但群聊已创建:', e);
                    }
                    
                    // 2. 确保群聊立即加入QQ_Groups数组
                    if (!QQ_Groups.includes(groupName)) {
                        QQ_Groups.push(groupName);
                        console.log(`群聊 "${groupName}" 已立即加入QQ_Groups数组`);
                    }
                    
                    // 3. 确保QQ_msgjson中有该群聊的数据结构
                    if (!QQ_msgjson.群聊[groupName]) {
                        QQ_msgjson.群聊[groupName] = {
                            members: members || [],
                            msgs: []
                        };
                        console.log('在QQ_msgjson.群聊中初始化群聊数据:', groupName);
                    }
                    
                    // 4. 立即重新加载群聊以确保显示在界面上
                    console.log('立即重新加载群聊数据以显示新创建的群聊');
                    await loadGroupChatsFromWorldbook();
                    
                    console.log('群聊创建成功:', groupName);
                    console.log('当前QQ_Groups数组:', QQ_Groups);
                    return true;
                } catch (error) {
                    console.error('创建群聊失败:', error);
                    toastr.error('创建群聊失败: ' + error.message);
                    return false;
                }
            }
            
            /**
             * 删除群聊（基于世界书，类似私聊逻辑）
             */
            async function deleteGroupChat(groupName) {
                console.log('删除群聊:', groupName);
                
                try {
                    // 1. 从世界书删除
                    const success = await removeGroupFromWorldbook(groupName);
                    if (!success) {
                        throw new Error('从世界书删除失败');
                    }
                    
                    // 2. 从界面删除
                    $(`.QQ_home_usermsg[data-name='${groupName}']`).remove();
                    
                    // 3. 从数据结构删除
                    delete QQ_msgjson.群聊[groupName];
                    const index = QQ_Groups.indexOf(groupName);
                    if (index > -1) {
                        QQ_Groups.splice(index, 1);
                    }
                    const pageIndex = QQ_pages.indexOf(groupName);
                    if (pageIndex > -1) {
                        QQ_pages.splice(pageIndex, 1);
                    }
                    
                    // 4. 删除聊天页面
                    $(`.QQ_chat_page[data-name='${groupName}']`).remove();
                    
                    // 5. 立即刷新entries，确保删除的群聊从界面消失
                    console.log('刷新entries以移除已删除的群聊');
                    try {
                        entries = await getLorebookEntries(worldbook);
                        console.log('entries刷新成功，新的条目数量:', entries ? entries.length : 'failed');
                    } catch (e) {
                        console.warn('刷新entries失败，但群聊已删除:', e);
                    }
                    
                    // 6. 立即重新加载群聊以确保已删除的群聊从界面消失
                    console.log('立即重新加载群聊数据以移除已删除的群聊');
                    await loadGroupChatsFromWorldbook();
                    
                    // 7. 更新消息列表
                    setTimeout(async () => {
                        await QQ_UpdateMessageList();
                    }, 100);
                    
                    console.log('群聊删除成功:', groupName);
                    console.log('当前QQ_Groups数组:', QQ_Groups);
                    return true;
                } catch (error) {
                    console.error('删除群聊失败:', error);
                    toastr.error('删除群聊失败: ' + error.message);
                    return false;
                }
            }
            
            /**
             * 保存群聊消息到本地存储和QQ_msgjson
             */
            function saveGroupMessage(groupId, message) {
                try {
                    // *** 修复：实际保存群聊消息到QQ_msgjson.群聊 ***
                    
                    // 确保QQ_msgjson.群聊结构存在
                    if (!QQ_msgjson.群聊) {
                        QQ_msgjson.群聊 = {};
                    }
                    
                    // 根据groupId找到对应的群聊名称
                    let groupName = null;
                    
                    // 尝试从QQ_Groups数组中匹配
                    for (const name of QQ_Groups) {
                        if (name.includes(groupId) || groupId.includes(name)) {
                            groupName = name;
                            break;
                        }
                    }
                    
                    // 如果没有找到，尝试通过界面元素查找
                    if (!groupName) {
                        const groupElement = document.querySelector(`[data-group-id="${groupId}"]`);
                        if (groupElement) {
                            groupName = groupElement.getAttribute('data-name') || 
                                       groupElement.textContent.trim() ||
                                       groupId; // 最后使用groupId作为名称
                        } else {
                            groupName = groupId; // 直接使用groupId
                        }
                    }
                    
                    console.log(`保存群聊消息 - groupId: ${groupId}, groupName: ${groupName}`, message);
                    
                    // 确保该群聊在QQ_msgjson.群聊中存在
                    if (!QQ_msgjson.群聊[groupName]) {
                        QQ_msgjson.群聊[groupName] = {
                            msgs: [],
                            members: []
                        };
                        console.log(`初始化群聊数据结构: ${groupName}`);
                    }
                    
                    // 构造消息格式：发送者--消息内容
                    const msgString = `${message.sender}--${message.content}`;
                    
                    // 检查是否已存在相同消息（避免重复）
                    const isDuplicate = QQ_msgjson.群聊[groupName].msgs.some(msg => 
                        msg === msgString || msg.includes(message.content)
                    );
                    
                    if (!isDuplicate) {
                        // 添加消息到群聊记录中
                        QQ_msgjson.群聊[groupName].msgs.push(msgString);
                        console.log(`✓ 群聊消息已保存到QQ_msgjson.群聊[${groupName}], 当前消息数: ${QQ_msgjson.群聊[groupName].msgs.length}`);
                        
                        // *** 新增：立即保存到世界书 ***
                        setTimeout(async () => {
                            await QQ_Save_Msg();
                            console.log('✓ 群聊消息已同步保存到世界书备份');
                        }, 100);
                    } else {
                        console.log('跳过重复的群聊消息:', msgString);
                    }
                    
                } catch (error) {
                    console.error('保存群聊消息失败:', error);
                }
            }
            
            /**
             * 恢复群聊数据到QQ_msgjson（类似私聊的恢复机制）
             */
            async function restoreGroupDataToMsgjson() {
                console.log('开始恢复群聊数据到QQ_msgjson');
                const groups = await loadGroupsFromStorage();
                
                groups.forEach(groupData => {
                    // 确保QQ_msgjson中有该群聊的数据结构
                    if (!QQ_msgjson.群聊[groupData.name]) {
                        QQ_msgjson.群聊[groupData.name] = {
                            members: groupData.members || [],
                            msgs: []
                        };
                    }
                    
                    // *** 修复：保持现有消息，不要清空 ***
                    // 如果QQ_msgjson中已经有消息，保持它们
                    console.log(`群聊 ${groupData.name} 当前有 ${QQ_msgjson.群聊[groupData.name].msgs.length} 条消息`);
                    
                    // 确保群聊在QQ_Groups数组中
                    if (!QQ_Groups.includes(groupData.name)) {
                        QQ_Groups.push(groupData.name);
                    }
                    
                    // *** 新增：重新加载后立即更新群聊最后消息显示 ***
                    if (QQ_msgjson.群聊[groupData.name].msgs.length > 0) {
                        setTimeout(() => {
                            updateGroupLastMessageDisplay(groupData.name);
                        }, 200);
                    }
                    
                    console.log(`恢复群聊数据: ${groupData.name}, 消息数量: ${QQ_msgjson.群聊[groupData.name].msgs.length}`);
                });
            }
            
            /**
             * 更新群聊的最后消息和时间
             */
            async function updateGroupLastMessage(groupId, message) {
                try {
                    // 修复：使用正确的群聊数据加载函数
                    const groups = await loadGroupChatsFromWorldbook();
                    
                    // 修复：确保groups是有效的数组
                    if (!groups || !Array.isArray(groups)) {
                        console.warn('群聊数据无效，跳过更新群聊最后消息:', groupId);
                        return;
                    }
                    
                    const groupIndex = groups.findIndex(g => g && g.id === groupId);
                    
                    if (groupIndex !== -1) {
                        const currentTime = new Date();
                        groups[groupIndex].lastMessage = message;
                        groups[groupIndex].lastTime = currentTime.toLocaleTimeString('zh-CN', { hour12: false }).slice(0, 5);
                        groups[groupIndex].timestamp = groups[groupIndex].lastTime;
                        
                        // 新版本：不再使用localStorage保存群聊数据
                        console.log('群聊最后消息已更新（仅内存）');
                        
                        // 更新界面显示
                        const messageElement = $(`.QQ_home_usermsg[data-group-id="${groupId}"]`)[0];
                        const contactElement = $(`.QQ_home_usermsg[data-group-id="${groupId}"]`)[0];
                        
                        if (messageElement) {
                            updateGroupInMessageList(messageElement, groups[groupIndex]);
                        }
                        if (contactElement) {
                            updateGroupInContactList(contactElement, groups[groupIndex]);
                        }
                        
                        console.log('群聊最后消息已更新:', groups[groupIndex]);
                    }
                } catch (error) {
                    console.error('更新群聊最后消息失败:', error);
                }
            }
            
            /**
             * 加载群聊消息历史
             */
            function loadGroupChatHistory(groupId) {
                console.log('加载群聊消息历史:', groupId);
                
                try {
                    // 新版本：群聊消息历史暂时不持久化，每次重新开始
                    const messages = [];
                    console.log('群聊消息历史（新会话）:', messages.length, '条');
                    
                    // 查找群聊专用页面的消息容器
                    const groupChatPage = $(`.QQ_chat_page[data-group-id="${groupId}"]`);
                    const msgContent = groupChatPage.find('.msgcontent')[0] || document.querySelector('.group-chat-page .msgcontent');
                    
                    if (msgContent) {
                        msgContent.innerHTML = '';
                        
                        // 如果有历史消息，显示它们
                        messages.forEach(message => {
                            displayGroupMessage(message, msgContent);
                        });
                        
                        // 滚动到底部
                        msgContent.scrollTop = msgContent.scrollHeight;
                    } else {
                        console.error('未找到群聊消息容器');
                    }
                    
                    if (messages.length === 0) {
                        // 如果没有历史消息，显示欢迎信息
                        if (msgContent && window.currentGroupChat) {
                            const welcomeMsg = document.createElement('div');
                            welcomeMsg.style.cssText = 'text-align: center; color: #999; padding: 20px; font-size: 14px;';
                            welcomeMsg.innerHTML = `
                                <div style="font-size: 18px; font-weight: bold; margin-bottom: 10px;">${window.currentGroupChat.name}</div>
                                <div style="font-size: 14px; margin-bottom: 10px;">群成员: ${window.currentGroupChat.members.join(', ')}</div>
                                <div style="font-size: 12px; color: #999;">群聊已创建，开始聊天吧！</div>
                            `;
                            msgContent.appendChild(welcomeMsg);
                        }
                    }
                } catch (error) {
                    console.error('加载群聊消息历史失败:', error);
                }
            }
            
            /**
             * 显示群聊消息
             */
            function displayGroupMessage(message, msgContent = null) {
                if (!msgContent) {
                    msgContent = document.querySelector('.group-chat-page .msgcontent') || document.querySelector('.msgcontent');
                }
                if (!msgContent) return;
                
                const messageDiv = document.createElement('div');
                messageDiv.className = 'QQ_chat_msgdiv group-message';
                messageDiv.setAttribute('data-name', message.sender);
                messageDiv.style.cssText = 'margin: 10px 0; padding: 10px; background: white; border-radius: 8px; box-shadow: 0 1px 2px rgba(0,0,0,0.1);';
                
                const senderSpan = document.createElement('span');
                senderSpan.style.cssText = 'font-weight: bold; color: #007AFF; margin-right: 8px; font-size: 14px;';
                senderSpan.textContent = message.sender + ':';
                
                const contentSpan = document.createElement('span');
                contentSpan.style.cssText = 'color: #333; font-size: 14px; line-height: 1.4;';
                contentSpan.textContent = message.content;
                
                const timeSpan = document.createElement('span');
                timeSpan.style.cssText = 'font-size: 12px; color: #999; margin-left: 8px; float: right;';
                timeSpan.textContent = message.timestamp || new Date().toLocaleTimeString();
                
                messageDiv.appendChild(senderSpan);
                messageDiv.appendChild(contentSpan);
                messageDiv.appendChild(timeSpan);
                
                msgContent.appendChild(messageDiv);
            }
            
            /**
             * 切换到私聊时清除群聊状态
             */
            function clearGroupChatState() {
                if (window.currentGroupChat) {
                    console.log('离开群聊:', window.currentGroupChat.name);
                    window.currentGroupChat = null;
                }
            }
            
            // 监听私聊切换，清除群聊状态
            const originalQQNav = window.QQ_Nav;
            // QQ_Nav函数已在前面正确定义，无需重复定义
            
            /**
             * 确保群聊在联系人列表中存在
             */
            async function ensureGroupsInContactList() {
                const groups = await loadGroupsFromStorage();
                const contactsContainer = document.getElementById('QQ_home_chars');
                
                if (!contactsContainer) {
                    console.log('联系人容器不存在，跳过群聊恢复');
                    return;
                }
                
                if (groups.length === 0) {
                    console.log('没有群聊数据需要恢复');
                    return;
                }
                
                console.log('检查联系人列表中的群聊，共', groups.length, '个群聊需要恢复');
                console.log('群聊数据:', groups.map(g => ({name: g.name, id: g.id, avatar: g.avatar})));
                
                // 先清理重复的群聊元素，但保留一个
                const existingGroups = contactsContainer.querySelectorAll('[data-group-type="true"]');
                const groupMap = new Map();
                const groupNameMap = new Map(); // 按名称索引
                
                console.log('现有群聊元素数量:', existingGroups.length);
                
                existingGroups.forEach(element => {
                    const groupId = element.getAttribute('data-group-id');
                    const groupName = element.getAttribute('data-name');
                    
                    console.log('检查现有群聊元素:', {groupId, groupName});
                    
                    if (groupId) {
                        if (groupMap.has(groupId)) {
                            console.log('移除重复的群聊元素(按ID):', groupId);
                            element.remove();
                        } else {
                            groupMap.set(groupId, element);
                            if (groupName) {
                                groupNameMap.set(groupName, element);
                            }
                        }
                    } else if (groupName) {
                        // 如果没有ID但有名称，也记录下来
                        if (groupNameMap.has(groupName)) {
                            console.log('移除重复的群聊元素(按名称):', groupName);
                            element.remove();
                        } else {
                            groupNameMap.set(groupName, element);
                        }
                    }
                });
                
                // 然后添加缺失的群聊
                groups.forEach(groupData => {
                    const existsByID = groupMap.has(groupData.id);
                    const existsByName = groupNameMap.has(groupData.name);
                    
                    if (!existsByID && !existsByName) {
                        console.log('恢复群聊到联系人列表:', groupData.name, 'ID:', groupData.id);
                        AddNewGroup(groupData.name, groupData.avatar || 'https://files.catbox.moe/skngqq.jpg', groupData.members, groupData.description);
                    } else {
                        console.log('群聊已存在于联系人列表:', groupData.name);
                        // 确保现有群聊的头像正确显示
                        const existingElement = existsByID ? groupMap.get(groupData.id) : groupNameMap.get(groupData.name);
                        if (existingElement) {
                            updateGroupAvatarInElement(existingElement, groupData);
                        }
                    }
                });
                
                console.log('联系人列表群聊恢复完成');
            }
            
            /**
             * 更新群聊元素中的头像显示
             */
            function updateGroupAvatarInElement(element, groupData) {
                const avatarElement = element.querySelector('.QQ_home_head');
                if (!avatarElement) return;
                
                // 重置头像样式
                avatarElement.style.backgroundImage = '';
                avatarElement.style.background = '';
                avatarElement.textContent = '';
                
                // 应用头像
                applyGroupAvatar(avatarElement, groupData.avatar);
            }
            
            /**
             * 从世界书获取角色头像数据
             */
            function getCharacterAvatarFromWorldbook(characterName) {
                console.log(`从世界书获取角色头像: ${characterName}`);
                
                // 从世界书 "手机-角色" 条目获取头像
                let entry = GetWorldEntry(["手机-角色", "手机界面-角色"], true);
                if (!entry || !entry.content) {
                    console.log('未找到手机-角色世界书条目');
                    return null;
                }
                
                const content = entry.content;
                const lines = content.split('\n');
                let currentSection = null;
                
                for (let line of lines) {
                    line = line.trim();
                    if (line.startsWith('[') && line.endsWith(']')) {
                        currentSection = line.slice(1, -1);
                    } else if (currentSection === characterName && line.startsWith('头像=')) {
                        const avatarUrl = line.substring(3);
                        console.log(`找到角色 ${characterName} 的头像: ${avatarUrl}`);
                        return {
                            backgroundImage: `url("${avatarUrl}")`,
                            background: '',
                            textContent: '',
                            avatarUrl: avatarUrl
                        };
                    }
                }
                
                console.log(`未在世界书中找到角色 ${characterName} 的头像`);
                return null;
            }
            
            /**
             * 从世界书获取群聊头像数据
             */
            function getGroupAvatarFromWorldbook(groupName) {
                console.log(`从世界书获取群聊头像: ${groupName}`);
                
                // 从世界书 "手机-群聊" 条目获取头像
                if (!entries) {
                    console.log('entries未定义，无法获取群聊头像');
                    return null;
                }
                
                const uniqueComment = `手机-群聊-${groupName}`;
                const groupEntry = entries.find(e => 
                    e.comment === uniqueComment
                );
                
                if (!groupEntry) {
                    console.log(`未找到群聊 ${groupName} 的世界书条目`);
                    return null;
                }
                
                const content = groupEntry.content;
                const lines = content.split('\n');
                let currentSection = null;
                
                for (let line of lines) {
                    line = line.trim();
                    if (line.startsWith('[') && line.endsWith(']')) {
                        currentSection = line.slice(1, -1);
                    } else if (currentSection === groupName && line.startsWith('头像=')) {
                        const avatarUrl = line.substring(3);
                        console.log(`找到群聊 ${groupName} 的头像: ${avatarUrl}`);
                        return {
                            backgroundImage: `url("${avatarUrl}")`,
                            background: '',
                            textContent: '',
                            avatarUrl: avatarUrl
                        };
                    }
                }
                
                console.log(`未在世界书中找到群聊 ${groupName} 的头像`);
                return null;
            }
            
            /**
             * 获取角色头像数据（优先从世界书，备选从联系人列表）
             */
            function getCharacterAvatar(characterName) {
                console.log(`获取角色头像: ${characterName}`);
                
                // 首先尝试从世界书获取
                const worldbookAvatar = getCharacterAvatarFromWorldbook(characterName);
                if (worldbookAvatar) {
                    return worldbookAvatar;
                }
                
                // 备选方案：从联系人列表中查找角色头像
                const contactsContainer = document.getElementById('QQ_home_chars');
                if (!contactsContainer) {
                    console.log('联系人容器未找到');
                    return null;
                }
                
                // 查找对应的联系人元素 - 修复：使用正确的选择器
                const contactElements = contactsContainer.querySelectorAll('.QQ_home_usermsg');
                for (let element of contactElements) {
                    const nameElement = element.querySelector('.QQ_home_name');
                    if (nameElement && nameElement.textContent.trim() === characterName) {
                        const avatarElement = element.querySelector('.QQ_home_head');
                        if (avatarElement) {
                            // 提取头像信息
                            const backgroundImage = avatarElement.style.backgroundImage;
                            const background = avatarElement.style.background;
                            const textContent = avatarElement.textContent;
                            
                            console.log(`从联系人列表获取角色 ${characterName} 的头像`);
                            return {
                                backgroundImage,
                                background,
                                textContent
                            };
                        }
                    }
                }
                
                console.log(`未找到角色 ${characterName} 的头像`);
                return null;
            }
            
            /**
             * 应用角色头像到元素
             */
            function applyCharacterAvatar(element, avatarData, characterName) {
                // *** 修复：不要强制设置尺寸，保持CSS中的样式 ***
                // 只设置必要的基础样式，让CSS控制尺寸
                element.style.borderRadius = '50%';
                element.style.display = 'flex';
                element.style.alignItems = 'center';
                element.style.justifyContent = 'center';
                element.style.fontWeight = 'bold';
                element.style.fontSize = '12px';
                element.style.color = 'white';
                element.style.backgroundSize = 'cover';
                element.style.backgroundPosition = 'center';
                element.style.backgroundRepeat = 'no-repeat';
                element.style.flexShrink = '0';
                
                if (avatarData && (avatarData.backgroundImage || avatarData.background)) {
                    // 使用真实头像
                    if (avatarData.backgroundImage && avatarData.backgroundImage !== 'none') {
                        element.style.backgroundImage = avatarData.backgroundImage;
                        element.style.background = '';
                        element.textContent = '';
                    } else if (avatarData.background && avatarData.background !== 'none') {
                        element.style.background = avatarData.background;
                        element.style.backgroundImage = '';
                        element.textContent = avatarData.textContent || characterName.charAt(0);
                    } else {
                        // 使用默认头像
                        element.style.background = 'linear-gradient(135deg, #667eea, #764ba2)';
                        element.style.backgroundImage = '';
                        element.textContent = characterName.charAt(0);
                    }
                } else {
                    // 使用默认头像
                    element.style.background = 'linear-gradient(135deg, #667eea, #764ba2)';
                    element.style.backgroundImage = '';
                    element.textContent = characterName.charAt(0);
                }
            }
            
            // 注意：ensureGroupsInMessageList函数已删除
            // 消息列表现在由QQ_UpdateMessageList()自动从联系人列表同步
            
            /**
             * 更新聊天界面头部信息
             */
            function updateChatHeader(groupData) {
                console.log('更新聊天界面头部信息:', groupData);
                
                // 查找聊天界面的头部元素
                const chatHeader = document.querySelector('#QQ_chat_username')?.closest('div') || 
                                  document.querySelector('.QQ_chat_head') || 
                                  document.querySelector('#QQ_chat_head');
                console.log('聊天头部元素:', chatHeader);
                
                if (!chatHeader) {
                    console.error('未找到聊天头部元素，尝试创建头部');
                    // 如果找不到头部，尝试在页面顶部创建一个
                    const chatPage = document.querySelector('.QQ_chat_page[style*="display:block"], .QQ_chat_page:not([style*="display:none"])');
                    if (chatPage) {
                        const headerDiv = document.createElement('div');
                        headerDiv.className = 'QQ_chat_head group-chat-header';
                        headerDiv.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; height: 60px; background: #fff; z-index: 1000; display: flex; align-items: center; padding: 0 15px; border-bottom: 1px solid #eee;';
                        
                        // 创建头像
                        const avatar = document.createElement('div');
                        avatar.className = 'QQ_home_head';
                        avatar.style.cssText = 'width: 40px; height: 40px; border-radius: 50%; margin-right: 10px;';
                        
                        // 创建名称和信息容器
                        const infoDiv = document.createElement('div');
                        infoDiv.style.cssText = 'flex: 1;';
                        
                        const nameDiv = document.createElement('div');
                        nameDiv.className = 'QQ_home_name group-chat-clickable-name';
                        nameDiv.style.cssText = 'font-size: 16px; font-weight: bold; color: #333; cursor: pointer; user-select: none;';
                        nameDiv.textContent = groupData.name;
                        
                        // 添加点击事件显示群聊管理菜单
                        nameDiv.addEventListener('click', function(e) {
                            e.stopPropagation();
                            showGroupManagementMenu(groupData, nameDiv);
                        });
                        
                        const msgDiv = document.createElement('div');
                        msgDiv.className = 'QQ_home_lastmsg group-member-count';
                        msgDiv.style.cssText = 'font-size: 12px; color: #666; margin-top: 2px;';
                        msgDiv.textContent = `群聊 · ${groupData.members.length}人`;
                        
                        infoDiv.appendChild(nameDiv);
                        infoDiv.appendChild(msgDiv);
                        
                        headerDiv.appendChild(avatar);
                        headerDiv.appendChild(infoDiv);
                        
                        chatPage.insertBefore(headerDiv, chatPage.firstChild);
                        
                        // 更新聊天区域的上边距，避免被固定头部遮挡
                        const msgContent = chatPage.querySelector('.msgcontent');
                        if (msgContent) {
                            msgContent.style.paddingTop = '70px';
                        }
                        
                        // 重新设置chatHeader
                        const updatedHeader = headerDiv;
                        updateHeaderContent(updatedHeader, groupData);
                        return;
                    } else {
                        console.error('也未找到聊天页面');
                        return;
                    }
                }
                
                updateHeaderContent(chatHeader, groupData);
            }
            
            /**
             * 更新头部内容的通用函数
             */
            function updateHeaderContent(chatHeader, groupData) {
                // *** 强制更新头像显示 ***
                const headerAvatar = chatHeader.querySelector('.QQ_home_head');
                console.log('*** 聊天界面头像更新 ***');
                console.log('头像元素:', headerAvatar);
                console.log('群聊头像数据:', groupData.avatar);
                
                if (headerAvatar) {
                    // 强制清空所有样式
                    headerAvatar.innerHTML = '';
                    headerAvatar.style.cssText = '';
                    
                    // 重新设置基础样式
                    headerAvatar.style.display = 'block';
                    headerAvatar.style.width = '40px';
                    headerAvatar.style.height = '40px';
                    headerAvatar.style.borderRadius = '50%';
                    headerAvatar.style.marginRight = '10px';
                    headerAvatar.style.flexShrink = '0';
                    headerAvatar.style.position = 'relative';
                    headerAvatar.style.overflow = 'hidden';
                    
                    // *** 强制更新头像内容 ***
                    if (groupData.avatar) {
                        console.log('强制更新群聊头像:', groupData.avatar.type);
                        
                        // 确保立即更新头像
                        updateAvatarElement(headerAvatar, groupData.avatar);
                        
                        // 延迟再次确保头像正确显示
                        setTimeout(() => {
                            console.log('延迟再次更新头像');
                            updateAvatarElement(headerAvatar, groupData.avatar);
                        }, 50);
                        
                        console.log('聊天界面头像已强制更新');
                    } else {
                        // 使用默认群聊头像
                        headerAvatar.style.background = 'linear-gradient(135deg, #199AFF, #0066CC)';
                        headerAvatar.style.backgroundImage = 'none';
                        headerAvatar.style.color = 'white';
                        headerAvatar.style.display = 'flex';
                        headerAvatar.style.alignItems = 'center';
                        headerAvatar.style.justifyContent = 'center';
                        headerAvatar.style.fontWeight = 'bold';
                        headerAvatar.textContent = '群';
                        console.log('使用默认群聊头像');
                    }
                } else {
                    console.warn('未找到聊天界面头像元素');
                }
                
                // *** 修复：更全面的名称元素查找和更新 ***
                console.log('=== 开始更新聊天头部名称显示 ===');
                console.log('目标群聊名称:', groupData.name);
                console.log('群聊成员数量:', groupData.members.length);
                
                // 查找多个可能的选择器，按重要性排序
                const nameSelectors = [
                    '#QQ_chat_username',        // 最常用的聊天用户名元素
                    '.QQ_home_name',           // 联系人名称元素
                    '.chat-title',             // 聊天标题元素
                    '.group-chat-title',       // 群聊标题元素
                    'h2',                      // 通用标题元素
                    '.name',                   // 通用名称元素
                    'span',                    // 通用span元素
                    'div'                      // 最后的备选
                ];
                
                let headerName = null;
                let selectorUsed = '';
                
                // 按优先级查找名称元素
                for (const selector of nameSelectors) {
                    headerName = chatHeader.querySelector(selector);
                    if (headerName) {
                        selectorUsed = selector;
                        console.log(`找到名称元素，使用选择器: ${selector}`);
                        break;
                    }
                }
                
                console.log('查找到的名称元素:', headerName);
                console.log('聊天头部的所有子元素:', Array.from(chatHeader.children).map(el => ({
                    tag: el.tagName,
                    class: el.className,
                    id: el.id,
                    text: el.textContent.trim().substring(0, 50)
                })));
                
                if (headerName) {
                    console.log('找到名称元素，开始更新...');
                    console.log('  - 当前内容:', headerName.textContent.trim());
                    console.log('  - 目标名称:', groupData.name);
                    console.log('  - 成员数量:', groupData.members.length);
                    
                    // *** 修复：正确设置群聊标题格式 ***
                    if (groupData.members && groupData.members.length >= 1) {
                        // 群聊格式：只显示名称，人数在副标题中显示
                        headerName.textContent = groupData.name;
                        console.log('已设置群聊标题:', groupData.name);
                        
                        // *** 重要修复：更新人数显示 ***
                        const memberCountElement = chatHeader.querySelector('.QQ_home_lastmsg, .group-member-count');
                        if (memberCountElement) {
                            const memberCount = groupData.members.length;
                            const countText = `群聊 · ${memberCount}人`;
                            memberCountElement.textContent = countText;
                            console.log('✅ 群聊人数已更新:', countText);
                        } else {
                            console.log('未找到人数显示元素，尝试创建...');
                            // 如果没有找到人数显示元素，创建一个
                            const nameContainer = headerName.parentElement;
                            if (nameContainer) {
                                const memberCountDiv = document.createElement('div');
                                memberCountDiv.className = 'QQ_home_lastmsg group-member-count';
                                memberCountDiv.style.cssText = 'font-size: 12px; color: #666; margin-top: 2px;';
                                memberCountDiv.textContent = `群聊 · ${groupData.members.length}人`;
                                nameContainer.appendChild(memberCountDiv);
                                console.log('✅ 已创建群聊人数显示元素');
                            }
                        }
                    } else {
                        // 私聊或无成员信息时，只显示名称
                        headerName.textContent = groupData.name;
                        console.log('已设置私聊标题:', groupData.name);
                    }
                    
                    // *** 核心修复：确保元素正确的可点击性 ***
                    // 移除可能存在的旧类名
                    headerName.classList.remove('group-chat-clickable-name');
                    
                    // 添加新的类名和样式
                    headerName.classList.add('group-chat-clickable-name');
                    headerName.style.cursor = 'pointer';
                    headerName.style.userSelect = 'none';
                    headerName.style.color = '#333';
                    headerName.style.fontWeight = 'bold';
                    
                    // 设置重要的数据属性
                    headerName.setAttribute('data-group-name', groupData.name);
                    headerName.setAttribute('data-group-id', groupData.id);
                    
                    // 移除旧的点击事件监听器
                    if (headerName._groupClickHandler) {
                        headerName.removeEventListener('click', headerName._groupClickHandler);
                        console.log('已移除旧的点击事件');
                    }
                    
                    // 添加新的点击事件
                    headerName._groupClickHandler = function(e) {
                        e.stopPropagation();
                        e.preventDefault();
                        console.log('群聊名称被点击 - 最新数据:', {
                            name: groupData.name,
                            id: groupData.id,
                            members: groupData.members.length
                        });
                        showGroupManagementMenu(groupData, headerName);
                    };
                    headerName.addEventListener('click', headerName._groupClickHandler);
                    
                    console.log('群聊名称点击事件已重新绑定');
                    console.log('  - 最终显示内容:', headerName.textContent.trim());
                    
                } else {
                    console.error('*** 未找到群名称元素，群名称更新失败 ***');
                    console.error('聊天头部结构:', chatHeader.outerHTML);
                    
                    // 创建新的名称元素作为最后手段
                    const nameElement = document.createElement('span');
                    nameElement.id = 'QQ_chat_username';
                    nameElement.className = 'QQ_home_name group-chat-clickable-name';
                    
                    // 设置群聊标题
                    if (groupData.members && groupData.members.length > 1) {
                        nameElement.textContent = `${groupData.name} (${groupData.members.length}人)`;
                    } else {
                    nameElement.textContent = groupData.name;
                    }
                    
                    nameElement.style.cssText = 'font-size: 16px; font-weight: bold; color: #333; margin-left: 10px; cursor: pointer; user-select: none;';
                    nameElement.setAttribute('data-group-name', groupData.name);
                    nameElement.setAttribute('data-group-id', groupData.id);
                    
                    // 添加点击事件
                    nameElement.addEventListener('click', function(e) {
                        e.stopPropagation();
                        e.preventDefault();
                        console.log('新创建的群聊名称被点击:', groupData.name);
                        showGroupManagementMenu(groupData, nameElement);
                    });
                    
                    chatHeader.appendChild(nameElement);
                    headerName = nameElement;
                    console.log('已创建新的群聊名称元素');
                }
                
                console.log('=== 聊天头部名称更新完成 ===');
                
                // 添加群聊成员数显示
                const headerMsg = chatHeader.querySelector('.QQ_home_lastmsg') || 
                                 chatHeader.querySelector('.chat-subtitle');
                
                if (headerMsg) {
                    headerMsg.textContent = `群聊 · ${groupData.members.length}人`;
                } else {
                    // 如果找不到副标题元素，创建一个
                    const subtitleElement = document.createElement('div');
                    subtitleElement.className = 'QQ_home_lastmsg';
                    subtitleElement.textContent = `群聊 · ${groupData.members.length}人`;
                    subtitleElement.style.cssText = 'font-size: 12px; color: #666; margin-left: 10px;';
                    chatHeader.appendChild(subtitleElement);
                }
            }
            
            /**
             * 加载群聊消息历史（增强版：支持系统消息）
             */
            function loadGroupChatHistory(groupId) {
                console.log('加载群聊消息历史:', groupId);
                
                const chatContainer = document.querySelector('#QQ_chat_msgs');
                if (!chatContainer) {
                    console.error('找不到聊天消息容器');
                    return;
                }
                
                // 清空现有消息
                chatContainer.innerHTML = '';
                
                // 检查是否有保存的群聊消息
                if (window.groupChatMessages && window.groupChatMessages[groupId]) {
                    const messages = window.groupChatMessages[groupId];
                    console.log(`群聊 ${groupId} 有 ${messages.length} 条消息`);
                    
                    // 显示所有消息（包括系统消息）
                    messages.forEach(message => {
                        if (message.type === 'system') {
                            // 显示系统消息
                            const systemMsgDiv = document.createElement('div');
                            systemMsgDiv.className = 'system-message';
                            systemMsgDiv.style.cssText = `
                                text-align: center;
                                color: #999;
                                font-size: 12px;
                                margin: 10px 0;
                                padding: 5px;
                                line-height: 1.4;
                            `;
                            systemMsgDiv.textContent = message.content;
                            chatContainer.appendChild(systemMsgDiv);
                        } else {
                            // 显示普通消息（这里可以扩展更多消息类型）
                            console.log('显示普通消息:', message);
                            // TODO: 添加普通消息显示逻辑
                        }
                    });
                }
                
                // 如果没有消息，显示欢迎消息
                if (chatContainer.children.length === 0) {
                    const welcomeDiv = document.createElement('div');
                    welcomeDiv.className = 'system-message';
                    welcomeDiv.style.cssText = `
                        text-align: center;
                        color: #999;
                        margin: 20px 0;
                        font-size: 14px;
                    `;
                    welcomeDiv.textContent = '欢迎来到群聊！开始聊天吧～';
                    chatContainer.appendChild(welcomeDiv);
                }
                
                // 滚动到底部
                chatContainer.scrollTop = chatContainer.scrollHeight;
            }

            // ==================== 群聊隔离功能 ====================
            
            /**
             * 获取当前群聊的成员列表
             */
            function getCurrentGroupMembers() {
                if (!window.currentGroupChat) {
                    return [];
                }
                return window.currentGroupChat.members || [];
            }
            
            /**
             * 检查角色是否在当前群聊中
             */
            function isCharacterInCurrentGroup(characterName) {
                if (!window.currentGroupChat) {
                    return true; // 如果不在群聊中，允许所有角色回复
                }
                
                const members = getCurrentGroupMembers();
                return members.includes(characterName);
            }
            
            /**
             * 群聊消息过滤器 - 只允许群聊成员看到消息
             */
            function filterGroupChatResponse(response) {
                if (!window.currentGroupChat) {
                    return response; // 不在群聊中，不需要过滤
                }
                
                const groupName = window.currentGroupChat.name;
                const members = getCurrentGroupMembers();
                
                console.log(`当前群聊: ${groupName}, 成员: [${members.join(', ')}]`);
                
                // 在响应中添加群聊上下文信息
                let contextInfo = `\n[群聊上下文]\n`;
                contextInfo += `- 当前群聊: ${groupName}\n`;
                contextInfo += `- 群聊成员: ${members.join('、')}\n`;
                contextInfo += `- 注意: 只有以上成员能够看到和回复此群聊中的消息\n`;
                contextInfo += `- 其他角色无法看到此群聊的内容\n`;
                
                return contextInfo + response;
            }
            
            /**
             * 重写QQ_Gen函数以支持群聊隔离
             */
            const originalQQGen = window.QQ_Gen;
            if (originalQQGen) {
                            window.QQ_Gen = async function(prompt, callback) {
                try {
                    // 如果在群聊中，添加隔离信息
                    if (window.currentGroupChat) {
                        const groupName = window.currentGroupChat.name;
                        const members = getCurrentGroupMembers();
                        
                        // 在prompt前添加群聊限制信息
                        const groupContext = `[重要: 当前在群聊"${groupName}"中，只有以下成员可以参与对话: ${members.join('、')}。其他角色无法看到此群聊消息，不应回复。]\n\n`;
                        prompt = groupContext + prompt;
                        
                        console.log('群聊消息发送，限制成员:', members);
                    }
                    
                    // 调用原始生成函数
                    const result = await originalQQGen(prompt);
                    
                    // 对结果进行群聊过滤
                    const filteredResult = filterGroupChatResponse(result);
                    
                    // 如果提供了回调函数，调用它
                    if (typeof callback === 'function') {
                        await callback(filteredResult);
                    }
                    
                    return filteredResult;
                } catch (error) {
                    console.error('QQ_Gen执行错误:', error);
                    
                    // 如果提供了回调函数，也要通知错误
                    if (typeof callback === 'function') {
                        try {
                            await callback(null, error);
                        } catch (callbackError) {
                            console.error('回调函数执行错误:', callbackError);
                        }
                    }
                    
                    throw error;
                }
                };
            }
            
            // ==================== 页面初始化增强 ====================
            
            /**
             * 增强的页面初始化，包含群聊功能
             */
            async function initializeEnhancedFeatures() {
                // 加载保存的群聊
                if (worldbook) {
                    await loadGroupChatsFromWorldbook();
                } else {
                    console.log('initializeEnhancedFeatures: worldbook未初始化，跳过群聊加载');
                }
                
                // 初始化分组功能
                if (typeof loadGroupsFromStorage === 'function' && worldbook) {
                    await loadGroupsFromStorage();
                } else if (!worldbook) {
                    console.log('initializeEnhancedFeatures: worldbook未初始化，跳过分组加载');
                }
                
                if (typeof initContactGroups === 'function') {
                    initContactGroups();
                }
                
                // *** 修复：在初始化完成后更新所有群聊的最后消息显示 ***
                setTimeout(async () => {
                    console.log('开始更新所有群聊的最后消息显示...');
                    try {
                        const groups = await loadGroupsFromStorage();
                        if (groups && Array.isArray(groups)) {
                        groups.forEach(groupData => {
                                if (groupData && groupData.name) {
                            updateGroupLastMessageDisplay(groupData.name);
                                }
                        });
                        console.log('所有群聊最后消息显示更新完成');
                        } else {
                            console.warn('群聊数据无效，跳过最后消息显示更新');
                        }
                    } catch (error) {
                        console.error('更新群聊最后消息显示时出错:', error);
                    }
                }, 500);
                
                // 初始化动态点赞功能
                if (typeof QQ_InitMomentLikes === 'function') {
                    QQ_InitMomentLikes();
                    console.log('- 动态点赞功能已启用');
                }
                
                // 加载动态点赞状态
                if (typeof QQ_LoadMomentLikes === 'function') {
                    await QQ_LoadMomentLikes();
                }
                
                console.log('增强功能初始化完成');
                console.log('- 群聊功能已启用');
                console.log('- 分组功能已启用');
                console.log('- 头像设置已启用');
                console.log('- 拖拽功能已启用');
            }
            
            // 在页面加载完成后初始化增强功能
            if (document.readyState === 'complete' || document.readyState === 'interactive') {
                setTimeout(initializeEnhancedFeatures, 1000);
            } else {
                document.addEventListener('DOMContentLoaded', () => {
                    setTimeout(initializeEnhancedFeatures, 1000);
                });
            }
            
        </script>
        
        <!-- 修复按钮点击问题：将关键函数放在单独的script标签中 -->
        <script>
            // 确保全局变量可用
            window.selectedAvatarData = null;
            
            // 确保这些函数在全局作用域中可用
            window.confirmAvatarSelection = function() {
                console.log('🔵 confirmAvatarSelection 被调用！');
                console.log('当前选中的头像数据:', window.selectedAvatarData);
                
                // 如果没有选择头像，使用默认头像
                if (!window.selectedAvatarData) {
                    window.selectedAvatarData = {
                        type: 'preset',
                        gradient: { start: '#199AFF', end: '#0066CC' },
                        text: '群'
                    };
                    console.log('使用默认头像:', window.selectedAvatarData);
                }
                
                const previewElement = document.getElementById('group_avatar_preview');
                const textElement = document.querySelector('.group-avatar-text');
                
                if (!previewElement || !textElement) {
                    console.error('找不到头像预览元素');
                    alert('找不到头像预览元素，请检查页面结构');
                    return;
                }
                
                try {
                    if (window.selectedAvatarData.type === 'preset') {
                        // 预设头像
                        const gradient = window.selectedAvatarData.gradient;
                        previewElement.style.background = `linear-gradient(135deg, ${gradient.start}, ${gradient.end})`;
                        previewElement.style.backgroundImage = 'none';
                        previewElement.innerHTML = `<div class="default-group-avatar">${window.selectedAvatarData.text}</div>`;
                        textElement.textContent = '已设置预设头像';
                    } else if (window.selectedAvatarData.type === 'upload') {
                        // 上传的头像
                        previewElement.style.background = 'none';
                        previewElement.style.backgroundImage = `url('${window.selectedAvatarData.imageData}')`;
                        previewElement.style.backgroundSize = 'cover';
                        previewElement.style.backgroundPosition = 'center';
                        previewElement.innerHTML = '';
                        textElement.textContent = '已设置自定义头像';
                    }
                    
                    console.log('头像设置成功，关闭选择器');
                    
                    // 关闭头像选择器
                    const modal = document.getElementById('avatar_selector_modal');
                    if (modal) {
                        modal.style.display = 'none';
                    }
                    
                    alert('头像设置成功！');
                    
                } catch (error) {
                    console.error('头像设置时出错:', error);
                    alert('头像设置失败：' + error.message);
                }
            };
            
            // 添加全局清理函数
            window.cleanupDuplicateGroups = cleanupDuplicateGroups;
            window.checkWorldbookGroups = checkWorldbookGroups;
            
            window.createGroupChat = async function() {
                console.log('🔵 createGroupChat 被调用！（使用新的世界书逻辑）');
                
                try {
                    const nameInput = document.getElementById('group_name_input');
                    if (!nameInput) {
                        console.error('找不到群聊名称输入框');
                        alert('系统错误：找不到群聊名称输入框');
                        return;
                    }
                    
                    const groupName = nameInput.value.trim();
                    console.log('群聊名称:', groupName);
                    
                    if (!groupName) {
                        alert('请输入群聊名称');
                        return;
                    }
                    
                    // 获取选中的成员
                    const selectedContacts = Array.from(document.querySelectorAll('#contact_list_for_group .contact-item.selected'));
                    
                    console.log('=== 群聊创建调试信息 ===');
                    console.log('所有联系人项目:', document.querySelectorAll('#contact_list_for_group .contact-item'));
                    console.log('选中的联系人项目:', selectedContacts);
                    console.log('选中的联系人数量:', selectedContacts.length);
                    
                    if (selectedContacts.length === 0) {
                        alert('请至少选择一个群成员');
                        return;
                    }
                    
                    // 禁用创建按钮防止重复点击
                    const confirmBtn = document.getElementById('group_confirm_btn');
                    if (confirmBtn) {
                        confirmBtn.disabled = true;
                        confirmBtn.textContent = '创建中...';
                    }
                    
                    // 获取成员列表
                    const members = selectedContacts.map(contact => {
                        const nameElement = contact.querySelector('.contact-name');
                        return nameElement ? nameElement.textContent.trim() : '';
                    }).filter(name => name);
                    
                    // 获取头像URL
                    let avatarUrl = 'http://sharkpan.xyz/f/z0WU5/mmexport1736971020657.gif';
                    if (window.selectedAvatarData && window.selectedAvatarData.type === 'upload' && window.selectedAvatarData.imageData) {
                        avatarUrl = window.selectedAvatarData.imageData;
                    }
                    
                    console.log('准备调用createNewGroup，参数:', { groupName, members, avatarUrl });
                    
                    // 使用新的createNewGroup函数（世界书逻辑）
                    const success = await createNewGroup(groupName, members, avatarUrl);
                    if (!success) {
                        // 恢复创建按钮状态
                        if (confirmBtn) {
                            confirmBtn.disabled = false;
                            confirmBtn.textContent = '创建群聊';
                        }
                        return;
                    }
                    
                    // 关闭弹窗
                    const modal = document.getElementById('group_create_modal');
                    if (modal) {
                        modal.style.display = 'none';
                    }
                    
                    // 重置表单
                    nameInput.value = '';
                    window.selectedAvatarData = null;
                    const preview = document.getElementById('group_avatar_preview');
                    const text = document.querySelector('.group-avatar-text');
                    if (preview && text) {
                        preview.style.background = 'linear-gradient(135deg, #199AFF, #0066CC)';
                        preview.innerHTML = '<div class="default-group-avatar">+</div>';
                        text.textContent = '点击设置头像';
                    }
                    
                    console.log('群聊创建成功:', groupName);
                    alert(`群聊"${groupName}"创建成功！`);
                    
                    // *** 关键修复：用户点击确认后，立即重新渲染联系人界面 ***
                    console.log('用户确认群聊创建完成，现在重新渲染联系人界面');
                    if (typeof renderContactGroups === 'function') {
                        await renderContactGroups();
                        console.log('联系人界面重新渲染完成，新群聊已显示');
                    }
                    
                    // 恢复创建按钮状态
                    if (confirmBtn) {
                        confirmBtn.disabled = false;
                        confirmBtn.textContent = '创建群聊';
                    }
                    
                } catch (error) {
                    console.error('创建群聊时出错:', error);
                    alert('创建群聊失败：' + error.message);
                    
                    // 恢复按钮状态
                    const confirmBtn = document.getElementById('group_confirm_btn');
                    if (confirmBtn) {
                        confirmBtn.disabled = false;
                        confirmBtn.textContent = '创建群聊';
                    }
                }
            };
            
            // saveGroupToStorage函数已移除，现在使用世界书存储
            
            /**
             * 从本地存储加载群聊数据
             */
            // 此函数已被loadGroupChatsFromWorldbook替代，为了兼容性保留别名
            /**
             * *** 已移除：重复的loadGroupsFromStorage函数 ***
             * 现在统一使用世界书加载机制
             */
            
            
            /**
             * 更新联系人列表中的群聊信息
             */
            function updateGroupInContactList(element, groupData) {
                const nameDiv = element.querySelector('.QQ_home_name');
                const msgDiv = element.querySelector('.QQ_home_lastmsg');
                
                if (nameDiv) nameDiv.textContent = groupData.name;
                if (msgDiv) msgDiv.textContent = `群聊 · ${groupData.members.length}人`;
            }
            
            /**
             * 更新消息列表中的群聊信息
             */
            function updateGroupInMessageList(element, groupData) {
                const nameDiv = element.querySelector('.QQ_home_name');
                const msgDiv = element.querySelector('.QQ_home_lastmsg');
                const timeDiv = element.querySelector('.QQ_home_lasttime');
                const avatarDiv = element.querySelector('.QQ_home_head');
                
                if (nameDiv) nameDiv.textContent = groupData.name;
                if (msgDiv) msgDiv.textContent = groupData.lastMessage || '群聊已创建';
                if (timeDiv) {
                    const currentTime = new Date();
                    const timeString = groupData.timestamp || groupData.lastTime || currentTime.toLocaleTimeString('zh-CN', { hour12: false }).slice(0, 5);
                    timeDiv.textContent = timeString;
                }
                
                // 更新头像
                if (avatarDiv) {
                    if (groupData.avatar && groupData.avatar.type === 'preset' && groupData.avatar.gradient) {
                        const gradient = groupData.avatar.gradient;
                        avatarDiv.style.background = `linear-gradient(135deg, ${gradient.start}, ${gradient.end})`;
                        avatarDiv.style.color = 'white';
                        avatarDiv.style.display = 'flex';
                        avatarDiv.style.alignItems = 'center';
                        avatarDiv.style.justifyContent = 'center';
                        avatarDiv.style.fontWeight = 'bold';
                        avatarDiv.style.fontSize = '18px';
                        avatarDiv.textContent = groupData.avatar.text || '群';
                    } else if (groupData.avatar && groupData.avatar.type === 'upload' && groupData.avatar.imageData) {
                        // 清除所有可能冲突的样式
                        avatarDiv.style.background = '';
                        avatarDiv.style.backgroundColor = '';
                        avatarDiv.style.color = '';
                        avatarDiv.style.display = 'block'; // 确保元素可见
                        avatarDiv.style.alignItems = '';
                        avatarDiv.style.justifyContent = '';
                        avatarDiv.style.fontWeight = '';
                        avatarDiv.style.fontSize = '';
                        avatarDiv.textContent = '';
                        
                        // 确保基础尺寸样式正确
                        avatarDiv.style.width = '40px';
                        avatarDiv.style.height = '40px';
                        avatarDiv.style.borderRadius = '50%';
                        avatarDiv.style.minWidth = '40px';
                        
                        // 设置背景图片
                        avatarDiv.style.backgroundImage = `url('${groupData.avatar.imageData}')`;
                        avatarDiv.style.backgroundSize = 'cover';
                        avatarDiv.style.backgroundPosition = 'center';
                        avatarDiv.style.backgroundRepeat = 'no-repeat';
                    } else {
                        // 默认头像
                        avatarDiv.style.background = 'linear-gradient(135deg, #199AFF, #0066CC)';
                        avatarDiv.style.color = 'white';
                        avatarDiv.style.display = 'flex';
                        avatarDiv.style.alignItems = 'center';
                        avatarDiv.style.justifyContent = 'center';
                        avatarDiv.style.fontWeight = 'bold';
                        avatarDiv.style.fontSize = '18px';
                        avatarDiv.textContent = '群';
                        avatarDiv.style.backgroundImage = '';
                    }
                }
            }
            
            /**
             * 页面加载时恢复群聊数据
             */
            async function restoreGroupChats() {
                console.log('恢复群聊数据...');
                if (!worldbook) {
                    console.log('restoreGroupChats: worldbook未初始化，跳过群聊恢复');
                    return;
                }
                const groups = await loadGroupsFromStorage();
                
                groups.forEach(groupData => {
                    console.log('恢复群聊:', groupData.name);
                    AddNewGroup(groupData.name, groupData.avatar || 'https://files.catbox.moe/skngqq.jpg', groupData.members, groupData.description);
                });
                
                console.log('群聊数据恢复完成，共', groups.length, '个群聊');
            }
            
            // 页面加载完成后恢复群聊数据（暂时禁用，避免与统一初始化冲突）
            // document.addEventListener('DOMContentLoaded', function() {
            //     setTimeout(restoreGroupChats, 500);
            // });
            
            // 如果页面已经加载完成，立即恢复（暂时禁用，避免与统一初始化冲突）
            // if (document.readyState === 'complete' || document.readyState === 'interactive') {
            //     setTimeout(restoreGroupChats, 500);
            // }
            
            // ==================== 群聊管理功能 ====================
            
            let currentManagingGroup = null;
            
            /**
             * 显示群聊管理下拉菜单
             */
            function showGroupManagementMenu(groupData, triggerElement) {
                console.log('=== showGroupManagementMenu 被调用 ===');
                console.log('显示群聊管理菜单:', groupData.name);
                
                // *** 关键修复：直接从世界书获取最新的头像数据 ***
                console.log('原始groupData:', JSON.stringify(groupData, null, 2));
                
                currentManagingGroup = Object.assign({}, groupData); // 创建副本
                
                // 从世界书获取最新的头像数据
                try {
                    const worldbookAvatar = getGroupAvatarFromWorldbook(groupData.name);
                    if (worldbookAvatar && worldbookAvatar.avatarUrl) {
                        console.log('从世界书获取到最新头像数据:', worldbookAvatar.avatarUrl);
                        
                        // 根据头像数据类型构建正确的格式
                        if (worldbookAvatar.avatarUrl.startsWith('data:')) {
                            // Base64数据，构建为上传格式
                            currentManagingGroup.avatar = {
                                type: 'upload',
                                imageData: worldbookAvatar.avatarUrl,
                                dataSize: Math.round(worldbookAvatar.avatarUrl.length * 0.75)
                            };
                            console.log('世界书头像为Base64格式，已转换为对象格式');
                        } else {
                            // URL格式，直接使用
                            currentManagingGroup.avatar = worldbookAvatar.avatarUrl;
                            console.log('世界书头像为URL格式，直接使用');
                        }
                    } else {
                        console.log('世界书中未找到头像数据，保持原始头像');
                    }
                } catch (error) {
                    console.error('从世界书获取头像失败:', error);
                }
                
                console.log('currentManagingGroup 已设置为:', currentManagingGroup);
                console.log('currentManagingGroup 头像数据:', currentManagingGroup.avatar);
                
                const dropdown = document.getElementById('group_management_dropdown');
                if (!dropdown) {
                    console.error('未找到群聊管理下拉菜单元素');
                    return;
                }
                
                // 设置下拉菜单位置
                const rect = triggerElement.getBoundingClientRect();
                dropdown.style.position = 'fixed';
                dropdown.style.top = (rect.bottom + 5) + 'px';
                dropdown.style.left = rect.left + 'px';
                dropdown.style.width = Math.max(200, rect.width) + 'px';
                
                // 生成群成员列表
                const membersList = document.getElementById('group_members_display');
                membersList.innerHTML = '';
                
                groupData.members.forEach((memberName, index) => {
                    const memberItem = document.createElement('div');
                    memberItem.className = 'group-member-item';
                    
                    const memberAvatar = document.createElement('div');
                    memberAvatar.className = 'group-member-avatar';
                    
                    // *** 修复：优先从世界书获取成员头像 ***
                    console.log(`群聊下拉菜单：获取成员 ${memberName} 头像`);
                    const worldbookAvatar = getCharacterAvatarFromWorldbook(memberName);
                    if (worldbookAvatar) {
                        memberAvatar.style.backgroundImage = worldbookAvatar.backgroundImage;
                        memberAvatar.style.backgroundSize = 'cover';
                        memberAvatar.style.backgroundPosition = 'center';
                        memberAvatar.style.backgroundRepeat = 'no-repeat';
                        memberAvatar.style.borderRadius = '50%';
                        memberAvatar.style.width = '32px';
                        memberAvatar.style.height = '32px';
                        memberAvatar.style.flexShrink = '0';
                        memberAvatar.textContent = '';
                        console.log(`群聊下拉菜单：成功应用 ${memberName} 的世界书头像`);
                    } else {
                        // 备选方案
                        const memberAvatarData = getCharacterAvatar(memberName);
                        applyCharacterAvatar(memberAvatar, memberAvatarData, memberName);
                        memberAvatar.style.width = '32px';
                        memberAvatar.style.height = '32px';
                        console.log(`群聊下拉菜单：使用备选方案为 ${memberName} 应用头像`);
                    }
                    
                    const memberNameDiv = document.createElement('div');
                    memberNameDiv.className = 'group-member-name';
                    memberNameDiv.textContent = memberName;
                    
                    memberItem.appendChild(memberAvatar);
                    memberItem.appendChild(memberNameDiv);
                    membersList.appendChild(memberItem);
                });
                
                // 显示下拉菜单
                dropdown.style.display = 'block';
                
                // 添加点击外部关闭功能
                setTimeout(() => {
                    document.addEventListener('click', closeGroupManagementMenu);
                }, 100);
            }
            
            /**
             * 关闭群聊管理下拉菜单
             */
            function closeGroupManagementMenu(event) {
                const dropdown = document.getElementById('group_management_dropdown');
                if (!dropdown) return;
                
                // 如果点击的是下拉菜单内部，不关闭
                if (event && dropdown.contains(event.target)) {
                    return;
                }
                
                dropdown.style.display = 'none';
                document.removeEventListener('click', closeGroupManagementMenu);
            }
            
            /**
             * 显示群聊设置模态窗口
             */
            function showGroupSettings() {
                console.log('=== showGroupSettings 被调用 ===');
                if (!currentManagingGroup) {
                    console.error('没有当前管理的群聊');
                    return;
                }
                
                console.log('显示群聊设置:', currentManagingGroup.name);
                
                // 关闭下拉菜单
                closeGroupManagementMenu();
                
                const modal = document.getElementById('group_settings_modal');
                if (!modal) {
                    console.error('未找到群聊设置模态窗口');
                    return;
                }
                
                // 填充当前群聊信息
                const nameInput = document.getElementById('group_name_edit');
                if (nameInput) {
                    nameInput.value = currentManagingGroup.name;
                }
                
                // *** 修复：优先从世界书获取群聊头像 ***
                const avatarPreview = document.getElementById('group_settings_avatar_preview');
                if (avatarPreview) {
                    avatarPreview.innerHTML = '';
                    
                    console.log(`群聊设置：获取群聊 ${currentManagingGroup.name} 头像`);
                    
                    // 首先尝试从世界书获取群聊头像
                    const worldbookGroupAvatar = getGroupAvatarFromWorldbook(currentManagingGroup.name);
                    let realAvatarFound = false;
                    
                    if (worldbookGroupAvatar) {
                        console.log(`从世界书获取到群聊 ${currentManagingGroup.name} 头像:`, worldbookGroupAvatar);
                        const avatarImg = document.createElement('div');
                        avatarImg.style.backgroundImage = worldbookGroupAvatar.backgroundImage;
                        avatarImg.style.backgroundSize = 'cover';
                        avatarImg.style.backgroundPosition = 'center';
                        avatarImg.style.backgroundRepeat = 'no-repeat';
                        avatarImg.style.borderRadius = '12px';
                        avatarImg.style.width = '100%';
                        avatarImg.style.height = '100%';
                        avatarPreview.appendChild(avatarImg);
                        realAvatarFound = true;
                    } else {
                        // 备选方案：从群聊列表中获取真实的头像数据
                        const contactsContainer = document.getElementById('QQ_home_chars');
                        
                        if (contactsContainer) {
                            const groupElements = contactsContainer.querySelectorAll('.QQ_home_char[data-group-type="true"]');
                            for (let element of groupElements) {
                                const nameElement = element.querySelector('.QQ_home_name');
                                if (nameElement && nameElement.textContent.trim() === currentManagingGroup.name) {
                                    const avatarElement = element.querySelector('.QQ_home_head');
                                    if (avatarElement) {
                                        // 创建一个和联系人列表中相同的头像
                                        const avatarClone = document.createElement('div');
                                        avatarClone.style.cssText = avatarElement.style.cssText;
                                        avatarClone.style.width = '60px';
                                        avatarClone.style.height = '60px';
                                        avatarClone.style.fontSize = '20px';
                                        avatarClone.textContent = avatarElement.textContent;
                                        avatarPreview.appendChild(avatarClone);
                                        realAvatarFound = true;
                                        break;
                                    }
                                }
                            }
                        }
                        
                        // 如果没有找到真实头像，尝试使用存储的头像数据
                        if (!realAvatarFound && currentManagingGroup.avatar) {
                            if (currentManagingGroup.avatar.startsWith('avatar_')) {
                                const avatarData = localStorage.getItem(`avatarData_${currentManagingGroup.avatar.replace('avatar_', '')}`);
                                if (avatarData) {
                                    const img = document.createElement('img');
                                    img.src = avatarData;
                                    img.alt = '群聊头像';
                                    img.style.width = '100%';
                                    img.style.height = '100%';
                                    img.style.objectFit = 'cover';
                                    avatarPreview.appendChild(img);
                                    realAvatarFound = true;
                                }
                            } else if (currentManagingGroup.avatar.startsWith('http')) {
                                // 直接是URL
                                const img = document.createElement('img');
                                img.src = currentManagingGroup.avatar;
                                img.alt = '群聊头像';
                                img.style.width = '100%';
                                img.style.height = '100%';
                                img.style.objectFit = 'cover';
                                avatarPreview.appendChild(img);
                                realAvatarFound = true;
                            }
                        }
                    }
                    
                    // 如果仍然没有头像，显示默认头像
                    if (!realAvatarFound) {
                        const defaultAvatar = document.createElement('div');
                        defaultAvatar.className = 'group-settings-default-avatar';
                        defaultAvatar.textContent = currentManagingGroup.name.charAt(0);
                        defaultAvatar.style.background = 'linear-gradient(135deg, #667eea, #764ba2)';
                        defaultAvatar.style.color = 'white';
                        defaultAvatar.style.width = '100%';
                        defaultAvatar.style.height = '100%';
                        defaultAvatar.style.display = 'flex';
                        defaultAvatar.style.alignItems = 'center';
                        defaultAvatar.style.justifyContent = 'center';
                        avatarPreview.appendChild(defaultAvatar);
                        console.log(`群聊设置：使用默认头像显示 ${currentManagingGroup.name}`);
                    }
                }
                
                // 生成群成员编辑列表
                const membersEdit = document.getElementById('group_members_edit');
                if (membersEdit) {
                    membersEdit.innerHTML = '';
                    
                    // 添加现有成员
                    currentManagingGroup.members.forEach((memberName, index) => {
                        const memberItem = document.createElement('div');
                        memberItem.className = 'group-settings-member-item';
                        
                        const memberInfo = document.createElement('div');
                        memberInfo.className = 'group-settings-member-info';
                        
                        const memberAvatar = document.createElement('div');
                        memberAvatar.className = 'group-member-avatar';
                        
                        // *** 修复：优先从世界书获取成员头像 ***
                        console.log(`群聊设置：获取成员 ${memberName} 头像`);
                        const worldbookAvatar = getCharacterAvatarFromWorldbook(memberName);
                        if (worldbookAvatar) {
                            memberAvatar.style.backgroundImage = worldbookAvatar.backgroundImage;
                            memberAvatar.style.backgroundSize = 'cover';
                            memberAvatar.style.backgroundPosition = 'center';
                            memberAvatar.style.backgroundRepeat = 'no-repeat';
                            memberAvatar.style.borderRadius = '50%';
                            memberAvatar.style.width = '32px';
                            memberAvatar.style.height = '32px';
                            memberAvatar.style.flexShrink = '0';
                            memberAvatar.textContent = '';
                            console.log(`群聊设置：成功应用 ${memberName} 的世界书头像`);
                        } else {
                            // 备选方案
                            const memberAvatarData = getCharacterAvatar(memberName);
                            applyCharacterAvatar(memberAvatar, memberAvatarData, memberName);
                            memberAvatar.style.width = '32px';
                            memberAvatar.style.height = '32px';
                            console.log(`群聊设置：使用备选方案为 ${memberName} 应用头像`);
                        }
                        
                        const memberNameDiv = document.createElement('div');
                        memberNameDiv.className = 'group-member-name';
                        memberNameDiv.textContent = memberName;
                        
                        memberInfo.appendChild(memberAvatar);
                        memberInfo.appendChild(memberNameDiv);
                        
                        const removeBtn = document.createElement('button');
                        removeBtn.className = 'group-settings-remove-btn';
                        removeBtn.textContent = '移除';
                        removeBtn.onclick = () => removeMemberFromGroup(memberName);
                        
                        memberItem.appendChild(memberInfo);
                        memberItem.appendChild(removeBtn);
                        membersEdit.appendChild(memberItem);
                    });
                    
                    // 添加"添加成员"按钮
                    const addMemberItem = document.createElement('div');
                    addMemberItem.className = 'group-settings-add-member-item';
                    
                    const addMemberBtn = document.createElement('button');
                    addMemberBtn.className = 'group-settings-add-member-btn';
                    addMemberBtn.innerHTML = '<span class="add-member-icon">+</span><span class="add-member-text">添加成员</span>';
                    addMemberBtn.onclick = () => showAddMemberModal();
                    
                    addMemberItem.appendChild(addMemberBtn);
                    membersEdit.appendChild(addMemberItem);
                }
                
                // 显示模态窗口
                modal.style.display = 'flex';
            }
            
            /**
             * 关闭群聊设置模态窗口
             */
            function closeGroupSettings() {
                const modal = document.getElementById('group_settings_modal');
                if (modal) {
                    modal.style.display = 'none';
                }
            }
            
            /**
             * 从群聊中移除成员
             */
            async function removeMemberFromGroup(memberName) {
                if (!currentManagingGroup) return;
                
                if (confirm(`确定要将 ${memberName} 移出群聊吗？`)) {
                    const index = currentManagingGroup.members.indexOf(memberName);
                    if (index > -1) {
                        currentManagingGroup.members.splice(index, 1);
                        console.log(`已从群聊中移除成员: ${memberName}`);
                        
                        // *** 立即更新当前聊天界面（如果正在群聊中） ***
                        if (window.currentGroupChat && window.currentGroupChat.id === currentManagingGroup.id) {
                            console.log('立即更新当前群聊界面（移除成员后）');
                            
                            // 更新当前群聊对象
                            window.currentGroupChat.members = currentManagingGroup.members;
                            
                            // 立即更新聊天界面头部显示（包括人数）
                            updateChatHeader(currentManagingGroup);
                            
                            console.log('群聊界面头部已立即更新，人数:', currentManagingGroup.members.length);
                        }
                        
                        // *** 修复：添加系统消息并立即显示 ***
                        const systemMessage = `群主将${memberName}移出了群聊`;
                        
                        // *** 修复：总是显示系统消息，不依赖界面状态检查 ***
                        console.log('显示移除成员系统消息:', systemMessage);
                        await addSystemMessageToGroup(currentManagingGroup.id, systemMessage);
                        
                        // *** 修复：强制立即显示系统消息 ***
                        console.log('强制立即显示移除成员系统消息:', systemMessage);
                        displaySystemMessage(systemMessage, currentManagingGroup.id);
                        
                                // *** 立即更新所有界面中的群聊显示 ***
        console.log('立即更新联系人列表中的群聊显示（移除成员后）...');
        
        // *** 关键修复：确保传递完整的群聊数据，包括头像信息 ***
        console.log('传递给protectedContactListUpdate的数据:', {
            name: currentManagingGroup.name,
            id: currentManagingGroup.id,
            avatar: currentManagingGroup.avatar,
            members: currentManagingGroup.members
        });
        await protectedContactListUpdate(currentManagingGroup, 'remove_member');
        
        // 更新到世界书
        await updateGroupMembersInWorldbook(currentManagingGroup.name, currentManagingGroup.members);
        
        // *** 轻量级界面更新，避免消息丢失 ***
        console.log('执行轻量级界面更新（移除成员后）...');
        await refreshGroupChatsDisplay();
                        
                        // 重新生成成员列表
                        showGroupSettings();
                    }
                }
            }
            
            /**
             * 显示群聊头像选择器
             */
            function showGroupAvatarSelector() {
                if (!currentManagingGroup) {
                    console.error('没有当前管理的群聊');
                    return;
                }
                
                // 设置全局变量，标识当前是在群聊设置中选择头像
                window.isSelectingGroupAvatar = true;
                window.currentAvatarGroup = currentManagingGroup;
                
                // 显示头像选择器模态窗口
                const avatarModal = document.getElementById('avatar_selector_modal');
                if (avatarModal) {
                    avatarModal.style.display = 'flex';
                    
                    // 切换到上传标签页
                    switchAvatarTab('upload');
                } else {
                    console.error('未找到头像选择器模态窗口');
                }
            }
            
            // *** 旧的群聊头像上传函数已移除，现在使用统一的 handleAvatarUpload 和 confirmAvatarSelection 逻辑 ***

            /**
             * 保存群聊设置（增强修复版：立即生效，保持消息不丢失）
             */
            async function saveGroupSettings() {
                if (!currentManagingGroup) return;
                
                const nameInput = document.getElementById('group_name_edit');
                const newName = nameInput ? nameInput.value.trim() : '';
                
                if (!newName) {
                    alert('群聊名称不能为空');
                    return;
                }
                
                console.log('=== 保存群聊设置（增强修复版） ===');
                console.log('原群聊名称:', currentManagingGroup.name);
                console.log('新群聊名称:', newName);
                console.log('选中的头像数据:', window.selectedAvatarData);
                
                // *** 重要修复：确保世界书变量已正确初始化 ***
                try {
                    if (!worldbook) {
                        console.log('世界书变量未初始化，重新获取...');
                        worldbook = await GetWorldBookName();
                        if (!worldbook) {
                            console.error('无法获取世界书，保存操作终止');
                            alert('无法连接到世界书，请稍后重试');
                            return;
                        }
                    }
                    
                    if (!entries) {
                        console.log('entries变量未初始化，重新获取...');
                        entries = await getLorebookEntries(worldbook);
                        if (!entries) {
                            console.error('无法获取世界书条目，保存操作终止');
                            alert('无法读取世界书数据，请稍后重试');
                            return;
                        }
                    }
                    
                    console.log('世界书初始化检查完成，worldbook:', worldbook, 'entries数量:', entries.length);
                } catch (error) {
                    console.error('世界书初始化失败:', error);
                    alert('世界书初始化失败，请稍后重试');
                    return;
                }
                
                // 保存旧的信息
                const oldName = currentManagingGroup.name;
                const oldId = currentManagingGroup.id;
                const oldAvatar = currentManagingGroup.avatar;
                
                // *** 重要修复：确保头像数据完整性 ***
                console.log('检查头像数据完整性:');
                console.log('- currentManagingGroup.avatar:', currentManagingGroup.avatar);
                console.log('- window.selectedAvatarData:', window.selectedAvatarData);
                
                // *** 关键修复：从世界书comment中获取原始群聊名称，确保ID稳定 ***
                let originalGroupName = oldName; // 默认使用当前名称
                try {
                    if (entries) {
                        const groupEntry = entries.find(e => 
                            e.comment === `手机-群聊-${oldName}` || 
                            e.comment.startsWith('手机-群聊-') && 
                            e.content.includes(`[${oldName}]`)
                        );
                        
                        if (groupEntry && groupEntry.comment.startsWith('手机-群聊-')) {
                            originalGroupName = groupEntry.comment.replace('手机-群聊-', '');
                            console.log('从世界书comment中获取到原始群聊名称:', originalGroupName);
                        }
                    }
                } catch (error) {
                    console.warn('获取原始群聊名称时出错，使用当前名称:', error);
                }
                
                // *** 修复：确保ID保持稳定，基于原始名称生成 ***
                const stableGroupId = `group_${originalGroupName.replace(/[^a-zA-Z0-9\u4e00-\u9fff]/g, '_')}`;
                console.log('使用稳定的群聊ID:', stableGroupId, '(基于原始名称:', originalGroupName, ')');
                
                // 记录变更类型
                const changes = [];
                
                // 更新群聊名称（保持ID不变）
                if (newName !== oldName) {
                    // *** 核心修复：完整的数据绑定迁移 ***
                    console.log('=== 执行完整数据绑定迁移 ===');
                    const migratedCount = await migrateGroupDataBindings(oldName, newName, currentManagingGroup);
                    console.log(`数据绑定迁移完成，共迁移 ${migratedCount} 项`);
                    
                    currentManagingGroup.name = newName;
                    currentManagingGroup.id = stableGroupId;
                    changes.push({
                        type: 'name',
                        oldValue: oldName,
                        newValue: newName
                    });
                }
                
                // *** 修复：更新头像信息 ***
                if (window.selectedAvatarData) {
                    console.log('检测到新的头像数据，更新群聊头像:', window.selectedAvatarData);
                    currentManagingGroup.avatar = window.selectedAvatarData;
                    
                    // 如果是上传的头像，确保数据格式正确
                    if (window.selectedAvatarData.type === 'upload' && window.selectedAvatarData.imageData) {
                        currentManagingGroup.avatarUrl = window.selectedAvatarData.imageData;
                    }
                    
                    changes.push({
                        type: 'avatar',
                        oldValue: oldAvatar,
                        newValue: window.selectedAvatarData
                    });
                } else {
                    // *** 关键修复：如果没有新头像数据，确保保持原有头像 ***
                    console.log('没有新头像数据，保持原有头像:', currentManagingGroup.avatar);
                    console.log('原有头像数据类型:', typeof currentManagingGroup.avatar);
                    console.log('原有头像数据详情:', currentManagingGroup.avatar);
                    
                    // *** 关键修复：处理不同格式的头像数据 ***
                    if (currentManagingGroup.avatar) {
                        // 情况1：头像是字符串URL（需要保持不变）
                        if (typeof currentManagingGroup.avatar === 'string') {
                            console.log('检测到字符串类型头像，保持不变:', currentManagingGroup.avatar);
                            // 保持字符串格式的头像不变
                            // 不需要额外处理，字符串头像会被updateAvatarElement正确处理
                        }
                        // 情况2：头像是对象，检查是否需要补充数据
                        else if (typeof currentManagingGroup.avatar === 'object' && currentManagingGroup.avatar.type) {
                            console.log('检测到对象类型头像，检查数据完整性');
                            // 如果有avatarUrl但没有在avatar对象中，需要补充
                            if (currentManagingGroup.avatarUrl && 
                                currentManagingGroup.avatar.type === 'upload' && 
                                !currentManagingGroup.avatar.imageData) {
                                currentManagingGroup.avatar.imageData = currentManagingGroup.avatarUrl;
                                console.log('修复头像数据格式，添加imageData');
                            }
                        }
                        // 情况3：头像数据格式异常，尝试从avatarUrl恢复
                        else {
                            console.log('头像数据格式异常，尝试从avatarUrl恢复');
                            if (currentManagingGroup.avatarUrl) {
                                console.log('使用avatarUrl作为头像:', currentManagingGroup.avatarUrl);
                                currentManagingGroup.avatar = currentManagingGroup.avatarUrl;
                            } else {
                                console.log('无法恢复头像数据，设置默认头像');
                                currentManagingGroup.avatar = {
                                    type: 'preset',
                                    text: '群',
                                    gradient: {
                                        start: '#199AFF',
                                        end: '#0066CC'
                                    }
                                };
                            }
                        }
                    } else {
                        // 情况4：完全没有头像数据，尝试从avatarUrl恢复或设置默认
                        console.log('没有头像数据，检查是否有avatarUrl...');
                        if (currentManagingGroup.avatarUrl) {
                            console.log('使用avatarUrl作为头像:', currentManagingGroup.avatarUrl);
                            currentManagingGroup.avatar = currentManagingGroup.avatarUrl;
                        } else {
                            console.log('设置默认头像');
                            currentManagingGroup.avatar = {
                                type: 'preset',
                                text: '群',
                                gradient: {
                                    start: '#199AFF',
                                    end: '#0066CC'
                                }
                            };
                        }
                    }
                    
                    console.log('头像数据处理完成:', currentManagingGroup.avatar);
                }
                
                // *** 核心修复1：在保存到世界书之前，先立即更新界面 ***
                console.log('=== 立即更新界面显示（保存前） ===');
                
                // 简化：基本DOM更新（交给数据迁移函数处理）
                console.log('基本DOM属性更新已由migrateGroupDataBindings处理');
                
                // *** 简化的界面更新流程 ***
                console.log('=== 简化界面更新流程 ===');
                
                // 更新当前群聊对象（如果存在）
                    if (window.currentGroupChat && window.currentGroupChat.id === stableGroupId) {
                        window.currentGroupChat.name = currentManagingGroup.name;
                        window.currentGroupChat.avatar = currentManagingGroup.avatar;
                        window.currentGroupChat.avatarUrl = currentManagingGroup.avatarUrl;
                        window.currentGroupChat.members = currentManagingGroup.members;
                }
                
                // 1. 立即更新标题
                console.log('开始寻找聊天头部进行更新...');
                
                // 查找当前可见的聊天页面头部
                let chatHeader = null;
                const visibleChatPage = document.querySelector('.QQ_chat_page[style*="display:block"], .QQ_chat_page:not([style*="display:none"])');
                if (visibleChatPage) {
                    chatHeader = visibleChatPage.querySelector('.QQ_chat_header, .QQ_home');
                }
                
                            if (chatHeader) {
                    console.log('找到聊天头部，开始更新标题...');
                                updateHeaderContent(chatHeader, currentManagingGroup);
                } else {
                    console.log('未找到可见的聊天头部，跳过标题更新');
                }
                
                // 2. 延迟恢复背景和更新联系人（避免冲突）
                setTimeout(async () => {
                    // 重新应用群聊背景
                    reapplyGroupChatBackground(currentManagingGroup);
                    
                    // 保护性联系人更新
                    await protectedContactListUpdate(currentManagingGroup, oldName);
                    
                    console.log('界面更新流程完成');
                }, 150);
                
                // 确保使用稳定ID
                currentManagingGroup.id = stableGroupId;
                
                // 现在才保存到世界书
                if (oldName !== newName) {
                    await updateGroupNameInWorldbook(oldName, newName);
                } else {
                    // 即使名称没变，也要保存头像等其他信息
                    await saveGroupToWorldbook(currentManagingGroup);
                }
                
                // *** 核心修复4：添加系统消息并立即显示 ***
                if (changes.length > 0) {
                    console.log('添加系统消息，变更列表:', changes);
                    
                    // 为每个变更生成系统消息
                    for (const change of changes) {
                        let systemMessage = '';
                        switch (change.type) {
                            case 'name':
                                systemMessage = `群聊名称已更改为"${change.newValue}"`;
                                break;
                            case 'avatar':
                                systemMessage = `群主已更改群头像`;
                                break;
                        }
                        
                        if (systemMessage) {
                            console.log('处理系统消息:', systemMessage);
                            
                            // 保存到群聊消息历史中
                            await addSystemMessageToGroup(stableGroupId, systemMessage);
                            
                            // *** 强制在当前聊天界面显示系统消息（超强制版） ***
                            console.log('检查当前聊天状态:', {
                                currentGroupChat: window.currentGroupChat ? window.currentGroupChat.id : 'null',
                                targetGroupId: stableGroupId,
                                isMatching: window.currentGroupChat && window.currentGroupChat.id === stableGroupId
                            });
                            
                            // 简化：如果能操作群聊设置，就直接显示系统消息
                            console.log('*** 显示系统消息 ***:', systemMessage);
                            console.log('当前聊天页面状态检查...');
                            
                            // 显示系统消息到正确的群聊
                            console.log('显示系统消息到当前操作的群聊:', currentManagingGroup.id);
                            displaySystemMessage(systemMessage, currentManagingGroup.id);
                        }
                    }
                }
                
                // *** 修复：更新消息JSON中的群聊信息，保持聊天记录 ***
                if (oldName !== newName) {
                    await updateGroupChatMessagesInMsgjson(stableGroupId, oldName, newName);
                }
                
                // 清空选中的头像数据
                window.selectedAvatarData = null;
                
                console.log(`群聊设置已保存并立即生效: ${oldName} -> ${newName}`);
                alert('群聊设置已保存');
                closeGroupSettings();
            }
            
            /**
             * 删除当前群聊
             */
            async function deleteCurrentGroup() {
                if (!currentManagingGroup) return;
                
                if (confirm(`确定要删除群聊 "${currentManagingGroup.name}" 吗？此操作不可撤销。`)) {
                    console.log('删除群聊:', currentManagingGroup.name);
                    
                    const deletedGroupId = currentManagingGroup.id;
                    const deletedGroupName = currentManagingGroup.name;
                    
                    // **关键修复：先关闭模态窗口并立即跳转，避免界面卡死**
                    closeGroupSettings();
                    
                    // 记录跳转目标和当前状态
                    let shouldJumpToPage = null;
                    let wasInGroupChat = false;
                    
                    if (window.currentGroupChat && window.currentGroupChat.id === deletedGroupId) {
                        shouldJumpToPage = window.groupChatSourcePage || 'people';
                        wasInGroupChat = true;
                        console.log('删除群聊后需要跳转到页面:', shouldJumpToPage);
                        console.log('当前在群聊界面，需要跳转');
                    } else {
                        // 即使不在群聊界面，也要确保删除后刷新当前页面
                        shouldJumpToPage = 'people'; // 默认跳转到联系人页面
                        console.log('不在群聊界面，但仍需要刷新界面');
                    }
                    
                    // 等待模态窗口关闭后再执行删除操作
                    setTimeout(async () => {
                        try {
                            // 从世界书中删除
                            await removeGroupFromWorldbook(deletedGroupName);
                            console.log('群聊已从世界书中删除');
                            
                            // 立即刷新entries
                            console.log('刷新entries以移除已删除的群聊');
                            entries = await getLorebookEntries(worldbook);
                            console.log('entries刷新成功，新的条目数量:', entries ? entries.length : 'failed');
                            

                            
                            // 从数据结构中删除群聊（内存清理）
                            delete QQ_msgjson.群聊[deletedGroupName];
                            console.log('群聊已从QQ_msgjson中删除');
                            
                            // **先清除群聊状态，避免跳转时的状态冲突**
                            if (wasInGroupChat) {
                                window.currentGroupChat = null;
                                window.groupChatSourcePage = null;
                                console.log('已清除群聊状态');
                            }
                            
                            // **立即跳转到目标页面**
                            console.log('执行页面跳转到:', shouldJumpToPage);
                            if (typeof QQ_Nav === 'function') {
                                if (shouldJumpToPage === 'messages') {
                                    QQ_Nav('message');
                                } else {
                                    QQ_Nav('people');
                                }
                                console.log('跳转完成');
                            } else {
                                console.warn('QQ_Nav函数不可用，手动显示联系人页面');
                                // 手动显示联系人页面
                                $('.QQ_chat_page').hide();
                                $('.group-chat-page').hide();
                                $('#QQ_home_page').show();
                                $('.QQ_bottom_nav').show();
                            }
                            
                            console.log('群聊删除完成:', deletedGroupName);
                            
                            // *** 修复：先删除世界书数据和更新内存，但不立即重新渲染界面 ***
                            console.log('删除界面元素和重新加载群聊数据');
                            
                            // 删除特定的群聊元素
                            safeRemoveGroupFromInterface(deletedGroupId, deletedGroupName);
                            
                            // 重新加载群聊数据
                            console.log('重新加载群聊数据');
                            await loadGroupChatsFromWorldbook();
                            
                            // 更新消息列表
                            console.log('更新消息列表');
                            await QQ_UpdateMessageList();
                            
                            console.log('群聊删除数据更新完成');
                            
                            // 先显示确认消息
                            alert('群聊已删除');
                            
                            // *** 关键修复：用户点击确认后，确保QQ_Groups基于最新数据，然后重新渲染 ***
                            console.log('用户确认删除完成，现在确保QQ_Groups数据最新并重新渲染联系人界面');
                            
                            // 关键步骤：清空QQ_Groups并基于最新的世界书数据重建
                            console.log('删除前QQ_Groups:', QQ_Groups.length, '个群聊');
                            QQ_Groups.length = 0; // 清空数组
                            
                            // 重新从最新的世界书数据构建QQ_Groups（不包含已删除的群聊）
                            if (entries) {
                                const remainingGroupEntries = entries.filter(e => e.comment && e.comment.startsWith("手机-群聊-"));
                                remainingGroupEntries.forEach(entry => {
                                    const groupName = entry.comment.replace('手机-群聊-', '');
                                    if (groupName && !QQ_Groups.includes(groupName)) {
                                        QQ_Groups.push(groupName);
                                    }
                                });
                                console.log('删除后QQ_Groups:', QQ_Groups.length, '个群聊');
                            }
                            
                            // *** 确保QQ_Groups重建完成后才开始重新渲染 ***
                            console.log('🎯 QQ_Groups数据重建完成，开始重新渲染联系人界面');
                            if (typeof renderContactGroups === 'function') {
                                await renderContactGroups();
                                console.log('✅ 联系人界面重新渲染完成，群聊已从界面消失');
                            } else {
                                console.error('❌ renderContactGroups函数不可用');
                            }
                            
                        } catch (error) {
                            console.error('删除群聊时出错:', error);
                            alert('删除群聊时出现问题，请刷新页面');
                            
                            // 出错时确保界面恢复正常
                            console.log('出错后恢复界面显示');
                            
                            // 清除群聊状态
                            if (wasInGroupChat) {
                                window.currentGroupChat = null;
                                window.groupChatSourcePage = null;
                            }
                            
                            // 强制显示联系人页面
                            $('.QQ_chat_page').hide();
                            $('.group-chat-page').hide();
                            $('#QQ_home_page').show();
                            $('.QQ_bottom_nav').show();
                            
                            // 尝试通过QQ_Nav恢复正常状态
                            if (typeof QQ_Nav === 'function') {
                                QQ_Nav('people');
                            }
                        }
                        
                        currentManagingGroup = null;
                    }, 100); // 缩短等待时间
                }
            }
            
            /**
             * 更新所有列表中的群聊信息（增强版：包含头像更新）
             */
            async function updateGroupInAllListsWithAvatar(groupData) {
                console.log('更新所有列表中的群聊信息，包括头像:', groupData);
                
                // 更新联系人列表
                const contactsContainer = document.getElementById('QQ_home_chars');
                if (contactsContainer) {
                    const existingGroup = contactsContainer.querySelector(`[data-group-id="${groupData.id}"]`);
                    if (existingGroup) {
                        const nameElement = existingGroup.querySelector('.QQ_home_name');
                        const avatarElement = existingGroup.querySelector('.QQ_home_head');
                        
                        if (nameElement) {
                            nameElement.textContent = groupData.name;
                        }
                        
                        // 更新头像
                        if (avatarElement && groupData.avatar) {
                            updateAvatarElement(avatarElement, groupData.avatar);
                        }
                    }
                }
                
                // 更新消息列表
                const messagesContainer = document.getElementById('QQ_message_list_chars');
                if (messagesContainer) {
                    const existingGroup = messagesContainer.querySelector(`[data-group-id="${groupData.id}"]`);
                    if (existingGroup) {
                        const nameElement = existingGroup.querySelector('.QQ_home_name');
                        const avatarElement = existingGroup.querySelector('.QQ_home_head');
                        
                        if (nameElement) {
                            nameElement.textContent = groupData.name;
                        }
                        
                        // 更新头像
                        if (avatarElement && groupData.avatar) {
                            updateAvatarElement(avatarElement, groupData.avatar);
                        }
                    }
                }
            }
            
            /**
             * 更新所有列表中的群聊信息（原版：仅名称）
             */
            function updateGroupInAllLists(groupData) {
                // 更新联系人列表
                const contactsContainer = document.getElementById('QQ_home_chars');
                if (contactsContainer) {
                    const existingGroup = contactsContainer.querySelector(`[data-group-id="${groupData.id}"]`);
                    if (existingGroup) {
                        const nameElement = existingGroup.querySelector('.QQ_home_name');
                        if (nameElement) {
                            nameElement.textContent = groupData.name;
                        }
                    }
                }
                
                // 更新消息列表
                const messagesContainer = document.getElementById('QQ_message_list_chars');
                if (messagesContainer) {
                    const existingGroup = messagesContainer.querySelector(`[data-group-id="${groupData.id}"]`);
                    if (existingGroup) {
                        const nameElement = existingGroup.querySelector('.QQ_home_name');
                        if (nameElement) {
                            nameElement.textContent = groupData.name;
                        }
                    }
                }
            }
            
            /**
             * 群聊设置更新后轻量级界面更新（不重新加载，避免消息丢失）
             */
            async function autoReloadInterfaceAfterGroupUpdate(updatedGroupData) {
                console.log('=== 开始轻量级界面更新（避免消息丢失） ===');
                console.log('更新的群聊数据:', updatedGroupData);
                
                try {
                    // *** 重要：不重新从世界书加载，而是直接更新现有数据 ***
                    
                    // 1. 更新全局群聊数据（保持消息不变）
                    if (window.QQ_Groups && Array.isArray(window.QQ_Groups)) {
                        const groupIndex = window.QQ_Groups.findIndex(g => g.id === updatedGroupData.id);
                        if (groupIndex !== -1) {
                            // 只更新名称和头像，保持其他数据不变
                            window.QQ_Groups[groupIndex].name = updatedGroupData.name;
                            window.QQ_Groups[groupIndex].avatar = updatedGroupData.avatar;
                            window.QQ_Groups[groupIndex].avatarUrl = updatedGroupData.avatarUrl;
                            console.log('已轻量更新全局群聊数据');
                        }
                    }
                    
                    // 2. 如果当前在群聊界面，只更新头部显示，不重新加载消息
                    if (window.currentGroupChat && window.currentGroupChat.id === updatedGroupData.id) {
                        console.log('轻量更新当前群聊界面头部...');
                        
                        // 更新当前群聊对象（保持消息数据不变）
                        window.currentGroupChat.name = updatedGroupData.name;
                        window.currentGroupChat.avatar = updatedGroupData.avatar;
                        window.currentGroupChat.avatarUrl = updatedGroupData.avatarUrl;
                        
                        // 只更新聊天头部，不重新加载消息历史
                        updateChatHeader(updatedGroupData);
                        
                        console.log('聊天界面头部已轻量更新，消息历史保持不变');
                    }
                    
                        // 3. 轻量更新群聊列表显示
    console.log('轻量更新群聊列表显示...');
    await protectedContactListUpdate(updatedGroupData, 'group_update');
                    
                    console.log('=== 轻量级界面更新完成，消息数据保持完整 ===');
                    
                } catch (error) {
                    console.error('轻量级界面更新时出错:', error);
                    // 不显示警告框，避免打断用户操作
                    console.warn('界面更新时出现问题，但群聊设置已保存，消息数据完整');
                }
            }
            
            /**
             * 刷新群聊显示（修复版：防止重复群聊，正确应用头像）
             */
            async function refreshGroupChatsDisplay() {
                console.log('刷新群聊显示（修复版）...');
                
                try {
                    // 不要重新从世界书加载，直接使用当前的QQ_Groups数据
                    // 清理和重新显示现有的群聊元素
                    await updateExistingGroupElements();
                    
                    console.log('群聊显示刷新完成');
                    
                } catch (error) {
                    console.error('刷新群聊显示时出错:', error);
                    alert('界面更新时出现问题，建议手动刷新页面。');
                }
            }
            
            /**
             * 更新现有群聊元素而不重新创建
             */
            async function updateExistingGroupElements() {
                console.log('更新现有群聊元素...');
                
                try {
                    // *** 关键修复：使用当前内存中的QQ_Groups数据，不重新加载 ***
                    const latestGroups = window.QQ_Groups || [];
                    console.log('updateExistingGroupElements: 使用的群聊数据:', latestGroups.length, '个群聊');
                    console.log('使用当前内存中的群聊数据:', latestGroups.length, '个');
                    
                    if (latestGroups.length === 0) {
                        console.warn('内存中没有群聊数据，跳过更新');
                        return;
                    }
                    
                    const contactsContainer = document.getElementById('QQ_home_chars');
                    const messagesContainer = document.getElementById('QQ_message_list_chars');
                    
                    // 更新联系人列表中的群聊
                    if (contactsContainer && latestGroups) {
                        for (const groupData of latestGroups) {
                            if (groupData && groupData.name) {
                                const existingElement = contactsContainer.querySelector(`[data-group-id="${groupData.id}"]`);
                                if (existingElement) {
                                    console.log('更新现有群聊元素:', groupData.name);
                                    updateGroupElement(existingElement, groupData);
                                } else {
                                    console.log('群聊元素不存在，保持现状:', groupData.name);
                                }
                            }
                        }
                    }
                    
                    // 更新消息列表中的群聊
                    if (messagesContainer && latestGroups) {
                        console.log('=== 开始更新消息列表中的群聊 ===');
                        console.log('消息容器存在:', !!messagesContainer);
                        console.log('群聊数据:', latestGroups.map(g => ({ name: g.name, id: g.id })));
                        
                        // 先检查消息列表中现有的群聊元素
                        const existingElements = messagesContainer.querySelectorAll('[data-group-id]');
                        console.log('消息列表中现有的群聊元素:', Array.from(existingElements).map(el => ({
                            name: el.querySelector('.QQ_home_name')?.textContent,
                            dataGroupId: el.getAttribute('data-group-id')
                        })));
                        
                        for (const groupData of latestGroups) {
                            if (groupData && groupData.name) {
                                console.log(`\n--- 处理群聊: ${groupData.name} (ID: ${groupData.id}) ---`);
                                
                                const existingElement = messagesContainer.querySelector(`[data-group-id="${groupData.id}"]`);
                                console.log('根据data-group-id查找到的元素:', !!existingElement);
                                
                                if (!existingElement) {
                                    // 尝试用其他方式查找，比如名称匹配
                                    const nameElements = messagesContainer.querySelectorAll('.QQ_home_name');
                                    let foundByName = null;
                                    for (const nameEl of nameElements) {
                                        if (nameEl.textContent.trim() === groupData.name) {
                                            foundByName = nameEl.closest('[data-group-id]');
                                            break;
                                        }
                                    }
                                    
                                    if (foundByName) {
                                        console.log('通过名称匹配找到群聊元素，更新data-group-id');
                                        foundByName.setAttribute('data-group-id', groupData.id);
                                        updateGroupElement(foundByName, groupData);
                                    } else {
                                        console.warn(`❌ 群聊 "${groupData.name}" 在消息列表中完全找不到，可能已被删除或隐藏`);
                                        
                                                                // 特殊检查'港区'群聊
                        if (groupData.name === '港区') {
                            console.error('🚨 特别关注：港区群聊在消息列表中找不到！');
                            console.log('港区群聊完整数据:', JSON.stringify(groupData, null, 2));
                            console.log('所有现有元素的详细信息:');
                            existingElements.forEach(el => {
                                console.log('元素:', {
                                    innerHTML: el.innerHTML.substring(0, 200),
                                    dataGroupId: el.getAttribute('data-group-id'),
                                    nameText: el.querySelector('.QQ_home_name')?.textContent
                                });
                            });
                            
                            // *** 港区群聊紧急恢复机制 ***
                            console.log('启动港区群聊紧急恢复机制...');
                            const messagesContainer = document.querySelector('#QQ_messages_list');
                            if (messagesContainer) {
                                // 检查是否有港区群聊的残留元素（没有正确的data-group-id）
                                const allGroupElements = messagesContainer.querySelectorAll('.QQ_home_lxr');
                                console.log('找到的所有群聊元素:', allGroupElements.length);
                                
                                for (const element of allGroupElements) {
                                    const nameEl = element.querySelector('.QQ_home_name');
                                    if (nameEl && nameEl.textContent.trim() === '港区') {
                                        console.log('🔧 找到港区群聊元素，修复其data-group-id');
                                        element.setAttribute('data-group-id', groupData.id || 'group_gangqu');
                                        updateGroupElement(element, groupData);
                                        console.log('✅ 港区群聊已修复');
                                        return; // 修复完成，退出
                                    }
                                }
                                
                                // 如果没有找到，尝试重新添加港区群聊
                                console.log('🆘 港区群聊完全丢失，尝试重新创建...');
                                const groupElement = createGroupElementForDisplay({
                                    ...groupData,
                                    id: groupData.id || 'group_gangqu',
                                    name: '港区'
                                });
                                
                                if (groupElement) {
                                    messagesContainer.insertBefore(groupElement, messagesContainer.firstChild);
                                    console.log('✅ 港区群聊已重新创建并添加到列表顶部');
                                }
                            }
                        }
                                    }
                                } else {
                                    console.log('✅ 找到群聊元素，正在更新:', groupData.name);
                                    updateGroupElement(existingElement, groupData);
                                }
                            }
                        }
                        
                        console.log('=== 消息列表群聊更新完成 ===');
                    }
                } catch (error) {
                    console.error('更新现有群聊元素时出错:', error);
                }
            }
            
            /**
             * 更新群聊元素的名称和头像（增强版：防止头像丢失）
             */
            function updateGroupElement(element, groupData) {
                try {
                    console.log('=== updateGroupElement 开始 ===');
                    console.log('群聊数据:', {
                        name: groupData.name,
                        id: groupData.id,
                        avatar: groupData.avatar,
                        avatarUrl: groupData.avatarUrl
                    });
                    
                    // 更新群聊名称
                    const nameElement = element.querySelector('.QQ_home_name');
                    if (nameElement) {
                        nameElement.textContent = groupData.name;
                    }
                    
                    // *** 关键修复：更强的头像数据检查和保护 ***
                    const avatarElement = element.querySelector('.QQ_home_head');
                    if (avatarElement) {
                        console.log('找到头像元素，检查头像数据...');
                        
                        // 优先级1：检查完整的avatar对象
                        if (groupData.avatar && typeof groupData.avatar === 'object' && groupData.avatar.type) {
                            console.log('发现完整的头像对象，应用头像:', groupData.avatar);
                            updateAvatarElement(avatarElement, groupData.avatar);
                        }
                        // 优先级2：检查avatarUrl字符串
                        else if (groupData.avatarUrl && typeof groupData.avatarUrl === 'string') {
                            console.log('发现avatarUrl，应用字符串头像:', groupData.avatarUrl);
                            updateAvatarElement(avatarElement, groupData.avatarUrl);
                        }
                        // 优先级3：检查avatar字符串
                        else if (groupData.avatar && typeof groupData.avatar === 'string') {
                            console.log('发现avatar字符串，应用头像:', groupData.avatar);
                            updateAvatarElement(avatarElement, groupData.avatar);
                        }
                        // 优先级4：从内存中的QQ_Groups查找完整数据
                        else if (window.QQ_Groups && groupData.id) {
                            console.log('头像数据不完整，从QQ_Groups中查找...');
                            const fullGroupData = window.QQ_Groups.find(g => g.id === groupData.id || g.name === groupData.name);
                            if (fullGroupData && fullGroupData.avatar) {
                                console.log('从QQ_Groups中找到完整头像数据:', fullGroupData.avatar);
                                updateAvatarElement(avatarElement, fullGroupData.avatar);
                            } else {
                                console.warn('从QQ_Groups中也未找到头像数据，保持现有头像');
                                // 不应用默认头像，保持现有头像不变
                            }
                        }
                                                 else {
                             console.warn('没有有效的头像数据，保持现有头像');
                             // 不应用默认头像，保持现有头像不变
                         }
                     } else {
                         console.warn('未找到头像元素');
                     }
                    
                    console.log('群聊元素更新完成:', groupData.name);
                } catch (error) {
                    console.error('更新群聊元素时出错:', error);
                }
            }
            
            /**
             * 添加系统消息到群聊（灰色小字）
             */
            async function addSystemMessageToGroup(groupId, systemMessage) {
                console.log('添加系统消息到群聊:', { groupId, systemMessage });
                
                try {
                    // 确保群聊消息数组存在
                    if (!window.groupChatMessages) {
                        window.groupChatMessages = {};
                    }
                    if (!window.groupChatMessages[groupId]) {
                        window.groupChatMessages[groupId] = [];
                    }
                    
                    // 创建系统消息对象
                    const systemMessageObj = {
                        id: 'system_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                        type: 'system',
                        content: systemMessage,
                        timestamp: new Date().toISOString(),
                        sender: 'system'
                    };
                    
                    // 添加到群聊消息数组
                    window.groupChatMessages[groupId].push(systemMessageObj);
                    
                    // 如果当前正在查看这个群聊，立即显示系统消息
                    if (window.currentGroupChat && window.currentGroupChat.id === groupId) {
                        displaySystemMessage(systemMessage, groupId);
                    }
                    
                    console.log('系统消息已添加到群聊');
                    
                } catch (error) {
                    console.error('添加系统消息时出错:', error);
                }
            }
            
            /**
             * 在聊天界面显示系统消息（灰色小字）- 修复版
             */
            function displaySystemMessage(message, targetGroupId = null) {
                try {
                    console.log('=== 尝试显示系统消息 ===');
                    console.log('消息内容:', message);
                    console.log('目标群聊ID:', targetGroupId);
                    console.log('当前群聊:', window.currentGroupChat);
                    
                    let msgContent = null;
                    
                    // *** 修复：更准确的消息容器查找策略 ***
                    const containerSelectors = [
                        '.QQ_chat_page[style*="display:block"] .msgcontent',
                        '.QQ_chat_page:not([style*="display:none"]) .msgcontent',
                        '.msgcontent:not([style*="display:none"])',
                        '.msgcontent',
                        '#QQ_chat_msgs'
                    ];
                    
                    // 按优先级查找可见的消息容器
                    for (const selector of containerSelectors) {
                        const elements = document.querySelectorAll(selector);
                        for (const element of elements) {
                            if (element && element.offsetParent !== null && 
                                element.offsetWidth > 0 && element.offsetHeight > 0) {
                                msgContent = element;
                                console.log('✅ 找到可见的消息容器，使用选择器:', selector);
                                break;
                            }
                        }
                        if (msgContent) break;
                    }
                    
                    // *** 修复：如果还是没找到，强制查找当前活跃的聊天页面 ***
                    if (!msgContent) {
                        console.log('尝试在当前活跃的聊天页面中查找消息容器...');
                        
                        // 查找当前显示的聊天页面
                        const activeChatPage = document.querySelector('.QQ_chat_page[style*="display:block"]') ||
                                              document.querySelector('.QQ_chat_page:not([style*="display:none"])');
                        
                        if (activeChatPage) {
                            console.log('找到活跃的聊天页面，创建临时消息容器');
                            
                            // 在活跃聊天页面中创建或查找消息容器
                            msgContent = activeChatPage.querySelector('.msgcontent');
                            if (!msgContent) {
                                msgContent = document.createElement('div');
                                msgContent.className = 'msgcontent';
                                msgContent.style.cssText = `
                                    flex: 1;
                                    overflow-y: auto;
                                    box-sizing: border-box;
                                    margin-bottom: 50px;
                                    padding-left: 8px;
                                    padding-right: 8px;
                                    scrollbar-width: none;
                                    -ms-overflow-style: none;
                                    height: calc(100% - 120px);
                                    position: relative;
                                `;
                                activeChatPage.appendChild(msgContent);
                            }
                        }
                    }
                    
                    if (!msgContent) {
                        console.error('无法找到任何消息容器来显示系统消息');
                        // 作为最后的兜底方案，直接在页面中显示
                        const fallbackMsg = document.createElement('div');
                        fallbackMsg.style.cssText = `
                            position: fixed;
                            top: 50%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                            background: rgba(0,0,0,0.8);
                            color: white;
                            padding: 10px 20px;
                            border-radius: 5px;
                            z-index: 999999;
                            font-size: 14px;
                        `;
                        fallbackMsg.textContent = message;
                        document.body.appendChild(fallbackMsg);
                        setTimeout(() => fallbackMsg.remove(), 3000);
                        return;
                    }
                    
                    console.log('准备添加系统消息到容器:', msgContent.tagName, msgContent.className || msgContent.id);
                    
                    // *** 修复：创建更可靠的系统消息元素 ***
                    const systemMsgDiv = document.createElement('div');
                    systemMsgDiv.className = 'system-message-chat';
                    systemMsgDiv.setAttribute('data-message-type', 'system');
                    systemMsgDiv.setAttribute('data-timestamp', Date.now());
                    
                    // *** 修复：使用更强制的样式，确保显示 ***
                    systemMsgDiv.style.cssText = `
                        text-align: center !important;
                        color: #999999 !important;
                        font-size: 12px !important;
                        margin: 10px auto !important;
                        padding: 5px 10px !important;
                        line-height: 1.4 !important;
                        background: transparent !important;
                        border: none !important;
                        max-width: 90% !important;
                        position: relative !important;
                        z-index: 10 !important;
                        word-wrap: break-word !important;
                        white-space: normal !important;
                        display: block !important;
                        clear: both !important;
                        font-weight: normal !important;
                        opacity: 1 !important;
                        visibility: visible !important;
                        box-sizing: border-box !important;
                        width: auto !important;
                        min-height: 20px !important;
                        font-family: inherit !important;
                    `;
                    systemMsgDiv.textContent = message;
                    
                    console.log('*** 系统消息元素已创建 ***:', {
                        message: message,
                        element: systemMsgDiv,
                        parent: msgContent.tagName,
                        parentVisible: msgContent.offsetParent !== null
                    });
                    
                    // *** 修复：立即添加并强制显示 ***
                    msgContent.appendChild(systemMsgDiv);
                    
                    // 强制刷新布局
                    systemMsgDiv.offsetHeight;
                    
                    // 立即滚动到底部
                    setTimeout(() => {
                        msgContent.scrollTop = msgContent.scrollHeight;
                        console.log('系统消息已显示，容器高度:', msgContent.scrollHeight);
                    }, 50);
                    
                    // *** 修复：添加验证检查 ***
                    setTimeout(() => {
                        if (document.contains(systemMsgDiv)) {
                            const computedStyle = window.getComputedStyle(systemMsgDiv);
                            console.log('✅ 系统消息显示成功:', {
                                inDOM: true,
                                visible: systemMsgDiv.offsetParent !== null,
                                display: computedStyle.display,
                                visibility: computedStyle.visibility,
                                opacity: computedStyle.opacity,
                                height: systemMsgDiv.offsetHeight
                            });
                        } else {
                            console.error('❌ 系统消息未能添加到DOM中');
                        }
                    }, 200);
                    
                } catch (error) {
                    console.error('显示系统消息时出错:', error);
                    console.error('错误详情:', error.stack);
                }
            }
            

            
            /**
             * 为群聊变更添加系统消息
             */
            async function addSystemMessagesForChanges(groupId, changes) {
                if (!changes || changes.length === 0) {
                    return;
                }
                
                console.log('为群聊变更添加系统消息:', { groupId, changes });
                
                for (const change of changes) {
                    let systemMessage = '';
                    
                    switch (change.type) {
                        case 'name':
                            systemMessage = `群聊名称已更改为"${change.newValue}"`;
                            break;
                        case 'avatar':
                            systemMessage = `群主已更改群头像`;
                            break;
                        case 'add_member':
                            systemMessage = `${change.operator}邀请${change.newValue}加入群聊`;
                            break;
                        case 'remove_member':
                            systemMessage = `${change.operator}将${change.oldValue}移出群聊`;
                            break;
                        default:
                            systemMessage = `群聊设置已更新`;
                            break;
                    }
                    
                    if (systemMessage) {
                        await addSystemMessageToGroup(groupId, systemMessage);
                    }
                }
            }
            
            /**
             * 更新群聊消息JSON中的群聊信息（保持聊天记录）
             */
            async function updateGroupChatMessagesInMsgjson(groupId, oldName, newName) {
                console.log('更新消息JSON中的群聊信息:', { groupId, oldName, newName });
                
                try {
                    // 更新群聊消息记录中的群聊名称
                    if (window.groupChatMessages && window.groupChatMessages[groupId]) {
                        const messages = window.groupChatMessages[groupId];
                        console.log(`群聊 ${groupId} 有 ${messages.length} 条消息需要更新`);
                        
                        // 这里可以更新消息中的群聊相关信息，但保持消息内容不变
                        // 目前主要是确保groupId和消息记录的关联保持正确
                    }
                    
                    // 更新msgjson中的群聊相关信息
                    if (window.msgjson && window.msgjson.data) {
                        // 遍历所有用户的消息，更新涉及该群聊的消息
                        Object.keys(window.msgjson.data).forEach(userId => {
                            const userMessages = window.msgjson.data[userId];
                            if (Array.isArray(userMessages)) {
                                userMessages.forEach(message => {
                                    // 如果消息中提到了旧的群聊名称，可以选择性更新
                                    // 但要保持消息内容的完整性
                                    if (message.mes && typeof message.mes === 'string' && message.mes.includes(oldName)) {
                                        console.log(`在用户 ${userId} 的消息中发现群聊引用，保持不变`);
                                        // 这里可以选择是否更新消息中的群聊名称引用
                                        // 为了安全起见，暂时保持消息内容不变
                                    }
                                });
                            }
                        });
                    }
                    
                    console.log('群聊消息信息更新完成');
                } catch (error) {
                    console.error('更新群聊消息信息时出错:', error);
                }
            }
            
            /**
             * 重新应用群聊背景（使用原有的getRandomChatBackground逻辑）
             */
            function reapplyGroupChatBackground(groupData) {
                console.log('*** 重新应用群聊背景 ***');
                console.log('群聊数据:', groupData);
                
                try {
                    if (!groupData || !groupData.name) {
                        console.warn('群聊数据无效，跳过背景应用');
                        return;
                    }
                    
                    // 获取随机聊天背景（使用原有逻辑）
                    const randomBackground = getRandomChatBackground();
                    console.log('获取到的随机背景:', randomBackground);
                    
                    if (!randomBackground) {
                        console.warn('未获取到有效背景，跳过应用');
                        return;
                    }
                    
                    // 查找或创建群聊的CSS样式（模仿AddNewGroup的逻辑）
                    const groupName = groupData.name;
                    
                    // 移除旧的背景样式（如果存在）
                    $(`style[data-group-bg="${groupName}"]`).remove();
                    
                    // 创建新的背景CSS样式（包含完整的背景属性）
                    const backgroundCSS = `
.QQ_chat_page[data-name='${groupName}'] {
    --BackGroundImg: url('${randomBackground}');
    background-image: var(--BackGroundImg) !important;
    background-size: cover !important;
    background-position: center !important;
    background-repeat: no-repeat !important;
    background-color: transparent !important;
}`;
                    
                    // 创建新的style元素并添加到页面
                    const style = $("<style></style>").prop("type", "text/css");
                    style.attr('data-group-bg', groupName);
                    style.text(backgroundCSS);
                    $("head").append(style);
                    
                    console.log(`群聊 ${groupName} 的背景CSS已重新应用:`, randomBackground);
                    
                    // 延迟验证背景是否正确应用（更宽松的验证）
                    setTimeout(() => {
                        const chatPage = document.querySelector(`.QQ_chat_page[data-name="${groupName}"]`);
                        if (chatPage) {
                            const finalBg = window.getComputedStyle(chatPage).backgroundImage;
                            console.log('背景应用验证 - 最终背景:', finalBg);
                            
                            // 更宽松的验证：只要不是'none'就认为成功
                            if (finalBg === 'none') {
                                console.warn('背景应用失败：最终背景为none');
                            } else if (finalBg.includes('url(')) {
                                console.log('*** 群聊背景重新应用成功 ***');
                                console.log('验证通过：检测到背景图片URL');
                            } else {
                                // 即使URL不完全匹配，只要有背景就算成功
                                console.log('*** 群聊背景重新应用成功 ***'); 
                                console.log('验证通过：检测到背景样式（可能为CSS变量展开后的值）');
                            }
                        }
                    }, 200);
                    
                } catch (error) {
                    console.error('重新应用群聊背景时出错:', error);
                }
            }
            
            /**
             * 群聊改名时的完整数据迁移（修复绑定关系）
             */
            async function migrateGroupDataBindings(oldName, newName, groupData) {
                console.log('*** 开始群聊改名数据迁移 ***');
                console.log(`迁移: "${oldName}" -> "${newName}"`);
                
                try {
                    let migratedCount = 0;
                    
                    // *** 1. 迁移壁纸绑定数据（如果存在以群聊名称为key的绑定）***
                    if (window.wallpaperurl) {
                        // 检查是否有以旧群聊名称为key的壁纸设置
                        if (window.wallpaperurl[oldName]) {
                            console.log(`发现以群聊名称为key的壁纸设置: ${oldName}`);
                            window.wallpaperurl[newName] = window.wallpaperurl[oldName];
                            delete window.wallpaperurl[oldName];
                            console.log(`壁纸绑定已迁移: ${oldName} -> ${newName}`);
                            migratedCount++;
                        }
                        
                        // 确保群聊成员的壁纸绑定完整
                    if (groupData.members && groupData.members.length > 0) {
                        const firstMember = groupData.members[0];
                            if (window.wallpaperurl[firstMember]) {
                                console.log(`确认成员壁纸绑定存在: ${firstMember} -> ${window.wallpaperurl[firstMember]}`);
                            } else {
                                // 如果成员没有壁纸设置，使用默认的群聊壁纸
                                window.wallpaperurl[firstMember] = 'https://files.catbox.moe/9fdwty.jpg';
                                console.log(`为成员设置默认群聊壁纸: ${firstMember}`);
                                migratedCount++;
                            }
                        }
                    }
                    
                    // *** 2. 确保全局QQ_Groups数组正确更新 ***
                    console.log('检查和更新全局QQ_Groups数组...');
                    
                    // 确保QQ_Groups数组存在
                    if (!window.QQ_Groups) {
                        console.warn('QQ_Groups数组不存在，重新初始化');
                        window.QQ_Groups = [];
                    }
                    
                    // 查找并更新QQ_Groups中的群聊数据
                    const groupIndex = window.QQ_Groups.findIndex(g => 
                        g && (g.id === groupData.id || g.name === oldName || g.name === newName)
                    );
                    
                    if (groupIndex > -1) {
                        console.log(`更新QQ_Groups数组中的群聊 [${groupIndex}]:`, oldName, '->', newName);
                        console.log(`头像数据迁移: ${groupData.avatar ? JSON.stringify(groupData.avatar) : 'null'}`);
                        window.QQ_Groups[groupIndex] = {
                            ...window.QQ_Groups[groupIndex],
                            name: groupData.name,
                            id: groupData.id,
                            avatar: groupData.avatar,
                            avatarUrl: groupData.avatarUrl,
                            members: groupData.members
                        };
                        console.log('QQ_Groups数组中的头像已更新:', window.QQ_Groups[groupIndex].avatar);
                        migratedCount++;
                    } else {
                        // 如果在QQ_Groups中找不到，确保群聊数据存在
                        console.log('在QQ_Groups中未找到群聊，添加新数据');
                        console.log('新数据头像:', groupData.avatar);
                        window.QQ_Groups.push(groupData);
                        migratedCount++;
                    }
                    
                    console.log('QQ_Groups数组更新完成，当前数量:', window.QQ_Groups.length);
                    console.log('QQ_Groups数组内容:', window.QQ_Groups.map(g => ({ name: g.name, id: g.id })));
                    
                    // *** 3. 迁移其他可能的名称绑定数据 ***
                    
                    // 迁移localStorage中可能的群聊相关数据
                    try {
                        const storageKeys = Object.keys(localStorage);
                        for (const key of storageKeys) {
                            if (key.includes(oldName)) {
                                const value = localStorage.getItem(key);
                                const newKey = key.replace(oldName, newName);
                                localStorage.setItem(newKey, value);
                                localStorage.removeItem(key);
                                console.log(`localStorage数据迁移: ${key} -> ${newKey}`);
                                migratedCount++;
                            }
                        }
                    } catch (storageError) {
                        console.warn('localStorage数据迁移时出错:', storageError);
                    }
                    
                    // *** 3. 迁移window全局对象中的群聊相关数据 ***
                    if (window.groups && Array.isArray(window.groups)) {
                        const groupIndex = window.groups.findIndex(g => g && g.name === oldName || g.name === newName);
                        if (groupIndex !== -1) {
                            window.groups[groupIndex].name = newName;
                            console.log(`window.groups数据已更新`);
                            migratedCount++;
                        }
                    }
                    
                    // *** 4. 确保CSS类名和样式的数据绑定 ***
                    // 更新所有可能包含旧名称的data属性
                    const elementsWithOldName = document.querySelectorAll(`[data-name="${oldName}"]`);
                    elementsWithOldName.forEach(el => {
                        el.setAttribute('data-name', newName);
                        console.log('已更新元素data-name属性');
                        migratedCount++;
                    });
                    
                    // *** 5. 迁移可能的聊天历史绑定 ***
                    if (window.groupChats && window.groupChats[oldName]) {
                        window.groupChats[newName] = window.groupChats[oldName];
                        delete window.groupChats[oldName];
                        console.log(`群聊历史数据已迁移: ${oldName} -> ${newName}`);
                        migratedCount++;
                    }
                    
                    console.log(`*** 数据迁移完成，共迁移 ${migratedCount} 项数据绑定 ***`);
                    
                    // *** 6. 立即更新当前聊天页面（如果正在聊天中） ***
                    console.log('检查是否需要更新当前聊天页面...');
                    
                    // 查找当前显示的聊天页面
                    const currentChatPage = document.querySelector('.QQ_chat_page:not([style*="display: none"]):not([style*="display:none"])');
                    if (currentChatPage) {
                        console.log('找到当前聊天页面，检查是否为目标群聊...');
                        
                        // 检查是否为当前群聊的聊天页面
                        const pageGroupId = currentChatPage.getAttribute('data-group-id');
                        const pageDataName = currentChatPage.getAttribute('data-name');
                        
                        console.log('聊天页面数据:', {
                            pageGroupId,
                            pageDataName,
                            targetGroupId: groupData.id,
                            oldName,
                            newName
                        });
                        
                        // 判断是否为目标群聊页面（通过ID或名称匹配）
                        const isTargetChatPage = (pageGroupId === groupData.id) || 
                                                (pageDataName === oldName) || 
                                                (pageDataName === newName);
                        
                        if (isTargetChatPage) {
                            console.log('*** 当前聊天页面是目标群聊，立即更新！***');
                            
                            // *** 核心修复1：立即更新聊天页面的数据属性 ***
                            currentChatPage.setAttribute('data-group-id', groupData.id);
                            currentChatPage.setAttribute('data-name', groupData.name);
                            console.log('已更新聊天页面的data-group-id和data-name');
                            
                            // *** 核心修复2：立即更新window.currentGroupChat ***
                            if (window.currentGroupChat && 
                                (window.currentGroupChat.id === groupData.id || 
                                 window.currentGroupChat.name === oldName)) {
                                console.log('更新window.currentGroupChat数据...');
                                window.currentGroupChat.name = groupData.name;
                                window.currentGroupChat.avatar = groupData.avatar;
                                window.currentGroupChat.avatarUrl = groupData.avatarUrl;
                                window.currentGroupChat.members = groupData.members;
                                console.log('window.currentGroupChat已更新:', window.currentGroupChat);
                            }
                            
                            // *** 核心修复3：立即更新聊天页面头部（多重策略） ***
                            console.log('开始立即更新聊天页面标题...');
                            
                            // 策略1：直接更新聊天用户名元素
                            const chatUsernameElement = currentChatPage.querySelector('#QQ_chat_username');
                            if (chatUsernameElement) {
                                console.log('找到聊天用户名元素，立即更新...');
                                const displayName = groupData.members && groupData.members.length > 1 
                                    ? `${groupData.name} (${groupData.members.length}人)` 
                                    : groupData.name;
                                chatUsernameElement.textContent = displayName;
                                chatUsernameElement.setAttribute('data-group-name', groupData.name);
                                chatUsernameElement.setAttribute('data-group-id', groupData.id);
                                console.log(`聊天标题已立即更新为: ${displayName}`);
                            } else {
                                console.warn('未找到#QQ_chat_username元素');
                            }
                            
                            // 策略2：查找并更新完整的聊天头部
                            const chatHeader = currentChatPage.querySelector('.QQ_chat_header') || 
                                             currentChatPage.querySelector('.QQ_home') ||
                                             currentChatPage.querySelector('[class*="header"]');
                            
                            if (chatHeader) {
                                console.log('找到聊天头部，完整更新...');
                                updateHeaderContent(chatHeader, groupData);
                                console.log('聊天头部完整更新完成');
                            } else {
                                console.warn('未找到聊天头部元素');
                                console.log('聊天页面结构:', currentChatPage.outerHTML.substring(0, 500));
                            }
                            
                            // *** 策略3：强制DOM刷新后再次更新（确保显示更新） ***
                        setTimeout(() => {
                                console.log('延迟强制更新聊天标题...');
                                
                                // 再次查找并更新用户名元素
                                const delayedUsernameElement = currentChatPage.querySelector('#QQ_chat_username');
                                if (delayedUsernameElement) {
                                    const delayedDisplayName = groupData.members && groupData.members.length > 1 
                                        ? `${groupData.name} (${groupData.members.length}人)` 
                                        : groupData.name;
                                    delayedUsernameElement.textContent = delayedDisplayName;
                                    console.log(`延迟更新标题成功: ${delayedDisplayName}`);
                                }
                                
                                // 再次更新头部
                                const delayedChatHeader = currentChatPage.querySelector('.QQ_chat_header') || 
                                                         currentChatPage.querySelector('.QQ_home') ||
                                                         currentChatPage.querySelector('[class*="header"]');
                                if (delayedChatHeader) {
                                    updateHeaderContent(delayedChatHeader, groupData);
                                    console.log('延迟头部更新完成');
                                }
                                
                            }, 50);
                            
                                                         // *** 核心修复4：重新应用群聊背景（立即执行） ***
                             reapplyGroupChatBackground(groupData);
                            
                            console.log('*** 当前聊天页面实时更新完成 ***');
                        } else {
                            console.log('当前聊天页面不是目标群聊，跳过实时更新');
                        }
                    } else {
                        console.log('当前没有打开的聊天页面');
                    }
                    
                    // *** 7. 延迟刷新其他组件以应用新的绑定关系 ***
                    setTimeout(() => {
                        console.log('延迟刷新其他组件...');
                        
                        // 触发界面重新渲染事件
                        const event = new CustomEvent('groupDataMigrated', {
                            detail: { oldName, newName, groupData }
                        });
                        window.dispatchEvent(event);
                        
                                                 // 再次确保壁纸正确
                         reapplyGroupChatBackground(groupData);
                        
                    }, 100);
                    
                    return migratedCount;
                    
                } catch (error) {
                    console.error('群聊数据迁移时出错:', error);
                    return 0;
                }
            }
            
            /**
             * 保护性联系人列表更新（防止格式破坏）
             */
            async function protectedContactListUpdate(groupData, operation = 'group_update') {
                console.log('*** 开始保护性联系人列表更新 ***');
                console.log('群聊数据:', groupData);
                console.log('操作类型:', operation);
                
                try {
                    const contactsContainer = document.getElementById('QQ_home_chars');
                    if (!contactsContainer) {
                        console.warn('联系人容器未找到');
                        return;
                    }
                    
                    // *** 关键策略：极度保守的更新方式 ***
                    
                    // 1. 精确查找目标群聊元素（使用多种方法确保精确匹配）
                    let targetElements = [];
                    
                    // 方法1：使用data-group-id查找
                    if (groupData.id) {
                        const byGroupId = contactsContainer.querySelectorAll(`[data-group-id="${groupData.id}"]`);
                        targetElements.push(...byGroupId);
                        console.log(`方法1(data-group-id)找到 ${byGroupId.length} 个元素`);
                    }
                    
                    // 方法2：如果operation包含旧名称信息，使用它查找
                    if (operation && operation !== 'group_update' && targetElements.length === 0) {
                        const byOldName = contactsContainer.querySelectorAll(`[data-name="${operation}"]`);
                        targetElements.push(...byOldName);
                        console.log(`方法2(data-name操作参数)找到 ${byOldName.length} 个元素`);
                    }
                    
                    // 方法3：使用新名称的data-name查找
                    if (groupData.name && targetElements.length === 0) {
                        const byNewName = contactsContainer.querySelectorAll(`[data-name="${groupData.name}"]`);
                        targetElements.push(...byNewName);
                        console.log(`方法3(data-name新名称)找到 ${byNewName.length} 个元素`);
                    }
                    
                    // 去重
                    targetElements = [...new Set(targetElements)];
                    console.log(`总共找到 ${targetElements.length} 个目标元素需要更新`);
                    
                    if (targetElements.length === 0) {
                        console.warn('未找到需要更新的联系人元素，跳过更新');
                        return;
                    }
                    
                    // 2. 对每个目标元素进行安全更新
                    let successCount = 0;
                    let errorCount = 0;
                    
                    targetElements.forEach((element, index) => {
                        try {
                            console.log(`更新目标元素 ${index + 1}/${targetElements.length}`);
                            
                            // *** 极度安全的更新策略：只更新确保存在的元素 ***
                            
                            // 验证这是一个有效的联系人元素
                            if (!element.classList.contains('QQ_home_usermsg')) {
                                console.warn(`元素${index + 1}不是有效的联系人元素，跳过`);
                                return;
                            }
                            
                            // 只更新数据属性（最安全）
                            element.setAttribute('data-group-id', groupData.id);
                            element.setAttribute('data-name', groupData.name);
                            
                            // 只有在找到名称元素时才更新文本
                            const nameElement = element.querySelector('.QQ_home_name');
                            if (nameElement && nameElement.textContent.trim() !== groupData.name) {
                                const oldText = nameElement.textContent.trim();
                                nameElement.textContent = groupData.name;
                                console.log(`元素${index + 1}名称更新: "${oldText}" -> "${groupData.name}"`);
                            }
                            
                            // *** 重要修复：更新头像（如果有头像数据） ***
                            const avatarElement = element.querySelector('.QQ_home_head');
                            if (avatarElement && groupData.avatar) {
                                console.log(`更新元素${index + 1}的头像`);
                                try {
                                    // 保存原有的类名，避免破坏样式
                                    const originalClasses = avatarElement.className;
                                    const originalId = avatarElement.id;
                                    
                                    // 更新头像
                                    updateAvatarElement(avatarElement, groupData.avatar);
                                    
                                    // 确保原有类名没有被破坏
                                    if (originalClasses && !avatarElement.className.includes('QQ_home_head')) {
                                        avatarElement.className = originalClasses;
                                    }
                                    if (originalId) {
                                        avatarElement.id = originalId;
                                    }
                                    
                                    console.log(`元素${index + 1}头像更新成功`);
                                } catch (avatarError) {
                                    console.error(`更新元素${index + 1}头像时出错:`, avatarError);
                                }
                            } else if (!avatarElement) {
                                console.log(`元素${index + 1}没有找到头像元素`);
                            } else if (!groupData.avatar) {
                                console.log(`元素${index + 1}没有头像数据`);
                            }
                            
                            // 保护现有格式，不更新其他DOM结构
                            
                            successCount++;
                            console.log(`元素${index + 1}更新成功`);
                            
                        } catch (elementError) {
                            console.error(`更新元素${index + 1}时出错:`, elementError);
                            errorCount++;
                        }
                    });
                    
                    console.log(`*** 保护性联系人更新完成: 成功${successCount}个, 错误${errorCount}个 ***`);
                    
                    // 3. 验证更新结果
                    setTimeout(() => {
                        console.log('=== 联系人更新结果验证 ===');
                        const updatedElements = contactsContainer.querySelectorAll(`[data-name="${groupData.name}"]`);
                        console.log(`验证：现在有 ${updatedElements.length} 个元素使用新名称`);
                        
                        updatedElements.forEach((el, i) => {
                            const nameEl = el.querySelector('.QQ_home_name');
                            if (nameEl) {
                                console.log(`验证元素${i + 1}: "${nameEl.textContent.trim()}"`);
                            }
                        });
                    }, 500);
                    
                } catch (error) {
                    console.error('保护性联系人列表更新时出错:', error);
                }
            }
            
            // [已删除] updateChatPageBackground - 功能已由reapplyGroupChatBackground替代
            
            // [已删除] ensureContactListFormat - 功能已由protectedContactListUpdate替代
            
            // [已删除] immediateUpdateGroupInAllLists - 功能已由protectedContactListUpdate替代
            
            /**
             * 安全更新群聊元素（保护原有格式版）
             */
            function safeUpdateGroupElement(element, groupData) {
                try {
                    if (!element || !groupData) return;
                    
                    console.log('开始安全更新群聊元素:', groupData.name);
                    console.log('元素当前状态:', {
                        tagName: element.tagName,
                        className: element.className,
                        dataName: element.getAttribute('data-name'),
                        dataGroupId: element.getAttribute('data-group-id')
                    });
                    
                    // *** 安全策略1：只更新数据属性，不破坏DOM结构 ***
                    element.setAttribute('data-group-id', groupData.id);
                    element.setAttribute('data-name', groupData.name);
                    
                    // *** 安全策略2：小心更新群聊名称，保持原有HTML结构 ***
                    const nameElement = element.querySelector('.QQ_home_name');
                    if (nameElement) {
                        const oldName = nameElement.textContent.trim();
                        if (oldName !== groupData.name) {
                            console.log(`安全更新名称: "${oldName}" -> "${groupData.name}"`);
                        nameElement.textContent = groupData.name;
                        }
                    } else {
                        console.warn('未找到群聊名称元素，跳过名称更新');
                    }
                    
                    // *** 安全策略3：谨慎更新群聊头像，避免破坏样式 ***
                    const avatarElement = element.querySelector('.QQ_home_head');
                    if (avatarElement && groupData.avatar) {
                        console.log('安全更新群聊头像');
                        
                        // 保存原有的基础样式
                        const originalClasses = avatarElement.className;
                        const originalId = avatarElement.id;
                        
                        try {
                        updateAvatarElement(avatarElement, groupData.avatar);
                            
                            // 确保原有类名和ID没有被破坏
                            if (originalClasses && !avatarElement.className.includes('QQ_home_head')) {
                                avatarElement.className = originalClasses;
                            }
                            if (originalId) {
                                avatarElement.id = originalId;
                            }
                            
                        } catch (avatarError) {
                            console.error('更新头像时出错，保持原状:', avatarError);
                        }
                    }
                    
                    console.log('群聊元素安全更新完成:', groupData.name);
                    
                } catch (error) {
                    console.error('安全更新群聊元素时出错:', error);
                    // 即使出错也要确保基本数据属性正确
                    try {
                        element.setAttribute('data-group-id', groupData.id);
                        element.setAttribute('data-name', groupData.name);
                        console.log('已设置基本数据属性作为备用');
                    } catch (backupError) {
                        console.error('设置备用数据属性也失败:', backupError);
                    }
                }
            }
            
            // [已删除] immediateUpdateGroupElement - 已整合到safeUpdateGroupElement
            
            /**
             * 更新头像元素的通用函数
             */
            function updateAvatarElement(avatarElement, avatarData) {
                if (!avatarElement) {
                    console.warn('updateAvatarElement: 头像元素不存在');
                    return;
                }
                
                if (!avatarData) {
                    console.warn('updateAvatarElement: 头像数据不存在，保持现有头像');
                    return;
                }
                
                console.log('更新头像元素:', avatarData);
                
                if (avatarData.type === 'preset') {
                    // 预设头像
                    avatarElement.style.background = `linear-gradient(135deg, ${avatarData.gradient.start}, ${avatarData.gradient.end})`;
                    avatarElement.style.backgroundImage = 'none';
                    avatarElement.style.color = 'white';
                    avatarElement.style.display = 'flex';
                    avatarElement.style.alignItems = 'center';
                    avatarElement.style.justifyContent = 'center';
                    avatarElement.style.fontWeight = 'bold';
                    avatarElement.textContent = avatarData.text || '群';
                } else if (avatarData.type === 'upload' && avatarData.imageData) {
                    // 上传的头像
                    avatarElement.style.background = 'none';
                    avatarElement.style.backgroundImage = `url('${avatarData.imageData}')`;
                    avatarElement.style.backgroundSize = 'cover';
                    avatarElement.style.backgroundPosition = 'center';
                    avatarElement.style.backgroundRepeat = 'no-repeat';
                    avatarElement.textContent = '';
                } else if (typeof avatarData === 'string' && avatarData.startsWith('data:')) {
                    // 直接的base64字符串
                    avatarElement.style.background = 'none';
                    avatarElement.style.backgroundImage = `url('${avatarData}')`;
                    avatarElement.style.backgroundSize = 'cover';
                    avatarElement.style.backgroundPosition = 'center';
                    avatarElement.style.backgroundRepeat = 'no-repeat';
                    avatarElement.textContent = '';
                } else if (typeof avatarData === 'string' && (avatarData.startsWith('http://') || avatarData.startsWith('https://'))) {
                    // 网络图片URL
                    avatarElement.style.background = 'none';
                    avatarElement.style.backgroundImage = `url('${avatarData}')`;
                    avatarElement.style.backgroundSize = 'cover';
                    avatarElement.style.backgroundPosition = 'center';
                    avatarElement.style.backgroundRepeat = 'no-repeat';
                    avatarElement.textContent = '';
                } else {
                    // 默认头像
                    avatarElement.style.background = 'linear-gradient(135deg, #199AFF, #0066CC)';
                    avatarElement.style.backgroundImage = 'none';
                    avatarElement.style.color = 'white';
                    avatarElement.style.display = 'flex';
                    avatarElement.style.alignItems = 'center';
                    avatarElement.style.justifyContent = 'center';
                    avatarElement.style.fontWeight = 'bold';
                    avatarElement.textContent = '群';
                }
            }
            

            
            /**
             * 保存群聊到世界书的通用函数（修复版）
             */
            async function saveGroupToWorldbook(groupData) {
                console.log('保存群聊到世界书:', groupData);
                
                try {
                    // 使用与动态内容存储相同的简单检查
                    if (!worldbook || !entries) {
                        console.warn('世界书功能不可用，无法保存群聊到世界书');
                            return false;
                    }
                    
                    // 查找现有的群聊条目 - 使用唯一comment查找
                    const uniqueComment = `手机-群聊-${groupData.name}`;
                    let groupEntry = entries.find(e => 
                        e.comment === uniqueComment
                    );
                    
                    // 处理头像引用
                    let avatarReference = 'http://sharkpan.xyz/f/z0WU5/mmexport1736971020657.gif';
                    if (groupData.avatar) {
                        if (groupData.avatar.type === 'upload' && groupData.avatar.imageData) {
                            avatarReference = groupData.avatar.imageData;
                        } else if (groupData.avatar.type === 'preset') {
                            avatarReference = `预设:${groupData.avatar.text || '群'}`;
                        } else if (groupData.avatar.type === 'url' && groupData.avatar.url) {
                            avatarReference = groupData.avatar.url;
                        }
                    } else if (groupData.avatarUrl) {
                        avatarReference = groupData.avatarUrl;
                    }
                    
                    // 构建群聊内容
                    const groupContent = `[${groupData.name}]
类型=群聊
成员=${groupData.members.join(',')}
头像=${avatarReference}`;
                    
                    if (groupEntry) {
                        // 更新现有条目
                        console.log('更新现有群聊条目:', groupEntry.uid);
                        await setLorebookEntries(worldbook, [
                            {
                                uid: groupEntry.uid,
                                content: groupContent,
                            }
                        ]);
                        console.log('群聊已保存到世界书');
                    } else {
                        console.error('未找到群聊条目，无法保存');
                        return false;
                    }
                    
                    return true;
                } catch (error) {
                    console.error('保存群聊到世界书失败:', error);
                    throw error;
                }
            }
            
            /**
             * 从所有列表中移除群聊
             */
            function removeGroupFromAllLists(groupId) {
                // 从联系人列表移除
                const contactsContainer = document.getElementById('QQ_home_chars');
                if (contactsContainer) {
                    const existingGroup = contactsContainer.querySelector(`[data-group-id="${groupId}"]`);
                    if (existingGroup) {
                        existingGroup.remove();
                    }
                }
                
                // 从消息列表移除
                const messagesContainer = document.getElementById('QQ_message_list_chars');
                if (messagesContainer) {
                    const existingGroup = messagesContainer.querySelector(`[data-group-id="${groupId}"]`);
                    if (existingGroup) {
                        existingGroup.remove();
                    }
                }
            }
            
            /**
             * 强制删除群聊界面元素（增强版删除，确保完全清除）
             */
            function forceRemoveGroupFromInterface(groupId, groupName) {
                console.log('强制删除群聊界面元素:', groupId, groupName);
                
                // 方法1：通过data-group-id删除
                const elementsById = document.querySelectorAll(`[data-group-id="${groupId}"]`);
                elementsById.forEach((element, index) => {
                    console.log(`通过ID删除元素 ${index + 1}:`, element);
                    element.remove();
                });
                
                // 方法2：通过群聊名称删除
                const contactsContainer = document.getElementById('QQ_home_chars');
                if (contactsContainer) {
                    const groupElements = contactsContainer.querySelectorAll('.QQ_home_char[data-group-type="true"]');
                    groupElements.forEach(element => {
                        const nameElement = element.querySelector('.QQ_home_name');
                        if (nameElement && nameElement.textContent.trim() === groupName) {
                            console.log('通过名称删除联系人列表中的群聊:', groupName);
                            element.remove();
                        }
                    });
                }
                
                // 方法3：通过群聊名称删除消息列表中的群聊
                const messagesContainer = document.getElementById('QQ_message_list_chars');
                if (messagesContainer) {
                    const groupElements = messagesContainer.querySelectorAll('.QQ_home_char[data-group-type="true"]');
                    groupElements.forEach(element => {
                        const nameElement = element.querySelector('.QQ_home_name');
                        if (nameElement && nameElement.textContent.trim() === groupName) {
                            console.log('通过名称删除消息列表中的群聊:', groupName);
                            element.remove();
                        }
                    });
                }
                
                // 方法4：删除对应的聊天页面
                const chatPages = document.querySelectorAll(`.QQ_chat_page[data-name='${groupName}']`);
                chatPages.forEach((page, index) => {
                    console.log(`删除聊天页面 ${index + 1}:`, groupName);
                    page.remove();
                });
                
                // 方法5：删除群聊专用页面
                const groupChatPages = document.querySelectorAll(`.group-chat-page[data-group-id="${groupId}"]`);
                groupChatPages.forEach((page, index) => {
                    console.log(`删除群聊专用页面 ${index + 1}:`, groupId);
                    page.remove();
                });
                
                console.log('强制删除群聊界面元素完成');
            }
            
            /**
             * 安全删除群聊界面元素（避免过度删除导致空白页面）
             */
            function safeRemoveGroupFromInterface(groupId, groupName) {
                console.log('安全删除群聊界面元素:', groupId, groupName);
                
                // 只删除特定的群聊元素，保护主要的界面结构
                try {
                    // 删除联系人列表中的群聊
                    const contactsContainer = document.getElementById('QQ_home_chars');
                    if (contactsContainer) {
                        const groupElements = contactsContainer.querySelectorAll('.QQ_home_char[data-group-type="true"]');
                        groupElements.forEach(element => {
                            const nameElement = element.querySelector('.QQ_home_name');
                            if (nameElement && nameElement.textContent.trim() === groupName) {
                                console.log('安全删除联系人列表中的群聊:', groupName);
                                element.remove();
                            }
                        });
                    }
                    
                    // 删除消息列表中的群聊
                    const messagesContainer = document.getElementById('QQ_message_list_chars');
                    if (messagesContainer) {
                        const groupElements = messagesContainer.querySelectorAll('.QQ_home_char[data-group-type="true"]');
                        groupElements.forEach(element => {
                            const nameElement = element.querySelector('.QQ_home_name');
                            if (nameElement && nameElement.textContent.trim() === groupName) {
                                console.log('安全删除消息列表中的群聊:', groupName);
                                element.remove();
                            }
                        });
                    }
                    
                    // 只删除当前群聊的专用页面
                    const groupChatPages = document.querySelectorAll(`.group-chat-page[data-group-id="${groupId}"]`);
                    groupChatPages.forEach((page, index) => {
                        console.log(`安全删除群聊专用页面 ${index + 1}:`, groupId);
                        page.remove();
                    });
                    
                    console.log('安全删除群聊界面元素完成');
                    
                } catch (error) {
                    console.error('安全删除群聊界面元素时出错:', error);
                }
            }
            
            /**
             * 调试函数：测试群聊名称点击
             */

            

            
            /**
             * 显示添加成员模态窗口
             */
            function showAddMemberModal() {
                if (!currentManagingGroup) {
                    console.error('没有当前管理的群聊');
                    return;
                }
                
                console.log('显示添加成员模态窗口');
                
                const modal = document.getElementById('add_member_modal');
                if (!modal) {
                    console.error('未找到添加成员模态窗口');
                    return;
                }
                
                // 清空搜索框
                const searchInput = document.getElementById('add_member_search_input');
                if (searchInput) {
                    searchInput.value = '';
                }
                
                // 重置选中状态
                window.selectedMembersToAdd = [];
                updateAddMemberConfirmButton();
                
                // 加载联系人列表
                loadContactsForAddMember();
                
                // 显示模态窗口
                modal.style.display = 'flex';
            }
            
            /**
             * 关闭添加成员模态窗口
             */
            function closeAddMemberModal() {
                const modal = document.getElementById('add_member_modal');
                if (modal) {
                    modal.style.display = 'none';
                }
                
                // 清空选中状态
                window.selectedMembersToAdd = [];
            }
            
            /**
             * 加载联系人列表用于添加成员
             */
            function loadContactsForAddMember() {
                const contactList = document.getElementById('add_member_contact_list');
                if (!contactList) {
                    console.error('添加成员联系人列表容器未找到');
                    return;
                }
                
                contactList.innerHTML = '';
                
                // 获取所有联系人
                const contactsContainer = document.getElementById('QQ_home_chars');
                if (!contactsContainer) {
                    console.error('联系人容器未找到');
                    return;
                }
                
                // *** 修复：使用正确的选择器 .QQ_home_usermsg，与联系人界面搜索保持一致 ***
                const contactElements = contactsContainer.querySelectorAll('.QQ_home_usermsg');
                const currentMembers = new Set(currentManagingGroup.members);
                
                console.log(`找到 ${contactElements.length} 个联系人，当前群聊成员:`, currentMembers);
                
                let addedCount = 0;
                contactElements.forEach(element => {
                    // 跳过群聊类型的联系人，只处理个人联系人
                    if (element.hasAttribute('data-group-type')) {
                        return;
                    }
                    
                    const nameElement = element.querySelector('.QQ_home_name');
                    if (!nameElement) return;
                    
                    const contactName = nameElement.textContent.trim();
                    
                    // 跳过已经在群聊中的成员
                    if (currentMembers.has(contactName)) {
                        console.log(`跳过已存在成员: ${contactName}`);
                        return;
                    }
                    
                    const contactItem = document.createElement('div');
                    contactItem.className = 'add-member-contact-item';
                    contactItem.setAttribute('data-contact-name', contactName);
                    
                    const contactAvatar = document.createElement('div');
                    contactAvatar.className = 'add-member-contact-avatar';
                    
                    // *** 修复：优先从世界书获取头像，确保显示正确的角色头像 ***
                    console.log(`为联系人 ${contactName} 获取头像`);
                    
                    // 首先尝试从世界书获取头像
                    const worldbookAvatar = getCharacterAvatarFromWorldbook(contactName);
                    if (worldbookAvatar) {
                        console.log(`从世界书获取到 ${contactName} 的头像:`, worldbookAvatar);
                        
                        // 应用世界书中的头像
                        contactAvatar.style.backgroundImage = worldbookAvatar.backgroundImage;
                        contactAvatar.style.backgroundSize = 'cover';
                        contactAvatar.style.backgroundPosition = 'center';
                        contactAvatar.style.backgroundRepeat = 'no-repeat';
                        contactAvatar.style.borderRadius = '50%';
                        contactAvatar.style.width = '40px';
                        contactAvatar.style.height = '40px';
                        contactAvatar.style.marginRight = '12px';
                        contactAvatar.style.flexShrink = '0';
                        contactAvatar.textContent = '';
                    } else {
                        // 备选方案：从联系人列表复制头像
                        const avatarElement = element.querySelector('.QQ_home_head');
                        if (avatarElement) {
                            console.log(`从联系人列表复制 ${contactName} 的头像`);
                            
                            // 直接复制原始头像的所有样式和内容
                            contactAvatar.style.cssText = avatarElement.style.cssText;
                            contactAvatar.style.width = '40px';
                            contactAvatar.style.height = '40px';
                            contactAvatar.style.marginRight = '12px';
                            contactAvatar.style.flexShrink = '0';
                            contactAvatar.textContent = avatarElement.textContent;
                            
                            // 确保背景图像和背景样式都复制过来
                            const computedStyle = window.getComputedStyle(avatarElement);
                            if (computedStyle.backgroundImage && computedStyle.backgroundImage !== 'none') {
                                contactAvatar.style.backgroundImage = computedStyle.backgroundImage;
                            }
                            if (computedStyle.backgroundColor && computedStyle.backgroundColor !== 'rgba(0, 0, 0, 0)') {
                                contactAvatar.style.backgroundColor = computedStyle.backgroundColor;
                            }
                        } else {
                            // 最后的备选方案：使用默认头像
                            console.log(`为 ${contactName} 使用默认头像`);
                            contactAvatar.style.background = 'linear-gradient(135deg, #667eea, #764ba2)';
                            contactAvatar.style.backgroundImage = '';
                            contactAvatar.style.color = 'white';
                            contactAvatar.style.display = 'flex';
                            contactAvatar.style.alignItems = 'center';
                            contactAvatar.style.justifyContent = 'center';
                            contactAvatar.style.fontWeight = 'bold';
                            contactAvatar.style.borderRadius = '50%';
                            contactAvatar.style.width = '40px';
                            contactAvatar.style.height = '40px';
                            contactAvatar.style.marginRight = '12px';
                            contactAvatar.style.flexShrink = '0';
                            contactAvatar.textContent = contactName.charAt(0);
                        }
                    }
                    
                    const contactNameDiv = document.createElement('div');
                    contactNameDiv.className = 'add-member-contact-name';
                    contactNameDiv.textContent = contactName;
                    
                    const contactStatus = document.createElement('div');
                    contactStatus.className = 'add-member-contact-status';
                    contactStatus.textContent = '点击添加';
                    
                    contactItem.appendChild(contactAvatar);
                    contactItem.appendChild(contactNameDiv);
                    contactItem.appendChild(contactStatus);
                    
                    // 添加点击事件
                    contactItem.addEventListener('click', function() {
                        toggleMemberSelection(contactName, contactItem);
                    });
                    
                    contactList.appendChild(contactItem);
                    addedCount++;
                });
                
                console.log(`已加载 ${addedCount} 个可添加的联系人`);
                
                // 如果没有可添加的联系人，显示提示
                if (addedCount === 0) {
                    const noContactDiv = document.createElement('div');
                    noContactDiv.style.cssText = 'text-align: center; color: #999; padding: 20px; font-size: 14px;';
                    noContactDiv.textContent = '暂无可添加的联系人';
                    contactList.appendChild(noContactDiv);
                }
            }
            
            /**
             * 切换成员选中状态
             */
            function toggleMemberSelection(contactName, contactItem) {
                if (!window.selectedMembersToAdd) {
                    window.selectedMembersToAdd = [];
                }
                
                const index = window.selectedMembersToAdd.indexOf(contactName);
                const statusElement = contactItem.querySelector('.add-member-contact-status');
                
                if (index > -1) {
                    // 取消选中
                    window.selectedMembersToAdd.splice(index, 1);
                    contactItem.classList.remove('selected');
                    statusElement.textContent = '点击添加';
                } else {
                    // 选中
                    window.selectedMembersToAdd.push(contactName);
                    contactItem.classList.add('selected');
                    statusElement.textContent = '已选中';
                }
                
                updateAddMemberConfirmButton();
            }
            
            /**
             * 更新添加成员确认按钮状态
             */
            function updateAddMemberConfirmButton() {
                const confirmBtn = document.getElementById('add_member_confirm_btn');
                if (!confirmBtn) return;
                
                const selectedCount = window.selectedMembersToAdd ? window.selectedMembersToAdd.length : 0;
                
                if (selectedCount > 0) {
                    confirmBtn.disabled = false;
                    confirmBtn.textContent = `添加成员 (${selectedCount})`;
                } else {
                    confirmBtn.disabled = true;
                    confirmBtn.textContent = '添加成员';
                }
            }
            
            /**
             * 过滤添加成员联系人列表（参考联系人界面搜索逻辑）
             */
            function filterAddMemberContacts() {
                const searchInput = document.getElementById('add_member_search_input');
                const contactList = document.getElementById('add_member_contact_list');
                
                if (!searchInput || !contactList) {
                    console.log('搜索输入框或联系人列表未找到');
                    return;
                }
                
                const searchTerm = searchInput.value.trim();
                const search = searchTerm.toLowerCase();
                const isEmpty = search === '';
                const contactItems = contactList.querySelectorAll('.add-member-contact-item');
                
                console.log(`=== 添加成员搜索调试 ===`);
                console.log(`搜索词: "${searchTerm}"`);
                console.log(`联系人总数: ${contactItems.length}`);
                
                let visibleCount = 0;
                
                // 移除之前的无结果提示
                const existingNoResult = contactList.querySelector('.no-search-result');
                if (existingNoResult) {
                    existingNoResult.remove();
                }
                
                contactItems.forEach((item, index) => {
                    const nameElement = item.querySelector('.add-member-contact-name');
                    if (!nameElement) {
                        console.warn("联系人项目缺少姓名元素", item);
                        item.style.display = 'none';
                        return;
                    }
                    
                    // 获取原始文本内容（参考联系人搜索逻辑）
                    const originalName = nameElement.getAttribute('data-original-text') || nameElement.textContent;
                    const name = originalName.toLowerCase();
                    
                    // 检查是否匹配搜索条件
                    const nameMatches = isEmpty || name.includes(search);
                    const isMatch = nameMatches;
                    
                    if (isMatch) {
                        // 显示联系人
                        item.style.display = 'flex';
                        visibleCount++;
                        
                        // 处理高亮显示（参考联系人搜索的高亮逻辑）
                        if (!isEmpty && nameMatches) {
                            highlightAddMemberSearchTerm(nameElement, searchTerm, originalName);
                        } else {
                            // 恢复原始文本，移除高亮
                            if (nameElement.getAttribute('data-original-text')) {
                                nameElement.innerHTML = originalName;
                            }
                        }
                    } else {
                        // 隐藏不匹配的联系人
                        item.style.display = 'none';
                    }
                });
                
                console.log(`搜索"${searchTerm}": 找到 ${visibleCount} 个联系人`);
                
                // 如果搜索有内容但无结果，显示提示
                if (!isEmpty && visibleCount === 0) {
                    const noResultDiv = document.createElement('div');
                    noResultDiv.className = 'no-search-result';
                    noResultDiv.style.cssText = 'text-align: center; color: #999; padding: 20px; font-size: 14px; border: 1px dashed #ddd; border-radius: 8px; margin: 10px 0;';
                    noResultDiv.innerHTML = `
                        <div style="font-size: 16px; margin-bottom: 8px;">🔍</div>
                        <div>未找到包含 "<strong>${searchTerm}</strong>" 的联系人</div>
                        <div style="font-size: 12px; color: #666; margin-top: 4px;">请尝试输入其他关键词</div>
                    `;
                    contactList.appendChild(noResultDiv);
                    console.log("没有找到匹配的联系人");
                }
            }
            
            /**
             * 添加成员搜索高亮功能（参考联系人搜索高亮逻辑）
             */
            function highlightAddMemberSearchTerm(element, searchTerm, originalText) {
                if (!searchTerm || searchTerm.trim() === '') {
                    element.innerHTML = originalText;
                    return;
                }
                
                // 保存原始文本
                if (!element.getAttribute('data-original-text')) {
                    element.setAttribute('data-original-text', originalText);
                }
                
                // 创建高亮HTML
                const regex = new RegExp(`(${searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
                const highlightedText = originalText.replace(regex, '<span style="background-color: #FFE066; color: #333; font-weight: bold; padding: 1px 2px; border-radius: 2px;">$1</span>');
                
                element.innerHTML = highlightedText;
            }
            
            /**
             * 确认添加成员
             */
            async function confirmAddMembers() {
                if (!currentManagingGroup || !window.selectedMembersToAdd || window.selectedMembersToAdd.length === 0) {
                    return;
                }
                
                console.log('添加成员到群聊:', window.selectedMembersToAdd);
                
                // 记录要添加的新成员（用于系统消息）
                const newMembers = [];
                
                // 将选中的成员添加到群聊
                window.selectedMembersToAdd.forEach(memberName => {
                    if (!currentManagingGroup.members.includes(memberName)) {
                        currentManagingGroup.members.push(memberName);
                        newMembers.push(memberName);
                    }
                });
                
                // 保存到本地存储
                saveGroupToStorage(currentManagingGroup);
                
                // *** 新增：更新到世界书 ***
                await updateGroupMembersInWorldbook(currentManagingGroup.name, currentManagingGroup.members);
                
                // *** 立即更新当前聊天界面（如果正在群聊中） ***
                if (window.currentGroupChat && window.currentGroupChat.id === currentManagingGroup.id) {
                    console.log('立即更新当前群聊界面（添加成员后）');
                    
                    // 更新当前群聊对象
                    window.currentGroupChat.members = currentManagingGroup.members;
                    
                    // 立即更新聊天界面头部显示（包括人数）
                    updateChatHeader(currentManagingGroup);
                    
                    console.log('群聊界面头部已立即更新，人数:', currentManagingGroup.members.length);
                }
                
                // *** 修复：为每个新成员添加系统消息并立即显示 ***
                if (newMembers.length > 0) {
                    console.log('添加成员系统消息:', newMembers);
                    
                    for (const memberName of newMembers) {
                        const systemMessage = `群主邀请${memberName}加入群聊`;
                        
                        // *** 修复：总是保存系统消息，不依赖界面状态检查 ***
                        console.log('保存添加成员系统消息:', systemMessage);
                        await addSystemMessageToGroup(currentManagingGroup.id, systemMessage);
                        
                        // *** 修复：强制立即显示系统消息 ***
                        console.log('强制立即显示添加成员系统消息:', systemMessage);
                        displaySystemMessage(systemMessage, currentManagingGroup.id);
                    }
                }
                
                        // *** 立即更新所有界面中的群聊显示 ***
        console.log('立即更新联系人列表中的群聊显示（添加成员后）...');
        
        // *** 关键修复：确保传递完整的群聊数据，包括头像信息 ***
        console.log('传递给protectedContactListUpdate的数据:', {
            name: currentManagingGroup.name,
            id: currentManagingGroup.id,
            avatar: currentManagingGroup.avatar,
            members: currentManagingGroup.members
        });
        await protectedContactListUpdate(currentManagingGroup, 'add_member');
        
        // *** 轻量级界面更新，避免消息丢失 ***
        console.log('执行轻量级界面更新（添加成员后）...');
        await refreshGroupChatsDisplay();
                
                console.log(`已添加 ${newMembers.length} 个新成员到群聊`);
                alert(`已添加 ${newMembers.length} 个成员到群聊`);
                
                // 关闭模态窗口
                closeAddMemberModal();
                
                // 刷新群聊设置界面
                showGroupSettings();
            }

            /**
             * 清理localStorage中的过期头像数据
             */
            function cleanupAvatarData() {
                try {
                    // 获取所有localStorage中的头像数据
                    const avatarKeys = [];
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (key && key.startsWith('avatarData_')) {
                            avatarKeys.push(key);
                        }
                    }
                    
                    console.log('找到头像数据:', avatarKeys.length, '个');
                    
                    // 获取世界书中正在使用的头像ID
                    const usedAvatarIds = new Set();
                    if (entries && worldbook) {
                        const entry = entries.find(e => e.key === "手机-角色");
                        if (entry && entry.content) {
                            const lines = entry.content.split('\n');
                            lines.forEach(line => {
                                if (line.startsWith('头像=avatar_')) {
                                    const avatarId = line.substring(3);
                                    usedAvatarIds.add('avatarData_' + avatarId);
                                }
                            });
                        }
                    } else {
                        console.log('cleanupAvatarData: entries或worldbook未初始化，跳过世界书检查');
                    }
                    
                    console.log('正在使用的头像ID:', usedAvatarIds.size, '个');
                    
                    // 删除未使用的头像数据
                    let deletedCount = 0;
                    avatarKeys.forEach(key => {
                        if (!usedAvatarIds.has(key)) {
                            localStorage.removeItem(key);
                            deletedCount++;
                            console.log('删除未使用的头像数据:', key);
                        }
                    });
                    
                    console.log('清理完成，删除了', deletedCount, '个未使用的头像数据');
                } catch (error) {
                    console.error('清理头像数据失败:', error);
                }
            }
            
            /**
             * 获取localStorage使用情况
             */
            function getStorageUsage() {
                try {
                    let totalSize = 0;
                    let avatarSize = 0;
                    let avatarCount = 0;
                    
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        const value = localStorage.getItem(key);
                        const size = (key.length + value.length) * 2; // 估算字节数
                        totalSize += size;
                        
                        if (key.startsWith('avatarData_')) {
                            avatarSize += size;
                            avatarCount++;
                        }
                    }
                    
                    console.log('localStorage使用情况:');
                    console.log('- 总大小:', (totalSize / 1024 / 1024).toFixed(2), 'MB');
                    console.log('- 头像数据大小:', (avatarSize / 1024 / 1024).toFixed(2), 'MB');
                    console.log('- 头像数量:', avatarCount, '个');
                    
                    return {
                        totalSize,
                        avatarSize,
                        avatarCount
                    };
                } catch (error) {
                    console.error('获取存储使用情况失败:', error);
                    return null;
                }
            }

            // 将函数添加到全局作用域
            window.showGroupManagementMenu = showGroupManagementMenu;
            window.closeGroupManagementMenu = closeGroupManagementMenu;
            window.showGroupSettings = showGroupSettings;
            window.closeGroupSettings = closeGroupSettings;
            window.saveGroupSettings = saveGroupSettings;
            window.deleteContactGroup = deleteContactGroup;
            window.deleteGroupChat = deleteGroupChat;
            window.deleteCurrentGroup = deleteCurrentGroup;
            window.showAddMemberModal = showAddMemberModal;
            window.closeAddMemberModal = closeAddMemberModal;
            window.filterAddMemberContacts = filterAddMemberContacts;
            window.confirmAddMembers = confirmAddMembers;
            window.testGroupNameClick = testGroupNameClick;
            window.debugGroupData = debugGroupData;
            window.cleanupAvatarData = cleanupAvatarData;
            window.getStorageUsage = getStorageUsage;
            
            // 调试：检查函数是否正确定义
            console.log('🔧 全局函数检查:');
            console.log('- confirmAvatarSelection:', typeof window.confirmAvatarSelection);
            console.log('- createGroupChat:', typeof window.createGroupChat);
            console.log('- showGroupManagementMenu:', typeof window.showGroupManagementMenu);
            console.log('- saveGroupToStorage:', typeof saveGroupToStorage);
            console.log('- addGroupToContactList:', typeof addGroupToContactList);
            console.log('- addGroupToMessageList:', typeof addGroupToMessageList);
            
            // 调试：检查按钮是否存在
            setTimeout(() => {
                const avatarBtn = document.getElementById('avatar_confirm_btn');
                const groupBtn = document.getElementById('group_confirm_btn');
                console.log('🔧 按钮检查:');
                console.log('- avatar_confirm_btn:', avatarBtn ? '存在' : '不存在');
                console.log('- group_confirm_btn:', groupBtn ? '存在' : '不存在');
                
                if (avatarBtn) {
                    console.log('- avatar按钮onclick:', avatarBtn.getAttribute('onclick'));
                }
                if (groupBtn) {
                    console.log('- group按钮onclick:', groupBtn.getAttribute('onclick'));
                }
            }, 1000);
            
            /**
             * ===== 增强的世界书数据管理系统 =====
             */
            
            /**
             * 安全地保存数据到世界书
             */
            async function QQ_SafeSaveToWorldBook(operation, data, key) {
                try {
                    if (!worldbook || !entries) {
                        console.warn(`世界书功能不可用，无法保存${operation}`);
                        return false;
                    }
                    
                    // 创建世界书条目数据
                    const entryData = {
                        data: data,
                        operation: operation,
                        timestamp: new Date().toISOString(),
                        version: "1.0"
                    };
                    
                    // 查找或创建世界书条目
                    let entry = entries.find(e => e.comment === key);
                    
                    if (!entry) {
                        // 创建新条目
                        entry = {
                            comment: key,
                            content: JSON.stringify(entryData),
                            key: [`此世界书永不触发_${key}`],
                            keysecondary: [],
                            order: 1000 + entries.length,
                            enabled: true,
                            uid: Date.now() + Math.random()
                        };
                        // 添加到worldbook.entries（如果存在）
                        if (worldbook.entries) {
                            worldbook.entries.push(entry);
                        }
                        console.log(`创建新世界书条目: ${key}`);
                    } else {
                        // 更新现有条目
                        entry.content = JSON.stringify(entryData);
                        console.log(`更新世界书条目: ${key}`);
                    }
                    
                    // 触发保存
                    await QQ_SafeSaveWorldInfo(operation);
                    
                    console.log(`${operation}已成功保存到世界书 (${key})`);
                    return true;
                } catch (error) {
                    console.error(`保存${operation}到世界书失败:`, error);
                    return false;
                }
            }
            
            /**
             * 从世界书获取数据
             */
            async function QQ_GetFromWorldBook(key) {
                try {
                    if (!worldbook || !entries) {
                        console.warn('世界书功能不可用，返回默认值');
                        return null;
                    }
                    
                    const entry = entries.find(e => e.comment === key);
                    if (entry && entry.content) {
                        const entryData = JSON.parse(entry.content);
                        return entryData.data;
                    }
                    
                    return null;
                } catch (error) {
                    console.error(`从世界书读取数据失败 (${key}):`, error);
                    return null;
                }
            }
            
            /**
             * ===== 各类数据保存到世界书的功能 =====
             */
            
            /**
             * 保存所有联系人到世界书
             */
            function QQ_SaveAllContactsToWorldBook() {
                const contacts = window.QQ_Contacts || {};
                return QQ_SafeSaveToWorldBook('联系人数据', contacts, 'QQ_联系人数据');
            }
            
            /**
             * 保存所有群聊到世界书
             */
            function QQ_SaveAllGroupsToWorldBook() {
                const groups = window.QQ_Groups || {};
                return QQ_SafeSaveToWorldBook('群聊数据', groups, 'QQ_群聊数据');
            }
            
            /**
             * 保存所有消息到世界书
             */
            function QQ_SaveAllMessagesToWorldBook() {
                const messages = window.QQ_MessageHistory || {};
                return QQ_SafeSaveToWorldBook('消息记录', messages, 'QQ_消息记录');
            }
            
            /**
             * 保存所有动态到世界书
             */
            function QQ_SaveAllMomentsToWorldBook() {
                const moments = window.QQ_MomentData || {};
                return QQ_SafeSaveToWorldBook('动态数据', moments, 'QQ_动态数据');
            }
            
            /**
             * 保存所有互动空间到世界书
             */
            function QQ_SaveAllInteractiveSpacesToWorldBook() {
                const spaces = window.QQ_InteractiveSpaces || {};
                const characterSpaces = window.QQ_CharacterSpaces || {};
                
                const allSpaces = {
                    publicSpaces: spaces,
                    characterSpaces: characterSpaces
                };
                
                return QQ_SafeSaveToWorldBook('互动空间数据', allSpaces, 'QQ_互动空间数据');
            }
            
            /**
             * *** 已废弃：分组数据保存函数 ***
             * 这些函数已被简化版直接操作取代，参考群聊模式
             */
            /*
            async function QQ_SaveContactGroupsToWorldBook(characterId, groups) {
                // 此函数已废弃，现在使用简化的直接操作模式
            }
            
            async function QQ_LoadContactGroupsFromWorldBook(characterId) {
                // 此函数已废弃，现在使用简化的直接操作模式
            }
            */
            
            /**
             * ===== 统一的世界书数据管理系统 =====
             * 参考动态内容存储的成功机制，确保互动内容和分组内容也能正确保存和加载
             */
            
            /**
             * *** 简化版：统一的世界书保存函数 - 使用与动态内容相同的简单机制 ***
             * 参考QQ_Save_Moments的成功实现，为所有类型数据提供统一的保存机制
             */
            async function QQ_UnifiedSaveToWorldBook(dataType, dataContent, comment, keyPrefix = 'QQ') {
                try {
                    if (!worldbook || !entries) {
                        console.warn(`世界书功能不可用，无法保存${dataType}数据`);
                        return false;
                    }
                    
                    // *** 使用与动态内容相同的简单保存方式 ***
                    // 查找现有条目
                    let targetEntry = entries.find(entry => entry.comment === comment);
                    
                    // 准备保存的数据（简化格式）
                    const jsonData = JSON.stringify(dataContent, null, 2);
                    console.log(`准备保存${dataType}数据: ${comment}`);
                    
                    if (targetEntry) {
                        // 直接更新现有条目的内容
                        targetEntry.content = jsonData;
                        console.log(`✅ ${dataType}数据已更新到现有世界书条目: ${comment}`);
                    } else {
                        // *** 简化版：直接创建新条目到entries数组 ***
                        const newEntry = {
                            uid: Date.now(),
                            comment: comment,
                            key: [`此世界书永不触发_${keyPrefix}_${dataType}`],
                            content: jsonData,
                            enabled: true,
                            order: 9998,
                            depth: 0
                        };
                        entries.push(newEntry);
                        console.log(`✅ ${dataType}数据已保存到新世界书条目: ${comment}`);
                    }
                    
                    // *** 修复：使用统一的安全保存机制 ***
                    const saveSuccess = await QQ_SafeSaveWorldInfo(`${dataType}数据`);
                    if (!saveSuccess) {
                        console.warn(`⚠️ ${dataType}数据保存可能未完全同步`);
                    }
                    
                    // *** 新增：验证保存是否成功 ***
                    const verifyEntry = entries.find(entry => entry.comment === comment);
                    if (verifyEntry && verifyEntry.content === jsonData) {
                        console.log(`✅ 验证成功：${dataType}数据已正确保存到世界书`);
                        return true;
                    } else {
                        console.error(`❌ 验证失败：${dataType}数据保存可能有问题`);
                        return false;
                    }
                    
                } catch (error) {
                    console.error(`保存${dataType}数据到世界书失败:`, error);
                    return false;
                }
            }
            
            /**
             * *** 简化版：统一的世界书加载函数 - 使用与动态内容相同的简单机制 ***
             */
            async function QQ_UnifiedLoadFromWorldBook(comment, defaultValue = null) {
                try {
                    if (!worldbook || !entries) {
                        console.warn(`世界书功能不可用，返回默认值`);
                        return defaultValue;
                    }
                    
                    // 查找目标条目
                    const targetEntry = entries.find(entry => entry.comment === comment);
                    
                    if (targetEntry && targetEntry.content) {
                        try {
                            // *** 简化版：直接解析JSON内容，不需要包装格式 ***
                            const data = JSON.parse(targetEntry.content);
                            console.log(`✅ 从世界书加载数据成功: ${comment}`, data);
                            
                            // *** 兼容性处理：支持新旧数据格式 ***
                            if (data && typeof data === 'object' && data.content !== undefined) {
                                // 旧格式：带有wrapper的数据
                                console.log(`检测到旧格式数据，提取content部分`);
                                return data.content || defaultValue;
                            } else {
                                // 新格式：直接的数据
                                console.log(`检测到新格式数据，直接返回`);
                                return data || defaultValue;
                            }
                        } catch (parseError) {
                            console.error(`解析世界书数据失败 (${comment}):`, parseError);
                            return defaultValue;
                        }
                    } else {
                        console.log(`世界书中没有找到条目: ${comment}`);
                        return defaultValue;
                    }
                } catch (error) {
                    console.error(`从世界书加载数据失败 (${comment}):`, error);
                    return defaultValue;
                }
            }
            
            /**
             * *** 修复：互动内容保存函数 ***
             * 使用项目统一的QQ_SafeSaveToWorldBook机制，保持与其他功能一致性
             */
            async function QQ_SaveInteractiveContentToWorldBook(content, characterName = null) {
                try {
                    const interactiveData = {
                        content: content,
                        characterName: characterName,
                        timestamp: new Date().toISOString(),
                        id: `interactive_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                        type: characterName ? 'character_specific' : 'public'
                    };
                    
                    // 确定保存的键值（世界书条目comment）
                    const worldbookKey = characterName ? 
                        `QQ_互动内容备份_${characterName}` : 
                        'QQ_互动内容备份';
                    
                    // 加载现有数据
                    const existingData = await QQ_GetFromWorldBook(worldbookKey);
                    let dataArray = [];
                    
                    if (existingData && Array.isArray(existingData)) {
                        dataArray = existingData;
                    } else if (existingData && existingData.interactiveContent && Array.isArray(existingData.interactiveContent)) {
                        // 兼容旧格式
                        dataArray = existingData.interactiveContent;
                    }
                    
                    // 添加新数据到数组开头
                    dataArray.unshift(interactiveData);
                    
                    // 限制数量（最多30个）
                    if (dataArray.length > 30) {
                        dataArray.splice(30);
                    }
                    
                    console.log(`准备保存互动内容到世界书: ${worldbookKey}, 内容数量: ${dataArray.length}`);
                    
                    // 使用统一的保存机制
                    const success = await QQ_SafeSaveToWorldBook(
                        `互动内容_${characterName || '公共'}`, 
                        dataArray, 
                        worldbookKey
                    );
                    
                    if (success) {
                        console.log(`🎯 互动内容保存成功: ${characterName || '公共'}, ID: ${interactiveData.id}`);
                        return interactiveData.id;
                    } else {
                        console.error('互动内容保存失败：QQ_SafeSaveToWorldBook返回false');
                        return null;
                    }
                    
                } catch (error) {
                    console.error('保存互动内容失败:', error);
                    return null;
                }
            }
            
            /**
             * *** 修复：互动内容加载函数 ***
             * 使用项目统一的QQ_GetFromWorldBook机制，保持与其他功能一致性
             */
            async function QQ_LoadInteractiveContentFromWorldBook(characterName = null) {
                try {
                    // 确定世界书键值（与保存时一致）
                    const worldbookKey = characterName ? 
                        `QQ_互动内容备份_${characterName}` : 
                        'QQ_互动内容备份';
                    
                    // 使用统一的加载机制
                    const data = await QQ_GetFromWorldBook(worldbookKey);
                    
                    if (data && Array.isArray(data)) {
                        console.log(`✅ 加载${characterName || '公共'}互动内容: ${data.length}个项目`);
                        return data;
                    } else if (data && data.interactiveContent && Array.isArray(data.interactiveContent)) {
                        // 兼容旧格式
                        console.log(`✅ 加载${characterName || '公共'}互动内容(旧格式): ${data.interactiveContent.length}个项目`);
                        return data.interactiveContent;
                    } else {
                        console.log(`📋 ${characterName || '公共'}没有互动内容`);
                        return [];
                    }
                } catch (error) {
                    console.error('从世界书加载互动内容失败:', error);
                    return [];
                }
            }
            


            /**
             * *** 新增：综合数据管理和调试工具 ***
             * 替代过期的测试函数，提供简洁的数据管理功能
             */
            window.QQ_DataManager = {
                /**
                 * *** 新增：测试分组加载修复 ***
                 */
                async testGroupLoading() {
                    console.log('=== 🧪 测试分组加载修复 ===');
                    
                    try {
                        const characterId = getCurrentCharacterId() || 'default';
                        console.log(`\n🎭 测试角色ID: ${characterId}`);
                        
                        // 1. 检查世界书基本可用性
                        console.log('\n1️⃣ 检查世界书基本状态...');
                        if (!worldbook || !entries) {
                            console.error('❌ 世界书或entries不可用');
                            return false;
                        }
                        console.log(`✅ 世界书可用, entries数量: ${entries.length}`);
                        
                        // 2. 查找分组条目
                        console.log('\n2️⃣ 查找分组条目...');
                        const comment = `QQ_分组备份_${characterId}`;
                        const targetEntry = entries.find(entry => entry.comment === comment);
                        
                        if (targetEntry) {
                            console.log(`✅ 找到分组条目: ${comment}`);
                            console.log(`📄 条目内容长度: ${targetEntry.content?.length || 0}`);
                            console.log(`📄 条目内容预览:`, targetEntry.content?.substring(0, 200) + '...');
                            
                            // 3. 尝试解析数据
                            console.log('\n3️⃣ 尝试解析分组数据...');
                            try {
                                const data = JSON.parse(targetEntry.content);
                                console.log(`✅ JSON解析成功:`, data);
                                
                                // 4. 检查数据格式
                                console.log('\n4️⃣ 检查数据格式...');
                                let groupsData = null;
                                if (data && typeof data === 'object' && data.content !== undefined) {
                                    console.log(`📋 检测到旧格式数据，提取content部分`);
                                    groupsData = data.content;
                    } else {
                                    console.log(`📋 检测到新格式数据，直接使用`);
                                    groupsData = data;
                                }
                                
                                if (Array.isArray(groupsData)) {
                                    console.log(`✅ 成功获取分组数据: ${groupsData.length}个分组`);
                                    groupsData.forEach((group, index) => {
                                        console.log(`📂 分组${index + 1}: ${group.name} (${group.contacts?.length || 0}个联系人)`);
                                    });
                                    return true;
                                } else {
                                    console.error(`❌ 分组数据格式错误，不是数组:`, typeof groupsData);
                                    return false;
                                }
                            } catch (parseError) {
                                console.error(`❌ JSON解析失败:`, parseError);
                                return false;
                            }
                        } else {
                            console.log(`❌ 没有找到分组条目: ${comment}`);
                            console.log(`📋 可用的条目列表:`);
                            entries.forEach((entry, index) => {
                                if (entry.comment && entry.comment.includes('分组')) {
                                    console.log(`  ${index}: ${entry.comment}`);
                                }
                            });
                            return false;
                        }
                        
                    } catch (error) {
                        console.error('❌ 测试分组加载失败:', error);
                        return false;
                    }
                },
                
                /**
                 * 显示所有世界书数据统计
                 */
                async showStats() {
                    console.log('=== 📊 SillyTavern手机前端数据统计 ===');
                    
                    try {
                        if (!QQ_IsWorldBookAvailable()) {
                            console.log('❌ 世界书功能不可用');
                            return;
                        }
                        
                        const characterId = getCurrentCharacterId() || 'default';
                        console.log(`\n🎭 当前角色ID: ${characterId}`);
                        
                        // 动态数据统计
                        if (QQ_MomentsData && Array.isArray(QQ_MomentsData)) {
                            const totalComments = QQ_MomentsData.reduce((sum, moment) => sum + (moment.comments?.length || 0), 0);
                            console.log(`\n📱 动态数据: ${QQ_MomentsData.length}条动态, ${totalComments}条评论`);
                        }
                        
                        // 分组数据统计
                        const groups = await QQ_LoadContactGroupsFromWorldBook(characterId);
                        const totalContacts = groups.reduce((sum, group) => sum + (group.contacts?.length || 0), 0);
                        console.log(`\n👥 分组数据: ${groups.length}个分组, ${totalContacts}个联系人`);
                        
                        // 互动空间数据统计
                        const publicInteractive = await QQ_LoadInteractiveContentFromWorldBook();
                        const characterInteractive = await QQ_LoadInteractiveContentFromWorldBook(characterId);
                        console.log(`\n🎯 互动空间: 公共${publicInteractive.length}个, 角色专属${characterInteractive.length}个`);
                        
                        console.log('\n=== 数据统计完成 ===');
                    
                } catch (error) {
                        console.error('获取数据统计失败:', error);
                    }
                },
                
                /**
                 * 清理和优化数据
                 */
                async optimizeData() {
                    console.log('=== 🧹 数据清理和优化 ===');
                    
                    try {
                        // 清理动态数据
                        if (typeof QQ_CleanOldMoments === 'function') {
                            QQ_CleanOldMoments();
                            console.log('✅ 动态数据清理完成');
                        }
                        
                        // 优化评论存储
                        if (typeof QQ_OptimizeCommentsStorage === 'function') {
                            QQ_OptimizeCommentsStorage();
                            console.log('✅ 评论存储优化完成');
                        }
                        
                        // 保存清理后的数据
                        if (typeof QQ_Save_Moments === 'function') {
                            await QQ_Save_Moments();
                            console.log('✅ 优化后的动态数据已保存');
                        }
                        
                        console.log('\n=== 数据优化完成 ===');
                        
                    } catch (error) {
                        console.error('数据优化失败:', error);
                    }
                },
                
                /**
                 * *** 新增：测试互动内容保存和加载 ***
                 */
                async testInteractiveContent() {
                    console.log('=== 🎯 测试互动内容保存和加载 ===');
                    
                    try {
                        const characterId = getCurrentCharacterId() || 'default';
                        console.log(`\n🎭 测试角色ID: ${characterId}`);
                        
                        // 1. 检查世界书可用性
                        console.log('\n1️⃣ 检查世界书状态...');
                        if (!worldbook || !entries) {
                            console.error('❌ 世界书或entries不可用');
                            return false;
                        }
                        console.log(`✅ 世界书可用, entries数量: ${entries.length}`);
                        
                        // 2. 测试保存互动内容
                        console.log('\n2️⃣ 测试保存互动内容...');
                        const testContent = `测试互动内容 - ${new Date().toLocaleString()}\n\n这是一个测试的互动场景，包含以下元素：\n1. 详细的场景描述\n2. 角色的动作和表情\n3. 环境的渲染\n4. 情感的表达`;
                        
                        const interactiveId = await QQ_SaveInteractiveContentToWorldBook(testContent, characterId);
                        
                        if (interactiveId) {
                            console.log(`✅ 互动内容保存成功，ID: ${interactiveId}`);
                        } else {
                            console.error('❌ 互动内容保存失败');
                            return false;
                        }
                        
                        // 3. 测试加载互动内容
                        console.log('\n3️⃣ 测试加载互动内容...');
                        const loadedContent = await QQ_LoadInteractiveContentFromWorldBook(characterId);
                        
                        if (Array.isArray(loadedContent) && loadedContent.length > 0) {
                            console.log(`✅ 互动内容加载成功: ${loadedContent.length}个项目`);
                            console.log(`📄 最新内容预览:`, loadedContent[0].content.substring(0, 100) + '...');
                            console.log(`🕒 创建时间:`, loadedContent[0].timestamp);
                            console.log(`🎭 关联角色:`, loadedContent[0].characterName);
                        } else {
                            console.error('❌ 互动内容加载失败或为空');
                            return false;
                        }
                        
                        // 4. 验证世界书条目
                        console.log('\n4️⃣ 验证世界书条目...');
                        const worldbookKey = `QQ_互动内容备份_${characterId}`;
                        
                        // 使用统一的QQ_GetFromWorldBook验证
                        const verifyData = await QQ_GetFromWorldBook(worldbookKey);
                        
                        if (verifyData && Array.isArray(verifyData)) {
                            console.log(`✅ 世界书条目验证成功: ${worldbookKey}`);
                            console.log(`📄 条目数据包含: ${verifyData.length}个项目`);
                            
                            // 检查最新项目是否匹配
                            if (verifyData.length > 0 && verifyData[0].id === interactiveId) {
                                console.log(`✅ 最新项目ID匹配: ${interactiveId}`);
                                console.log(`📝 项目内容预览: ${verifyData[0].content.substring(0, 50)}...`);
                                return true;
                            } else {
                                console.error(`❌ 最新项目ID不匹配: 期望${interactiveId}, 实际${verifyData[0]?.id}`);
                                return false;
                            }
                        } else {
                            console.error(`❌ 世界书条目验证失败: ${worldbookKey}`);
                            console.log(`💡 提示: 检查QQ_SafeSaveToWorldBook是否正常工作`);
                            return false;
                        }
                        
                    } catch (error) {
                        console.error('❌ 测试互动内容失败:', error);
                        return false;
                    }
                },
                
                /**
                 * *** 新增：测试互动空间保存和加载 ***
                 */
                async testInteractiveSpaces() {
                    console.log('=== 🎯 测试互动空间保存和加载 ===');
                   
                    try {
                        // 1. 检查世界书基本状态
                        console.log('\n1️⃣ 检查世界书基本状态...');
                        if (!worldbook || !entries) {
                            console.error('❌ 世界书或entries不可用');
                            return false;
                        }
                        console.log(`✅ 世界书可用, entries数量: ${entries.length}`);
                        
                        // 2. 检查当前互动空间数据
                        console.log('\n2️⃣ 检查当前互动空间数据...');
                        const currentSpaceCount = Object.keys(QQ_InteractiveSpaces || {}).length;
                        console.log(`📊 当前内存中的互动空间数量: ${currentSpaceCount}`);
                        
                        if (currentSpaceCount > 0) {
                            console.log('📋 当前互动空间列表:');
                            Object.keys(QQ_InteractiveSpaces).forEach(spaceId => {
                                const space = QQ_InteractiveSpaces[spaceId];
                                console.log(`  - ${spaceId}: ${space.name} (${space.characterName})`);
                            });
                        }
                        
                        // 3. 测试保存功能
                        console.log('\n3️⃣ 测试保存功能...');
                        const saveResult = await QQ_SaveInteractiveSpaces();
                        if (saveResult) {
                            console.log('✅ 互动空间保存成功');
                        } else {
                            console.error('❌ 互动空间保存失败');
                            return false;
                        }
                        
                        // 4. 验证世界书条目
                        console.log('\n4️⃣ 验证世界书条目...');
                        const targetEntry = entries.find(entry => entry.comment === QQ_INTERACTIVE_BACKUP_KEY);
                        
                        if (targetEntry) {
                            console.log(`✅ 世界书条目存在: ${QQ_INTERACTIVE_BACKUP_KEY}`);
                            console.log(`📄 条目内容长度: ${targetEntry.content?.length || 0}`);
                            
                            try {
                                const entryData = JSON.parse(targetEntry.content);
                                if (entryData.spaces && typeof entryData.spaces === 'object') {
                                    const savedSpaceCount = Object.keys(entryData.spaces).length;
                                    console.log(`✅ 条目数据格式正确: ${savedSpaceCount}个空间`);
                                    
                                    if (savedSpaceCount === currentSpaceCount) {
                                        console.log('✅ 保存的空间数量与内存数量一致');
                                    } else {
                                        console.warn(`⚠️ 数量不一致: 内存${currentSpaceCount} vs 保存${savedSpaceCount}`);
                                    }
                                } else {
                                    console.error('❌ 条目数据格式错误，没有spaces对象');
                                    return false;
                                }
                            } catch (parseError) {
                                console.error('❌ 条目内容JSON解析失败:', parseError);
                                return false;
                            }
                        } else {
                            console.error(`❌ 世界书条目不存在: ${QQ_INTERACTIVE_BACKUP_KEY}`);
                            return false;
                        }
                        
                        // 5. 测试加载功能
                        console.log('\n5️⃣ 测试加载功能...');
                        const originalSpaces = { ...QQ_InteractiveSpaces };
                        QQ_InteractiveSpaces = {}; // 清空内存
                        
                        await QQ_LoadInteractiveSpaces();
                        const loadedSpaceCount = Object.keys(QQ_InteractiveSpaces).length;
                        
                        if (loadedSpaceCount === currentSpaceCount) {
                            console.log('✅ 加载测试成功，数据完整恢复');
                            QQ_InteractiveSpaces = originalSpaces; // 恢复原数据
                        } else {
                            console.error(`❌ 加载测试失败: 期望${currentSpaceCount}个，实际${loadedSpaceCount}个`);
                            QQ_InteractiveSpaces = originalSpaces; // 恢复原数据
                            return false;
                        }
                        
                        console.log('\n✅ 互动空间保存加载测试完成');
                        console.log('🎯 互动空间功能正常，数据能正确保存到世界书并重新加载');
                        
                        toastr.success('互动空间保存加载测试通过', '测试成功');
                        return true;
                        
                    } catch (error) {
                        console.error('❌ 测试互动空间时出错:', error);
                        toastr.error('测试过程中出现错误，请查看控制台', '测试失败');
                        return false;
                    }
                },
                
                /**
                 * *** 新增：测试互动空间数据一致性 ***
                 * 验证界面显示数据与世界书存储数据是否完全同步
                 */
                async testInteractiveSpacesConsistency() {
                    console.log('=== 🔍 测试互动空间数据一致性 ===');
                    
                    try {
                        // 1. 检查基本状态
                        if (!worldbook || !entries) {
                            console.error('❌ 世界书功能不可用');
                            return false;
                        }
                        
                        // 2. 获取界面显示数据
                        const interfaceSpaces = QQ_InteractiveSpaces || {};
                        const interfaceSpaceIds = Object.keys(interfaceSpaces);
                        console.log(`🖥️ 界面数据: ${interfaceSpaceIds.length}个空间`);
                        
                        // 3. 获取世界书存储数据
                        const entry = entries.find(e => e.comment === QQ_INTERACTIVE_BACKUP_KEY);
                        let worldbookSpaces = {};
                        let worldbookSpaceIds = [];
                        
                        if (entry && entry.content) {
                            try {
                                const data = JSON.parse(entry.content);
                                worldbookSpaces = data.spaces || {};
                                worldbookSpaceIds = Object.keys(worldbookSpaces);
                                console.log(`📚 世界书数据: ${worldbookSpaceIds.length}个空间`);
                            } catch (parseError) {
                                console.error('❌ 世界书数据解析失败:', parseError);
                                return false;
                            }
                        } else {
                            console.log('📚 世界书中没有互动空间数据');
                        }
                        
                        // 4. 对比数据一致性
                        if (interfaceSpaceIds.length === worldbookSpaceIds.length) {
                            console.log('✅ 空间数量一致');
                            
                            // 检查每个空间ID是否匹配
                            const missingInWorldbook = interfaceSpaceIds.filter(id => !worldbookSpaceIds.includes(id));
                            const missingInInterface = worldbookSpaceIds.filter(id => !interfaceSpaceIds.includes(id));
                            
                            if (missingInWorldbook.length === 0 && missingInInterface.length === 0) {
                                console.log('✅ 所有空间ID完全匹配');
                                
                                // 检查空间内容是否一致
                                let contentMismatches = 0;
                                interfaceSpaceIds.forEach(spaceId => {
                                    const interfaceSpace = interfaceSpaces[spaceId];
                                    const worldbookSpace = worldbookSpaces[spaceId];
                                    
                                    if (interfaceSpace.content !== worldbookSpace.content) {
                                        contentMismatches++;
                                        console.warn(`⚠️ 空间${spaceId}内容不一致`);
                                    }
                                });
                                
                                if (contentMismatches === 0) {
                                    console.log('✅ 所有空间内容完全一致');
                                    console.log('🎯 数据一致性测试通过：界面数据与世界书数据完全同步');
                                    return true;
                                } else {
                                    console.error(`❌ 有${contentMismatches}个空间内容不一致`);
                                    return false;
                                }
                            } else {
                                console.error('❌ 空间ID不匹配:');
                                if (missingInWorldbook.length > 0) {
                                    console.error('  界面有但世界书没有:', missingInWorldbook);
                                }
                                if (missingInInterface.length > 0) {
                                    console.error('  世界书有但界面没有:', missingInInterface);
                                }
                                return false;
                            }
                        } else {
                            console.error(`❌ 空间数量不一致: 界面${interfaceSpaceIds.length} vs 世界书${worldbookSpaceIds.length}`);
                            return false;
                        }
                        
                    } catch (error) {
                        console.error('❌ 测试数据一致性时出错:', error);
                        return false;
                    }
                },

                /**
                 * 手动保存所有数据
                 */
                async saveAll() {
                    console.log('=== 💾 手动保存所有数据 ===');
                    
                    try {
                        // 保存动态数据
                        if (typeof QQ_Save_Moments === 'function') {
                            await QQ_Save_Moments();
                            console.log('✅ 动态数据已保存');
                        }
                        
                        // 保存分组数据
                        if (typeof saveGroupsToStorage === 'function') {
                            await saveGroupsToStorage();
                            console.log('✅ 分组数据已保存');
                        }
                        
                        // 保存互动空间数据
                        if (typeof QQ_SaveInteractiveSpaces === 'function') {
                            await QQ_SaveInteractiveSpaces();
                            console.log('✅ 互动空间数据已保存');
                        }
                        
                        console.log('\n=== 所有数据保存完成 ===');
                        
                } catch (error) {
                        console.error('保存数据失败:', error);
                    }
                },
                
                /**
                 * 测试世界书功能
                 */
                async testWorldBook() {
                    console.log('=== 🧪 世界书功能测试 ===');
                    
                    try {
                        const testData = { test: true, timestamp: new Date().toISOString() };
                        const testComment = 'QQ_测试数据_临时';
                        
                        // 测试保存
                        const saveSuccess = await QQ_UnifiedSaveToWorldBook('测试', testData, testComment, '测试');
                        console.log('保存测试:', saveSuccess ? '✅ 成功' : '❌ 失败');
                        
                        // 测试加载
                        const loadedData = await QQ_UnifiedLoadFromWorldBook(testComment, null);
                        const loadSuccess = loadedData && loadedData.test === true;
                        console.log('加载测试:', loadSuccess ? '✅ 成功' : '❌ 失败');
                        
                        console.log('\n=== 世界书功能测试完成 ===');
                        return saveSuccess && loadSuccess;
                        
                    } catch (error) {
                        console.error('世界书功能测试失败:', error);
                        return false;
                    }
                }
            };
            
            /**
             * ===== 修复分组保存功能 =====
             */
            
            /**
             * *** 已移除：重复的window.saveGroupsToStorage定义 ***
             * 现在统一使用主saveGroupsToStorage函数
             */
            

            
            /**
             * *** 已移除：重复的window.loadGroupsFromStorage定义 ***
             * 现在统一使用主loadGroupsFromStorage函数
             */
            
            /**
             * ===== 数据管理和调试工具 =====
             */
            
            /**
             * *** 新增：调试分组数据同步状态 ***
             */
            window.QQ_Debug_Group_Data_Sync = function() {
                console.log('=== 🔍 分组数据同步状态检查 ===');
                
                try {
                    const charId = getCurrentCharacterId() || 'default';
                    const comment = `QQ_分组备份_${charId}`;
                    
                    console.log(`📍 当前角色ID: ${charId}`);
                    console.log(`📍 查找世界书条目: ${comment}`);
                    
                    // 检查内存中的分组数据
                    console.log(`📊 内存中的分组数据 (contactGroups):`);
                    console.log(`  - 分组数量: ${contactGroups.length}`);
                    if (contactGroups.length > 0) {
                        contactGroups.forEach((group, index) => {
                            console.log(`  - [${index}] ${group.name} (${group.contacts.length}人) ID:${group.id}`);
                        });
                    } else {
                        console.log(`  - 无分组数据`);
                    }
                    
                    // 检查世界书中的条目
                    if (!worldbook || !entries) {
                        console.error('❌ 世界书功能不可用');
                        return;
                    }
                    
                    const targetEntry = entries.find(entry => entry.comment === comment);
                    console.log(`📖 世界书条目状态:`);
                    if (targetEntry) {
                        console.log(`  ✅ 找到世界书条目: ${comment}`);
                        console.log(`  - UID: ${targetEntry.uid}`);
                        console.log(`  - 内容长度: ${targetEntry.content.length} 字符`);
                        
                        try {
                            const worldbookGroups = JSON.parse(targetEntry.content);
                            console.log(`  - 解析成功: ${Array.isArray(worldbookGroups) ? worldbookGroups.length : 0} 个分组`);
                            
                            if (Array.isArray(worldbookGroups) && worldbookGroups.length > 0) {
                                worldbookGroups.forEach((group, index) => {
                                    console.log(`    - [${index}] ${group.name} (${group.contacts ? group.contacts.length : 0}人) ID:${group.id}`);
                                });
                            }
                            
                            // 比较内存和世界书数据是否一致
                            console.log(`📊 数据一致性检查:`);
                            if (contactGroups.length === worldbookGroups.length) {
                                console.log(`  ✅ 分组数量一致: ${contactGroups.length}`);
                            } else {
                                console.warn(`  ⚠️ 分组数量不一致: 内存${contactGroups.length} vs 世界书${worldbookGroups.length}`);
                            }
                            
                        } catch (parseError) {
                            console.error(`  ❌ 解析世界书条目失败:`, parseError);
                        }
                    } else {
                        console.warn(`  ⚠️ 未找到世界书条目: ${comment}`);
                    }
                    
                    // 显示总结
                    const summary = `
🔍 分组数据同步状态:
- 角色ID: ${charId}  
- 内存分组数: ${contactGroups.length}个
- 世界书条目: ${targetEntry ? '✅ 存在' : '❌ 不存在'}
- 数据同步: ${targetEntry ? '需要进一步检查详细日志' : '❌ 世界书条目缺失'}

详细信息请查看控制台日志`;
                    
                    alert(summary);
                    
                } catch (error) {
                    console.error('分组数据同步检查失败:', error);
                }
            };
            
            /**
             * *** 新增：测试分组功能的完整性 ***
             */
            window.QQ_Test_Group_Functions = async function() {
                console.log('=== 🧪 测试分组功能开始 ===');
                
                try {
                    const characterId = getCurrentCharacterId() || 'default';
                    console.log(`测试角色ID: ${characterId}`);
                    
                    // 1. 测试加载功能
                    console.log('1️⃣ 测试分组加载功能...');
                    await loadGroupsFromStorage();
                    console.log(`✅ 加载测试完成，当前分组数量: ${contactGroups.length}`);
                    
                    // 2. 测试世界书查找功能
                    console.log('2️⃣ 测试世界书查找功能...');
                    const expectedComment = `QQ_分组备份_${characterId}`;
                    const existingEntry = entries ? entries.find(entry => entry.comment === expectedComment) : null;
                    if (existingEntry) {
                        console.log(`✅ 找到世界书条目: ${expectedComment}`);
                        console.log('条目内容预览:', existingEntry.content.substring(0, 100) + '...');
                    } else {
                        console.log(`⚠️ 未找到世界书条目: ${expectedComment}`);
                    }
                    
                    // 3. 测试保存功能
                    console.log('3️⃣ 测试分组保存功能...');
                    const originalLength = contactGroups.length;
                    const testGroup = {
                        id: 'test_group_' + Date.now(),
                        name: '测试分组_' + Date.now(),
                        contacts: [],
                        collapsed: false,
                        order: 999
                    };
                    
                    contactGroups.push(testGroup);
                    const saveResult = await saveGroupsToStorage();
                    console.log(`保存测试结果: ${saveResult ? '✅ 成功' : '❌ 失败'}`);
                    
                    // 4. 测试删除功能（移除测试分组）
                    console.log('4️⃣ 测试分组删除功能...');
                    contactGroups.splice(-1, 1); // 移除最后一个（测试分组）
                    const deleteResult = await saveGroupsToStorage();
                    console.log(`删除测试结果: ${deleteResult ? '✅ 成功' : '❌ 失败'}`);
                    
                    // 5. 验证最终状态
                    console.log('5️⃣ 验证最终状态...');
                    await loadGroupsFromStorage();
                    console.log(`✅ 最终分组数量: ${contactGroups.length}`);
                    
                    const summary = `
📊 分组功能测试总结:
- 角色ID: ${characterId}
- 加载功能: ${contactGroups.length >= 0 ? '✅ 正常' : '❌ 异常'}
- 世界书条目: ${existingEntry ? '✅ 存在' : '⚠️ 不存在'}
- 保存功能: ${saveResult ? '✅ 正常' : '❌ 异常'}
- 删除功能: ${deleteResult ? '✅ 正常' : '❌ 异常'}
- 当前分组数: ${contactGroups.length}个

${contactGroups.length > 0 ? 
'分组详情: ' + contactGroups.map(g => `${g.name}(${g.contacts.length}人)`).join(', ') : 
'当前无分组'}`;
                    
                    console.log(summary);
                    alert(summary);
                    
                } catch (error) {
                    console.error('分组功能测试失败:', error);
                    alert('分组功能测试失败: ' + error.message);
                }
                
                console.log('=== 🧪 测试分组功能结束 ===');
            };
            
            /**
             * 显示世界书数据统计
             */
            window.QQ_Show_WorldBook_Stats = function() {
                try {
                    if (!QQ_IsWorldBookAvailable()) {
                        console.log('❌ 世界书功能不可用');
                        return;
                    }
                    
                    console.log('=== 世界书数据统计 ===');
                    
                    const stats = {
                        总条目数: 0,
                        QQ相关条目: 0,
                        数据类型: {}
                    };
                    
                    if (worldbook && worldbook.entries) {
                        stats.总条目数 = worldbook.entries.length;
                        
                        worldbook.entries.forEach(entry => {
                            if (entry.comment && entry.comment.includes('QQ_')) {
                                stats.QQ相关条目++;
                                
                                // 统计数据类型
                                if (entry.comment.includes('联系人')) {
                                    stats.数据类型.联系人 = (stats.数据类型.联系人 || 0) + 1;
                                } else if (entry.comment.includes('群聊')) {
                                    stats.数据类型.群聊 = (stats.数据类型.群聊 || 0) + 1;
                                } else if (entry.comment.includes('消息')) {
                                    stats.数据类型.消息 = (stats.数据类型.消息 || 0) + 1;
                                } else if (entry.comment.includes('动态')) {
                                    stats.数据类型.动态 = (stats.数据类型.动态 || 0) + 1;
                                } else if (entry.comment.includes('互动')) {
                                    stats.数据类型.互动空间 = (stats.数据类型.互动空间 || 0) + 1;
                                } else if (entry.comment.includes('分组')) {
                                    stats.数据类型.分组 = (stats.数据类型.分组 || 0) + 1;
                                } else {
                                    stats.数据类型.其他 = (stats.数据类型.其他 || 0) + 1;
                                }
                            }
                        });
                    }
                    
                    console.log(stats);
                    
                    const message = `📊 世界书数据统计
总条目数: ${stats.总条目数}
QQ相关条目: ${stats.QQ相关条目}

数据类型分布:
${Object.entries(stats.数据类型).map(([type, count]) => `• ${type}: ${count}个`).join('\n')}`;
                    
                    alert(message);
                    
                } catch (error) {
                    console.error('显示世界书统计失败:', error);
                }
            };
            
            /**
             * 手动触发数据同步
             */
            window.QQ_Manual_Sync_All_Data = function() {
                console.log('🔄 开始手动同步所有数据到世界书...');
                QQ_SyncAllData();
            };
            
            // 页面加载完成后自动检查世界书状态
            $(document).ready(function() {
                setTimeout(() => {
                    console.log('🔍 检查世界书状态...');
                    if (QQ_IsWorldBookAvailable()) {
                        console.log('✅ 世界书功能正常');
                        // 可选：自动加载分组数据
                        if (typeof loadGroupsFromStorage === 'function') {
                            loadGroupsFromStorage().catch(error => {
                                console.error('自动加载分组数据失败:', error);
                            });
                        }
                    } else {
                        console.warn('⚠️ 世界书功能不可用，数据保存可能受影响');
                    }
                }, 2000);
            });
            
            /**
             * ===== 修复用户名下拉菜单功能 =====
             */
            
            /**
             * *** 修改：点击用户名显示精灵 ***
             */
            function QQ_ToggleUserMenu() {
                console.log('点击用户名，显示用户精灵');
                
                // 检查是否已存在精灵
                let existingSpirit = document.getElementById('QQ_user_spirit');
                if (existingSpirit) {
                    existingSpirit.remove();
                    return;
                }
                
                QQ_ShowUserSpirit();
            }
            
            /**
             * *** 新增：显示用户精灵 ***
             */
            function QQ_ShowUserSpirit() {
                // 移除现有精灵
                const existingSpirit = document.getElementById('QQ_user_spirit');
                if (existingSpirit) {
                    existingSpirit.remove();
                }
                
                // 获取用户名和头像
                const userName = QQ_GetUserName() || 'User';
                const userAvatar = QQ_GetUserAvatar() || 'default_avatar.png';
                
                // 创建精灵按钮
                const spirit = document.createElement('div');
                spirit.id = 'QQ_user_spirit';
                spirit.style.cssText = `
                    position: fixed;
                    top: 120px;
                    right: 30px;
                    width: 60px;
                    height: 60px;
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    border-radius: 50%;
                    box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
                    cursor: pointer;
                    z-index: 10000;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    animation: userSpiritPulse 2s infinite ease-in-out;
                    border: 3px solid white;
                    transition: all 0.3s ease;
                `;
                
                // 精灵内容（用户头像或图标）
                spirit.innerHTML = `
                    <img src="${userAvatar}" alt="${userName}" style="
                        width: 45px;
                        height: 45px;
                        border-radius: 50%;
                        object-fit: cover;
                    " onerror="this.outerHTML='<div style=&quot;color: white; font-size: 24px;&quot;>👤</div>';">
                `;
                
                // 精灵悬停效果
                spirit.addEventListener('mouseenter', () => {
                    spirit.style.transform = 'scale(1.1)';
                    spirit.style.boxShadow = '0 8px 25px rgba(102, 126, 234, 0.6)';
                });
                
                spirit.addEventListener('mouseleave', () => {
                    spirit.style.transform = 'scale(1)';
                    spirit.style.boxShadow = '0 6px 20px rgba(102, 126, 234, 0.4)';
                });
                
                // 点击精灵显示用户面板
                spirit.addEventListener('click', (e) => {
                    e.stopPropagation();
                    QQ_ShowUserSpiritPanel();
                    spirit.remove();
                });
                
                // 添加精灵动画样式
                if (!document.getElementById('user_spirit_styles')) {
                    const style = document.createElement('style');
                    style.id = 'user_spirit_styles';
                    style.textContent = `
                        @keyframes userSpiritPulse {
                            0%, 100% {
                                transform: scale(1);
                            }
                            50% {
                                transform: scale(1.05);
                            }
                        }
                        
                        @keyframes userSpiritSlideIn {
                            from {
                                opacity: 0;
                                transform: translateX(100px);
                            }
                            to {
                                opacity: 1;
                                transform: translateX(0);
                            }
                        }
                        
                        #QQ_user_spirit {
                            animation: userSpiritSlideIn 0.3s ease, userSpiritPulse 2s infinite ease-in-out 0.3s;
                        }
                    `;
                    document.head.appendChild(style);
                }
                
                // 添加到页面
                document.body.appendChild(spirit);
                
                // 5秒后自动消失
                setTimeout(() => {
                    if (spirit && spirit.parentNode) {
                        spirit.style.opacity = '0';
                        spirit.style.transform = 'translateX(100px)';
                        setTimeout(() => {
                            if (spirit.parentNode) {
                                spirit.remove();
                            }
                        }, 300);
                    }
                }, 5000);
                
                console.log('用户精灵已显示');
            }
            
            /**
             * *** 新增：获取用户名 ***
             */
            function QQ_GetUserName() {
                // 尝试多种方式获取用户名
                const methods = [
                    () => UserName, // 全局变量
                    () => document.getElementById('QQ_home_UserName')?.textContent?.replace(/\*\*/g, '').trim(),
                    () => document.getElementById('QQ_message_list_UserName')?.textContent?.replace(/\*\*/g, '').trim(),
                    () => window.name || window.user || 'User'
                ];
                
                for (const method of methods) {
                    try {
                        const result = method();
                        if (result && typeof result === 'string' && result.length > 0) {
                            return result;
                        }
                    } catch (error) {
                        // 忽略错误，尝试下一个方法
                    }
                }
                
                // 如果没有找到用户名，返回默认值
                return 'User';
            }
            
            /**
             * *** 新增：获取用户头像 ***
             */
            function QQ_GetUserAvatar() {
                // 尝试多种方式获取用户头像
                const methods = [
                    () => window.userAvatarPath,
                    () => window.selectedAvatarData,
                    () => document.querySelector('#QQ_home_UserAvatar img')?.src,
                    () => document.querySelector('.user-avatar img')?.src,
                    () => document.querySelector('[data-user-avatar]')?.src
                ];
                
                for (const method of methods) {
                    try {
                        const result = method();
                        if (result && typeof result === 'string' && result !== 'default_avatar.png') {
                            return result;
                        }
                    } catch (error) {
                        // 忽略错误，尝试下一个方法
                    }
                }
                
                // 如果没有找到头像，返回默认值
                return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHZpZXdCb3g9IjAgMCA0MCA0MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMjAiIGN5PSIyMCIgcj0iMjAiIGZpbGw9IiM2NjdlZWEiLz4KPHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4PSI4IiB5PSI4Ij4KPHBhdGggZD0iTTEyIDEyQzE0LjIwOTEgMTIgMTYgMTAuMjA5MSAxNiA4QzE2IDUuNzkwODYgMTQuMjA5MSA0IDEyIDRDOS43OTA4NiA0IDggNS43OTA4NiA4IDhDOCAxMC4yMDkxIDkuNzkwODYgMTIgMTIgMTJaIiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBkPSJNMTIgMTRDOC4xMzQwMSAxNCA1IDE3LjEzNDAxIDUgMjFIMTlDMTkgMTcuMTM0MDEgMTUuODY2IDE0IDEyIDE0WiIgZmlsbD0id2hpdGUiLz4KPC9zdmc+Cgo8L3N2Zz4K';
            }
            
            /**
             * *** 新增：显示用户精灵面板 ***
             */
            function QQ_ShowUserSpiritPanel() {
                console.log('显示用户精灵面板');
                
                // 移除现有面板
                $('.QQ_user_spirit_panel').remove();
                
                const userName = QQ_GetUserName() || 'User';
                const userAvatar = QQ_GetUserAvatar();
                
                // 创建面板HTML
                const panelHtml = `
                    <div class="QQ_user_spirit_panel" style="
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        background: white;
                        border-radius: 15px;
                        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
                        z-index: 99999999;
                        overflow: hidden;
                        animation: userPanelSlideIn 0.3s ease;
                        max-width: 90%;
                        max-height: 80%;
                        width: 350px;
                    ">
                        <div class="panel-header" style="
                            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                            color: white;
                            padding: 20px;
                            text-align: center;
                            font-weight: 600;
                        ">
                            <div style="display: flex; align-items: center; justify-content: center; gap: 10px;">
                                <img src="${userAvatar}" alt="${userName}" style="
                                    width: 40px;
                                    height: 40px;
                                    border-radius: 50%;
                                    border: 2px solid white;
                                " onerror="this.outerHTML='<div style=&quot;width: 40px; height: 40px; border-radius: 50%; border: 2px solid white; background: rgba(255,255,255,0.2); display: flex; align-items: center; justify-content: center; font-size: 20px;&quot;>👤</div>';">
                                <span style="font-size: 16px;">👑 ${userName} 的控制面板</span>
                            </div>
                        </div>
                        
                        <div class="panel-content" style="padding: 20px;">
                            <!-- 主要功能区 -->
                            <div style="
                                display: grid;
                                grid-template-columns: 1fr 1fr;
                                gap: 10px;
                                margin-bottom: 15px;
                            ">
                                <button class="panel-btn" data-action="interactive_guide" style="
                                    background: linear-gradient(135deg, #FF6B6B 0%, #FF8E53 100%);
                                    border: none;
                                    color: white;
                                    padding: 12px 8px;
                                    border-radius: 8px;
                                    cursor: pointer;
                                    font-size: 12px;
                                    font-weight: 500;
                                    transition: all 0.2s ease;
                                    display: flex;
                                    flex-direction: column;
                                    align-items: center;
                                    gap: 4px;
                                ">
                                    <span style="font-size: 16px;">💫</span>
                                    <span>互动指南</span>
                                </button>
                                
                                <button class="panel-btn" data-action="phone_status" style="
                                    background: linear-gradient(135deg, #4FACFE 0%, #00F2FE 100%);
                                    border: none;
                                    color: white;
                                    padding: 12px 8px;
                                    border-radius: 8px;
                                    cursor: pointer;
                                    font-size: 12px;
                                    font-weight: 500;
                                    transition: all 0.2s ease;
                                    display: flex;
                                    flex-direction: column;
                                    align-items: center;
                                    gap: 4px;
                                ">
                                    <span style="font-size: 16px;">📱</span>
                                    <span>手机状态</span>
                                </button>
                                
                                <button class="panel-btn" data-action="sync_data" style="
                                    background: linear-gradient(135deg, #43E97B 0%, #38F9D7 100%);
                                    border: none;
                                    color: white;
                                    padding: 12px 8px;
                                    border-radius: 8px;
                                    cursor: pointer;
                                    font-size: 12px;
                                    font-weight: 500;
                                    transition: all 0.2s ease;
                                    display: flex;
                                    flex-direction: column;
                                    align-items: center;
                                    gap: 4px;
                                ">
                                    <span style="font-size: 16px;">🔄</span>
                                    <span>同步数据</span>
                                </button>
                                
                                <button class="panel-btn" data-action="settings" style="
                                    background: linear-gradient(135deg, #FA709A 0%, #FEE140 100%);
                                    border: none;
                                    color: white;
                                    padding: 12px 8px;
                                    border-radius: 8px;
                                    cursor: pointer;
                                    font-size: 12px;
                                    font-weight: 500;
                                    transition: all 0.2s ease;
                                    display: flex;
                                    flex-direction: column;
                                    align-items: center;
                                    gap: 4px;
                                ">
                                    <span style="font-size: 16px;">⚙️</span>
                                    <span>设定</span>
                                </button>
                            </div>
                            
                            <!-- 新增：公共互动空间管理区 -->
                            <div style="
                                border-top: 1px solid #e9ecef;
                                padding-top: 15px;
                                margin-bottom: 15px;
                            ">
                                <div style="
                                    display: flex;
                                    align-items: center;
                                    gap: 8px;
                                    margin-bottom: 10px;
                                    font-size: 13px;
                                    font-weight: 600;
                                    color: #666;
                                ">
                                    <span style="
                                        display: inline-block;
                                        width: 16px;
                                        height: 16px;
                                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                                        border-radius: 50%;
                                        color: white;
                                        text-align: center;
                                        line-height: 16px;
                                        font-size: 10px;
                                    ">🏠</span>
                                    <span>公共互动空间</span>
                                    <span style="
                                        background: #e9ecef;
                                        color: #666;
                                        padding: 2px 6px;
                                        border-radius: 8px;
                                        font-size: 10px;
                                        font-weight: 500;
                                        margin-left: auto;
                                    ">${Object.keys(QQ_InteractiveSpaces || {}).length}个</span>
                                </div>
                                
                                <div style="
                                    display: grid;
                                    grid-template-columns: 1fr 1fr;
                                    gap: 8px;
                                ">
                                    <button class="panel-btn" data-action="view_public_spaces" style="
                                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                                        border: none;
                                        color: white;
                                        padding: 10px 8px;
                                        border-radius: 6px;
                                        cursor: pointer;
                                        font-size: 11px;
                                        font-weight: 500;
                                        transition: all 0.2s ease;
                                        display: flex;
                                        flex-direction: column;
                                        align-items: center;
                                        gap: 3px;
                                    ">
                                        <span style="font-size: 14px;">📂</span>
                                        <span>互动记录</span>
                                    </button>
                                    
                                    <button class="panel-btn" data-action="create_public_space" style="
                                        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
                                        border: none;
                                        color: white;
                                        padding: 10px 8px;
                                        border-radius: 6px;
                                        cursor: pointer;
                                        font-size: 11px;
                                        font-weight: 500;
                                        transition: all 0.2s ease;
                                        display: flex;
                                        flex-direction: column;
                                        align-items: center;
                                        gap: 3px;
                                    ">
                                        <span style="font-size: 14px;">✨</span>
                                        <span>创建互动</span>
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- 新增：互动符号提示 -->
                        <div class="interactive-tip" style="
                            padding: 12px 20px;
                            background: linear-gradient(135deg, #E8F5E8 0%, #F0F8FF 100%);
                            border-top: 1px solid #e9ecef;
                            font-size: 12px;
                            color: #666;
                            line-height: 1.4;
                        ">
                            <div style="
                                display: flex;
                                align-items: center;
                                gap: 8px;
                                margin-bottom: 6px;
                                font-weight: 500;
                            ">
                                <span style="
                                    display: inline-block;
                                    width: 16px;
                                    height: 16px;
                                    background: #4CAF50;
                                    border-radius: 50%;
                                    color: white;
                                    text-align: center;
                                    line-height: 16px;
                                    font-size: 10px;
                                ">💡</span>
                                <span style="color: #4CAF50;">快速互动小贴士</span>
                            </div>
                            <div style="margin-left: 24px;">
                                在聊天中使用 <span style="
                                    background: #4CAF50;
                                    color: white;
                                    padding: 2px 6px;
                                    border-radius: 3px;
                                    font-family: monospace;
                                    font-weight: 600;
                                ">&&</span> 符号可以直接触发互动内容
                            </div>
                            <div style="margin-left: 24px; margin-top: 4px; color: #888;">
                                例如：<code style="background: #f8f9fa; padding: 1px 4px; border-radius: 2px;">&&想要拥抱你</code>
                            </div>
                        </div>
                        
                        <div class="panel-actions" style="
                            padding: 20px;
                            background: #fafafa;
                            display: flex;
                            gap: 10px;
                        ">
                            <button class="close-panel-btn" style="
                                flex: 1;
                                background: #e9ecef;
                                border: none;
                                color: #666;
                                padding: 12px 16px;
                                border-radius: 8px;
                                cursor: pointer;
                                font-size: 13px;
                                font-weight: 500;
                                transition: all 0.2s ease;
                            ">
                                关闭
                            </button>
                        </div>
                    </div>
                    
                    <style>
                        @keyframes userPanelSlideIn {
                            from {
                                opacity: 0;
                                transform: translate(-50%, -60%);
                            }
                            to {
                                opacity: 1;
                                transform: translate(-50%, -50%);
                            }
                        }
                        
                        .QQ_user_spirit_panel .panel-btn:hover {
                            transform: translateY(-2px);
                            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
                        }
                    </style>
                `;
                
                // 添加到页面
                $('body').append(panelHtml);
                
                // 绑定事件
                $('.QQ_user_spirit_panel').on('click', function(e) {
                    e.stopPropagation();
                    
                    const panelBtn = e.target.closest('.panel-btn');
                    const closePanelBtn = e.target.closest('.close-panel-btn');
                    
                    if (panelBtn) {
                        const action = panelBtn.getAttribute('data-action');
                        console.log(`点击用户面板按钮: ${action}`);
                        
                        $('.QQ_user_spirit_panel').remove();
                        
                        switch (action) {
                            case 'interactive_guide':
                                QQ_ShowInteractiveGuide();
                                break;
                            case 'phone_status':
                                QQ_ShowPhoneStatus();
                                break;
                            case 'sync_data':
                                QQ_SyncAllData();
                                break;
                            case 'settings':
                                QQ_ShowInteractiveSettings();
                                break;
                            case 'view_public_spaces':
                                QQ_ShowPublicInteractiveSpaces();
                                break;
                            case 'create_public_space':
                                QQ_CreatePublicInteractiveSpace();
                                break;
                        }
                    } else if (closePanelBtn) {
                        $('.QQ_user_spirit_panel').remove();
                    }
                });
                
                // 点击外部关闭面板
                $(document).one('click', function() {
                    $('.QQ_user_spirit_panel').remove();
                });
            }
            
            /**
             * *** 新增：更新精灵面板中的互动状态显示 ***
             */
            function QQ_UpdateInteractiveStatus() {
                const statusContainer = $('#interactive-status-content');
                if (statusContainer.length === 0) return;
                
                try {
                    const settings = QQ_GetInteractiveSettings();
                    const symbolStatus = '🟢 特殊符号 (&&)：永久启用';
                    const keywordStatus = settings.enableKeywordTrigger ? 
                        '🟢 关键词触发：已启用' : 
                        '🔴 关键词触发：已禁用';
                    const customCount = settings.customKeywords.length;
                    const customStatus = customCount > 0 ? 
                        `🟢 自定义关键词：${customCount}个` : 
                        '⚪ 自定义关键词：暂无';
                    
                    const statusHtml = `
                        <div>${symbolStatus}</div>
                        <div>${keywordStatus}</div>
                        <div>${customStatus}</div>
                        <div style="margin-top: 4px; color: #888;">
                            点击"设定"按钮可修改关键词触发设置
                        </div>
                    `;
                    
                    statusContainer.html(statusHtml);
                } catch (error) {
                    console.error('更新互动状态显示失败:', error);
                    statusContainer.html(`
                        <div>🟢 特殊符号 (&&)：永久启用</div>
                        <div>⚪ 关键词触发：获取状态失败</div>
                        <div style="margin-top: 4px; color: #888;">
                            点击"设定"按钮配置互动触发
                        </div>
                    `);
                }
            }

            /**
             * *** 新增：显示用户设定菜单（原下拉菜单功能） ***
             */
            function QQ_ShowUserSettingsMenu() {
                console.log('显示用户设定菜单');
                
                // 检查是否已存在菜单
                let existingMenu = document.getElementById('QQ_user_dropdown_menu');
                if (existingMenu) {
                    existingMenu.remove();
                    return;
                }
                
                // 创建下拉菜单
                const menu = document.createElement('div');
                menu.id = 'QQ_user_dropdown_menu';
                menu.style.cssText = `
                    position: fixed;
                    top: 70px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: white;
                    border-radius: 12px;
                    padding: 12px 0;
                    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
                    z-index: 9999;
                    min-width: 200px;
                    animation: fadeInDown 0.2s ease;
                    border: 1px solid #e0e0e0;
                `;
                
                // 菜单项数据
                const menuItems = [
                    {
                        icon: '📊',
                        text: '世界书统计',
                        action: () => {
                            QQ_Show_WorldBook_Stats();
                            menu.remove();
                        }
                    },
                    {
                        icon: '🔄',
                        text: '同步数据',
                        action: () => {
                            QQ_Manual_Sync_All_Data();
                            menu.remove();
                        }
                    },
                    {
                        icon: '🧪',
                        text: '测试互动检测',
                        action: () => {
                            const testText = prompt('请输入要测试的文本:', '我想和大家一起拥抱');
                            if (testText) {
                                QQ_Test_Interactive_Detection(testText);
                            }
                            menu.remove();
                        }
                    },
                    {
                        icon: '⚙️',
                        text: '手机界面设置',
                        action: () => {
                            alert('设置功能开发中...');
                            menu.remove();
                        }
                    },
                    {
                        icon: '📱',
                        text: '界面信息',
                        action: () => {
                            const info = `手机界面状态:
- 当前用户: ${QQ_GetUserName()}
- 当前角色: ${getCurrentCharacterId() || '未知'}
- 世界书状态: ${QQ_IsWorldBookAvailable() ? '✅ 可用' : '❌ 不可用'}
- 联系人分组: ${contactGroups ? contactGroups.length : 0} 个
- 互动空间: ${Object.keys(QQ_InteractiveSpaces || {}).length} 个公共 + ${Object.keys(QQ_CharacterSpaces || {}).reduce((sum, char) => sum + Object.keys(QQ_CharacterSpaces[char]).length, 0)} 个私人`;
                            alert(info);
                            menu.remove();
                        }
                    }
                ];
                
                // 创建菜单项
                menuItems.forEach((item, index) => {
                    const menuItem = document.createElement('div');
                    menuItem.style.cssText = `
                        padding: 12px 20px;
                        cursor: pointer;
                        display: flex;
                        align-items: center;
                        font-size: 14px;
                        color: #333;
                        transition: background-color 0.2s ease;
                        ${index > 0 ? 'border-top: 1px solid #f0f0f0;' : ''}
                    `;
                    
                    menuItem.innerHTML = `
                        <span style="margin-right: 12px; font-size: 16px;">${item.icon}</span>
                        <span>${item.text}</span>
                    `;
                    
                    // 悬停效果
                    menuItem.addEventListener('mouseenter', () => {
                        menuItem.style.backgroundColor = '#f5f5f5';
                    });
                    
                    menuItem.addEventListener('mouseleave', () => {
                        menuItem.style.backgroundColor = 'transparent';
                    });
                    
                    // 点击事件
                    menuItem.addEventListener('click', item.action);
                    
                    menu.appendChild(menuItem);
                });
                
                // 添加动画样式
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes fadeInDown {
                        from {
                            opacity: 0;
                            transform: translateX(-50%) translateY(-10px);
                        }
                        to {
                            opacity: 1;
                            transform: translateX(-50%) translateY(0);
                        }
                    }
                `;
                document.head.appendChild(style);
                
                // 添加菜单到页面
                document.body.appendChild(menu);
                
                // 点击外部关闭菜单
                const closeMenu = (e) => {
                    if (!menu.contains(e.target) && !document.getElementById('QQ_message_list_UserName').contains(e.target)) {
                        menu.remove();
                        document.removeEventListener('click', closeMenu);
                    }
                };
                
                setTimeout(() => {
                    document.addEventListener('click', closeMenu);
                }, 100);
            }
            
            /**
             * *** 新增：显示手机状态 ***
             */
            function QQ_ShowPhoneStatus() {
                console.log('显示手机状态');
                
                const info = `📱 手机界面状态信息

👤 当前用户: ${QQ_GetUserName()}
🎭 当前角色: ${getCurrentCharacterId() || '未知'}
📚 世界书状态: ${QQ_IsWorldBookAvailable() ? '✅ 可用' : '❌ 不可用'}

📋 数据统计:
• 联系人分组: ${contactGroups ? contactGroups.length : 0} 个
• 公共互动空间: ${Object.keys(QQ_InteractiveSpaces || {}).length} 个
• 私人互动空间: ${Object.keys(QQ_CharacterSpaces || {}).reduce((sum, char) => sum + Object.keys(QQ_CharacterSpaces[char]).length, 0)} 个
• 动态数量: ${QQ_MomentsData ? QQ_MomentsData.length : 0} 个

⚙️ 功能状态:
• 消息发送: ${typeof QQ_SendMsg === 'function' ? '✅' : '❌'}
• 动态评论: ${typeof QQ_Moment_Comment === 'function' ? '✅' : '❌'}
• 互动检测: ${typeof QQ_DetectInteractiveIntent === 'function' ? '✅' : '❌'}
• 角色精灵: ${typeof QQ_ShowCharacterSpirit === 'function' ? '✅' : '❌'}

🕒 系统时间: ${new Date().toLocaleString('zh-CN')}`;
                
                alert(info);
            }
            
            /**
             * *** 新增：同步所有数据到世界书 ***
             */
            function QQ_SyncAllData() {
                console.log('🔄 开始同步所有数据到世界书...');
                
                if (!QQ_IsWorldBookAvailable()) {
                    alert('❌ 世界书功能不可用，无法同步数据');
                    return;
                }
                
                let syncCount = 0;
                let totalCount = 0;
                
                try {
                    // 同步分组数据
                    if (typeof saveGroupsToStorage === 'function') {
                        console.log('🔄 同步分组数据...');
                        saveGroupsToStorage();
                        syncCount++;
                    }
                    totalCount++;
                    
                    // 同步动态数据
                    if (typeof QQ_Save_Moments === 'function' && QQ_MomentsData) {
                        console.log('🔄 同步动态数据...');
                        QQ_Save_Moments();
                        syncCount++;
                    }
                    totalCount++;
                    
                    // 同步互动空间数据
                    if (typeof QQ_Save_Interactive_Spaces === 'function') {
                        console.log('🔄 同步互动空间数据...');
                        QQ_Save_Interactive_Spaces();
                        syncCount++;
                    }
                    totalCount++;
                    
                    // 同步已读状态
                    if (typeof QQ_SaveReadStatus === 'function') {
                        console.log('🔄 同步已读状态...');
                        QQ_SaveReadStatus();
                        syncCount++;
                    }
                    totalCount++;
                    
                    console.log(`✅ 数据同步完成: ${syncCount}/${totalCount} 项成功`);
                    alert(`✅ 数据同步完成\n成功同步: ${syncCount}/${totalCount} 项数据`);
                    
                } catch (error) {
                    console.error('❌ 数据同步失败:', error);
                    alert(`❌ 数据同步失败: ${error.message}`);
                }
            }
            
            /**
             * *** 强制从世界书重新加载所有互动空间数据 ***
             */
            async function QQ_ForceReloadInteractiveSpaces() {
                console.log('🔄 强制从世界书重新加载互动空间数据...');
                
                try {
                    // 清空内存缓存
                    QQ_InteractiveSpaces = {};
                    QQ_CharacterSpaces = {};
                    
                    // 从世界书重新加载
                    await QQ_LoadInteractiveSpaces();
                    await QQ_LoadCharacterSpaces();
                    
                    console.log('✅ 互动空间数据重新加载完成');
                    console.log(`📊 公共空间: ${Object.keys(QQ_InteractiveSpaces).length} 个`);
                    console.log(`👥 角色空间: ${Object.keys(QQ_CharacterSpaces).length} 个角色`);
                    
                    return true;
                } catch (error) {
                    console.error('❌ 强制重新加载互动空间数据失败:', error);
                    return false;
                }
            }
            
            /**
             * *** 优化：显示公共互动空间列表 - 增强加载体验 ***
             */
            async function QQ_ShowPublicInteractiveSpaces() {
                console.log('🌐 显示公共互动空间列表，立即从世界书加载数据...');
                
                // 移除现有面板
                $('.QQ_user_spirit_panel').remove();
                
                // *** 1. 立即显示加载状态 ***
                QQ_ShowPublicSpacesLoadingUI();
                
                try {
                    // *** 2. 关键优化：强制从世界书重新加载数据 ***
                    console.log('🔄 开始从世界书加载公共互动空间数据...');
                    const loadSuccess = await QQ_ForceReloadInteractiveSpaces();
                    
                    if (!loadSuccess) {
                        throw new Error('从世界书加载数据失败');
                    }
                    
                    // *** 3. 加载完成，显示数据 ***
                    QQ_ShowPublicSpacesContent();
                    
                } catch (error) {
                    console.error('❌ 显示公共互动空间失败:', error);
                    QQ_ShowPublicSpacesError(error.message);
                }
            }
            
            /**
             * *** 新增：显示公共互动空间加载状态 ***
             */
            function QQ_ShowPublicSpacesLoadingUI() {
                // 移除现有加载界面
                $('.QQ_public_spaces_panel').remove();
                
                const loadingPanel = $(`
                    <div class="QQ_public_spaces_panel" style="
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        background: white;
                        border-radius: 16px;
                        width: 85%;
                        max-width: 400px;
                        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
                        z-index: 10000;
                        overflow: hidden;
                        animation: slideIn 0.3s ease;
                    ">
                        <div class="panel-header" style="
                            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                            color: white;
                            padding: 16px 20px;
                            text-align: center;
                        ">
                            <div style="
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                gap: 8px;
                                font-size: 16px;
                                font-weight: 600;
                            ">
                                <span style="font-size: 18px;">🏠</span>
                                <span>公共互动空间</span>
                            </div>
                        </div>
                        
                        <div style="
                            padding: 40px 20px;
                            text-align: center;
                        ">
                            <div style="
                                width: 50px;
                                height: 50px;
                                border: 4px solid #f3f3f3;
                                border-top: 4px solid #667eea;
                                border-radius: 50%;
                                animation: spin 1s linear infinite;
                                margin: 0 auto 20px auto;
                            "></div>
                            <div style="
                                font-size: 16px;
                                color: #333;
                                margin-bottom: 8px;
                                font-weight: 500;
                            ">正在加载互动记录...</div>
                            <div style="
                                font-size: 12px;
                                color: #999;
                                line-height: 1.4;
                            ">从世界书获取最新数据<br/>
                            <small style="opacity: 0.7;">首次加载可能需要几秒钟</small></div>
                        </div>
                    </div>
                    
                    <style>
                        @keyframes spin {
                            0% { transform: rotate(0deg); }
                            100% { transform: rotate(360deg); }
                        }
                    </style>
                `);
                
                $('body').append(loadingPanel);
                
                // 点击背景可以关闭（可选）
                loadingPanel.on('click', function(e) {
                    if (e.target === this) {
                        $(this).remove();
                    }
                });
            }
            
            /**
             * *** 新增：显示公共互动空间内容 ***
             */
            function QQ_ShowPublicSpacesContent() {
                // 移除加载界面
                $('.QQ_public_spaces_panel').remove();
                
                const spaces = Object.values(QQ_InteractiveSpaces || {});
                const spacesCount = spaces.length;
                
                // 创建互动空间列表面板
                const panel = $(`
                    <div class="QQ_public_spaces_panel" style="
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        background: white;
                        border-radius: 16px;
                        width: 85%;
                        max-width: 400px;
                        max-height: 70vh;
                        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
                        z-index: 10000;
                        overflow: hidden;
                        animation: slideIn 0.3s ease;
                    ">
                        <div class="panel-header" style="
                            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                            color: white;
                            padding: 16px 20px;
                            text-align: center;
                            position: relative;
                        ">
                            <div style="
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                gap: 8px;
                                font-size: 16px;
                                font-weight: 600;
                            ">
                                <span style="font-size: 18px;">🏠</span>
                                <span>公共互动空间</span>
                                <span style="
                                    background: rgba(255, 255, 255, 0.2);
                                    padding: 2px 8px;
                                    border-radius: 8px;
                                    font-size: 12px;
                                    font-weight: 500;
                                ">${spacesCount}个</span>
                            </div>
                        </div>
                        
                        <div class="panel-content" style="
                            padding: 0;
                            max-height: 50vh;
                            overflow-y: auto;
                        ">
                            ${spacesCount === 0 ? `
                                <div style="
                                    text-align: center;
                                    padding: 40px 20px;
                                    color: #999;
                                ">
                                    <div style="font-size: 48px; margin-bottom: 16px;">🌟</div>
                                    <div style="font-size: 16px; margin-bottom: 8px; color: #666;">还没有互动记录</div>
                                    <div style="font-size: 12px;">开始一段现实互动吧～</div>
                                </div>
                            ` : spaces.map((space, index) => `
                                <div class="space-item" data-space-id="${space.id}" style="
                                    padding: 16px 20px;
                                    border-bottom: 1px solid #f0f0f0;
                                    cursor: pointer;
                                    transition: background-color 0.2s ease;
                                    ${index === spaces.length - 1 ? 'border-bottom: none;' : ''}
                                ">
                                    <div style="
                                        display: flex;
                                        align-items: flex-start;
                                        gap: 12px;
                                    ">
                                        <div style="
                                            width: 36px;
                                            height: 36px;
                                            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                                            border-radius: 8px;
                                            display: flex;
                                            align-items: center;
                                            justify-content: center;
                                            color: white;
                                            font-size: 16px;
                                            flex-shrink: 0;
                                        ">🌟</div>
                                        
                                        <div style="flex: 1; min-width: 0;">
                                            <div style="
                                                font-size: 14px;
                                                font-weight: 600;
                                                color: #333;
                                                margin-bottom: 4px;
                                                overflow: hidden;
                                                text-overflow: ellipsis;
                                                white-space: nowrap;
                                            ">${space.title || `互动空间 #${index + 1}`}</div>
                                            
                                            <div style="
                                                font-size: 12px;
                                                color: #666;
                                                line-height: 1.4;
                                                display: -webkit-box;
                                                -webkit-line-clamp: 2;
                                                -webkit-box-orient: vertical;
                                                overflow: hidden;
                                            ">${(space.content || '').replace(/<[^>]*>/g, '').substring(0, 60)}${(space.content || '').length > 60 ? '...' : ''}</div>
                                            
                                            <div style="
                                                font-size: 10px;
                                                color: #999;
                                                margin-top: 6px;
                                                display: flex;
                                                align-items: center;
                                                gap: 8px;
                                            ">
                                                <span>📅 ${space.timestamp ? new Date(space.timestamp).toLocaleDateString('zh-CN') : '未知时间'}</span>
                                                <span>💬 ${space.replies ? space.replies.length : 0}条回复</span>
                                            </div>
                                        </div>
                                        
                                        <div style="
                                            width: 24px;
                                            height: 24px;
                                            display: flex;
                                            align-items: center;
                                            justify-content: center;
                                            color: #ccc;
                                            font-size: 14px;
                                        ">→</div>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                        
                        <div class="panel-footer" style="
                            padding: 16px 20px;
                            border-top: 1px solid #f0f0f0;
                            background: #fafafa;
                        ">
                            <div style="
                                display: grid;
                                grid-template-columns: 1fr 1fr;
                                gap: 10px;
                            ">
                                <button class="close-btn" style="
                                    background: #e9ecef;
                                    border: none;
                                    color: #666;
                                    padding: 10px;
                                    border-radius: 8px;
                                    cursor: pointer;
                                    font-size: 14px;
                                    font-weight: 500;
                                    transition: all 0.2s ease;
                                ">关闭</button>
                                
                                <button class="create-new-btn" style="
                                    background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
                                    border: none;
                                    color: white;
                                    padding: 10px;
                                    border-radius: 8px;
                                    cursor: pointer;
                                    font-size: 14px;
                                    font-weight: 500;
                                    transition: all 0.2s ease;
                                ">✨ 创建新互动</button>
                            </div>
                        </div>
                    </div>
                `);
                
                // 添加悬停效果
                panel.find('.space-item').hover(
                    function() { $(this).css('background-color', '#f8f9fa'); },
                    function() { $(this).css('background-color', 'transparent'); }
                );
                
                // 绑定事件
                panel.on('click', '.space-item', function() {
                    const spaceId = $(this).data('space-id');
                    const space = QQ_InteractiveSpaces[spaceId];
                    if (space) {
                        panel.remove();
                        setTimeout(() => {
                            QQ_DisplayInteractiveSpace(spaceId, '公共互动空间');
                        }, 100);
                    }
                });
                
                panel.on('click', '.close-btn', function() {
                    panel.remove();
                });
                
                panel.on('click', '.create-new-btn', function() {
                    panel.remove();
                    setTimeout(() => {
                        QQ_CreatePublicInteractiveSpace();
                    }, 100);
                });
                
                // 点击外部关闭
                $(document).one('click', function() {
                    panel.remove();
                });
                
                panel.on('click', function(e) {
                    e.stopPropagation();
                });
                
                $('body').append(panel);
            }
            
            /**
             * *** 新增：创建公共互动空间 ***
             */
            async function QQ_CreatePublicInteractiveSpace() {
                console.log('创建公共互动空间');
                
                // *** 关键优化：先从世界书重新加载数据 ***
                await QQ_ForceReloadInteractiveSpaces();
                
                // 移除现有面板
                $('.QQ_public_spaces_panel').remove();
                
                // 创建输入面板
                const panel = $(`
                    <div class="QQ_create_space_panel" style="
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        background: white;
                        border-radius: 16px;
                        width: 85%;
                        max-width: 400px;
                        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
                        z-index: 10000;
                        overflow: hidden;
                        animation: slideIn 0.3s ease;
                    ">
                        <div class="panel-header" style="
                            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
                            color: white;
                            padding: 16px 20px;
                            text-align: center;
                        ">
                            <div style="
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                gap: 8px;
                                font-size: 16px;
                                font-weight: 600;
                            ">
                                <span style="font-size: 18px;">✨</span>
                                <span>创建新互动空间</span>
                            </div>
                        </div>
                        
                        <div class="panel-content" style="padding: 20px;">
                            <div style="margin-bottom: 16px;">
                                <label style="
                                    display: block;
                                    font-size: 13px;
                                    font-weight: 600;
                                    color: #333;
                                    margin-bottom: 6px;
                                ">互动标题</label>
                                <input type="text" class="space-title" placeholder="为这次互动起个名字..." style="
                                    width: 100%;
                                    padding: 10px 12px;
                                    border: 1px solid #ddd;
                                    border-radius: 8px;
                                    font-size: 14px;
                                    outline: none;
                                    transition: border-color 0.2s ease;
                                    box-sizing: border-box;
                                ">
                            </div>
                            
                            <div style="margin-bottom: 20px;">
                                <label style="
                                    display: block;
                                    font-size: 13px;
                                    font-weight: 600;
                                    color: #333;
                                    margin-bottom: 6px;
                                ">互动内容</label>
                                <textarea class="space-content" placeholder="描述你想要的互动场景..." style="
                                    width: 100%;
                                    height: 100px;
                                    padding: 10px 12px;
                                    border: 1px solid #ddd;
                                    border-radius: 8px;
                                    font-size: 14px;
                                    outline: none;
                                    transition: border-color 0.2s ease;
                                    resize: vertical;
                                    box-sizing: border-box;
                                "></textarea>
                            </div>
                            
                            <div style="
                                background: #f8f9fa;
                                padding: 12px;
                                border-radius: 8px;
                                margin-bottom: 20px;
                            ">
                                <div style="
                                    display: flex;
                                    align-items: center;
                                    gap: 6px;
                                    margin-bottom: 6px;
                                    font-size: 12px;
                                    font-weight: 600;
                                    color: #28a745;
                                ">
                                    <span>💡</span>
                                    <span>快速互动小贴士</span>
                                </div>
                                <div style="
                                    font-size: 11px;
                                    color: #666;
                                    line-height: 1.4;
                                ">
                                    在聊天中使用 <code style="
                                        background: #e9ecef;
                                        padding: 2px 4px;
                                        border-radius: 3px;
                                        font-family: monospace;
                                    ">&amp;&amp;</code> 符号可以直接触发互动内容<br>
                                    例如：<em>&amp;&amp;想要拥抱你</em>
                                </div>
                            </div>
                        </div>
                        
                        <div class="panel-footer" style="
                            padding: 16px 20px;
                            border-top: 1px solid #f0f0f0;
                            background: #fafafa;
                        ">
                            <div style="
                                display: grid;
                                grid-template-columns: 1fr 1fr;
                                gap: 10px;
                            ">
                                <button class="cancel-btn" style="
                                    background: #e9ecef;
                                    border: none;
                                    color: #666;
                                    padding: 10px;
                                    border-radius: 8px;
                                    cursor: pointer;
                                    font-size: 14px;
                                    font-weight: 500;
                                    transition: all 0.2s ease;
                                ">取消</button>
                                
                                <button class="create-btn" style="
                                    background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
                                    border: none;
                                    color: white;
                                    padding: 10px;
                                    border-radius: 8px;
                                    cursor: pointer;
                                    font-size: 14px;
                                    font-weight: 500;
                                    transition: all 0.2s ease;
                                ">✨ 创建互动</button>
                            </div>
                        </div>
                    </div>
                `);
                
                // 输入框焦点效果
                panel.find('input, textarea').on('focus', function() {
                    $(this).css('border-color', '#f093fb');
                }).on('blur', function() {
                    $(this).css('border-color', '#ddd');
                });
                
                // 绑定事件
                panel.on('click', '.cancel-btn', function() {
                    panel.remove();
                });
                
                panel.on('click', '.create-btn', function() {
                    const title = panel.find('.space-title').val().trim();
                    const content = panel.find('.space-content').val().trim();
                    
                    if (!content) {
                        alert('请输入互动内容');
                        return;
                    }
                    
                    // 创建互动空间
                    const spaceId = 'space_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                    const timestamp = Date.now();
                    
                    QQ_InteractiveSpaces[spaceId] = {
                        id: spaceId,
                        title: title || `互动空间 #${Object.keys(QQ_InteractiveSpaces).length + 1}`,
                        content: content,
                        timestamp: timestamp,
                        characterName: '',
                        isMultiCharacter: true,
                        replies: []
                    };
                    
                    // *** 立即保存互动内容到世界书 ***
                    QQ_SaveInteractiveContentToWorldBook(content, null).then(interactiveId => {
                        console.log(`🎯 公共互动空间已立即保存到世界书，ID: ${interactiveId}`);
                    }).catch(error => {
                        console.error('保存公共互动空间失败:', error);
                    });
                    
                    // 同时保存到旧的互动空间存储（兼容性）
                    if (typeof QQ_Save_Interactive_Spaces === 'function') {
                        QQ_Save_Interactive_Spaces();
                    }
                    
                    console.log('✅ 公共互动空间创建成功:', spaceId);
                    
                    panel.remove();
                    
                    // 显示创建的互动空间
                    setTimeout(() => {
                        QQ_DisplayInteractiveSpace(spaceId, '公共互动空间');
                    }, 100);
                });
                
                // 回车快捷键
                panel.find('.space-content').on('keydown', function(e) {
                    if (e.ctrlKey && e.key === 'Enter') {
                        panel.find('.create-btn').click();
                    }
                });
                
                // 点击外部关闭
                $(document).one('click', function() {
                    panel.remove();
                });
                
                panel.on('click', function(e) {
                    e.stopPropagation();
                });
                
                $('body').append(panel);
                
                // 自动聚焦到标题输入框
                setTimeout(() => {
                    panel.find('.space-title').focus();
                }, 100);
            }
            
            /**
             * *** 新增：显示公共互动空间加载错误 ***
             * @param {string} errorMessage - 错误信息
             */
            function QQ_ShowPublicSpacesError(errorMessage) {
                // 移除加载界面
                $('.QQ_public_spaces_panel').remove();
                
                const errorPanel = $(`
                    <div class="QQ_public_spaces_panel" style="
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        background: white;
                        border-radius: 16px;
                        width: 85%;
                        max-width: 400px;
                        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
                        z-index: 10000;
                        overflow: hidden;
                        animation: slideIn 0.3s ease;
                    ">
                        <div class="panel-header" style="
                            background: linear-gradient(135deg, #ff6b6b 0%, #ffa726 100%);
                            color: white;
                            padding: 16px 20px;
                            text-align: center;
                        ">
                            <div style="
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                gap: 8px;
                                font-size: 16px;
                                font-weight: 600;
                            ">
                                <span style="font-size: 18px;">⚠️</span>
                                <span>加载失败</span>
                            </div>
                        </div>
                        
                        <div style="
                            padding: 30px 20px;
                            text-align: center;
                        ">
                            <div style="
                                font-size: 48px;
                                margin-bottom: 16px;
                                opacity: 0.6;
                            ">😵</div>
                            <div style="
                                font-size: 16px;
                                color: #333;
                                margin-bottom: 8px;
                                font-weight: 500;
                            ">互动记录加载失败</div>
                            <div style="
                                font-size: 12px;
                                color: #666;
                                line-height: 1.4;
                                margin-bottom: 20px;
                            ">${errorMessage || '未知错误'}<br/>
                            <small style="opacity: 0.7;">请检查世界书功能是否正常</small></div>
                            
                            <div style="
                                display: grid;
                                grid-template-columns: 1fr 1fr;
                                gap: 10px;
                            ">
                                <button class="retry-btn" style="
                                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                                    border: none;
                                    color: white;
                                    padding: 12px;
                                    border-radius: 8px;
                                    cursor: pointer;
                                    font-size: 14px;
                                    font-weight: 500;
                                    transition: all 0.2s ease;
                                ">🔄 重试</button>
                                
                                <button class="close-error-btn" style="
                                    background: #e9ecef;
                                    border: none;
                                    color: #666;
                                    padding: 12px;
                                    border-radius: 8px;
                                    cursor: pointer;
                                    font-size: 14px;
                                    font-weight: 500;
                                    transition: all 0.2s ease;
                                ">关闭</button>
                            </div>
                        </div>
                    </div>
                `);
                
                // 绑定事件
                errorPanel.on('click', '.retry-btn', function() {
                    errorPanel.remove();
                    // 重新尝试加载
                    setTimeout(() => {
                        QQ_ShowPublicInteractiveSpaces();
                    }, 100);
                });
                
                errorPanel.on('click', '.close-error-btn', function() {
                    errorPanel.remove();
                });
                
                // 点击背景关闭
                errorPanel.on('click', function(e) {
                    if (e.target === this) {
                        $(this).remove();
                    }
                });
                
                // 添加到页面
                $('body').append(errorPanel);
                
                // 显示错误提示
                toastr.error('加载公共互动空间失败', '错误');
            }
            
            // 确保函数全局可用
            window.QQ_ToggleUserMenu = QQ_ToggleUserMenu;
            window.QQ_GetUserName = QQ_GetUserName;
            window.QQ_ShowUserSpirit = QQ_ShowUserSpirit;
            window.QQ_ShowUserSpiritPanel = QQ_ShowUserSpiritPanel;
            window.QQ_ShowUserSettingsMenu = QQ_ShowUserSettingsMenu;
            window.QQ_ShowPhoneStatus = QQ_ShowPhoneStatus;
            window.QQ_SyncAllData = QQ_SyncAllData;
            window.QQ_ShowPublicInteractiveSpaces = QQ_ShowPublicInteractiveSpaces;
            window.QQ_CreatePublicInteractiveSpace = QQ_CreatePublicInteractiveSpace;
            window.QQ_ForceReloadInteractiveSpaces = QQ_ForceReloadInteractiveSpaces;
            window.QQ_ForceReloadContactGroups = QQ_ForceReloadContactGroups;
            window.QQ_ShowPublicSpacesError = QQ_ShowPublicSpacesError;
            
            // *** 保留核心功能函数，移除过期测试函数 ***
            window.QQ_ProcessSurpriseMechanism = QQ_ProcessSurpriseMechanism;
            window.QQ_ValidateInteractiveContent = QQ_ValidateInteractiveContent;
            window.QQ_CleanNestedTags = QQ_CleanNestedTags;
            window.QQ_CleanContentTags = QQ_CleanContentTags;
            window.QQ_HandleCharacterChat = QQ_HandleCharacterChat;
            window.QQ_SaveCharacterChatToWorldbook = QQ_SaveCharacterChatToWorldbook;
            window.QQ_Test_Smart_Content_Extraction = QQ_Test_Smart_Content_Extraction;

            /**
             * *** 新增：测试新的格式处理和重试逻辑 ***
             * 验证修复后的逻辑是否正确工作
             */
            window.QQ_Test_New_Format_Processing = function() {
                console.log('=== 测试新的格式处理和重试逻辑 ===');
                
                // 测试用例1：包含content标签但内容包含聊天标签
                const testCase1 = `
                    <content>
                        <群聊：测试群>
                            用户--12:30--这是一条测试消息
                            AI角色--12:31--这是AI的回复
                        </群聊：测试群>
                    </content>
                `;
                
                console.log('测试用例1: content包含聊天标签');
                const result1 = QQ_IsInteractiveContent(testCase1, true);
                console.log('结果:', result1 ? '❌ 错误识别为互动内容' : '✅ 正确识别为非互动内容');
                
                // 测试用例2：包含content标签但内容只是纯文本互动
                const testCase2 = `
                    <content>
                        *轻轻走向你，眼神中充满了温柔*
                        
                        我慢慢靠近，感觉到周围的氛围变得温馨。看到你的表情，我内心感到一阵暖流。
                        
                        *伸出手，想要触摸你的脸颊*
                    </content>
                `;
                
                console.log('测试用例2: content包含纯互动内容');
                const result2 = QQ_IsInteractiveContent(testCase2, true);
                console.log('结果:', result2 ? '✅ 正确识别为互动内容' : '❌ 错误识别为非互动内容');
                
                // 测试用例3：包含content标签但内容包含私聊标签
                const testCase3 = `
                    <content>
                        <用户和AI角色的私聊>
                            用户: 你好
                            AI角色: 你好，很高兴见到你
                        </用户和AI角色的私聊>
                    </content>
                `;
                
                console.log('测试用例3: content包含私聊标签');
                const result3 = QQ_IsInteractiveContent(testCase3, true);
                console.log('结果:', result3 ? '❌ 错误识别为互动内容' : '✅ 正确识别为非互动内容');
                
                // 测试用例4：包含content标签但内容是错误信息
                const testCase4 = `
                    <content>
                        错误：无法处理您的请求
                        系统出现了异常，请稍后重试
                    </content>
                `;
                
                console.log('测试用例4: content包含错误信息');
                const result4 = QQ_IsInteractiveContent(testCase4, true);
                console.log('结果:', result4 ? '❌ 错误识别为互动内容' : '✅ 正确识别为非互动内容');
                
                // 测试 QQ_CleanContentTags 函数
                console.log('\n=== 测试 QQ_CleanContentTags 函数 ===');
                const contentTest = QQ_CleanContentTags(testCase1);
                console.log('提取的content内容:', contentTest ? '✅ 成功提取' : '❌ 提取失败');
                
                console.log('\n=== 新格式处理逻辑测试完成 ===');
                console.log('✅ 修复要点:');
                console.log('   - AI没有回复线上格式时，会检查content中是否包含聊天标签');
                console.log('   - 只有content中没有任何聊天标签的纯互动内容才会被识别为互动内容');
                console.log('   - 包含聊天标签的content会通过格式提取处理，不会输出到新楼层');
                console.log('   - 既没有格式也没有互动内容时会重试，最多3次，不会输出到新楼层');
                
                triggerSlash('/echo ✅ 新格式处理逻辑测试完成，请查看控制台详细结果');
                
                return {
                    hasFormatTags: !result1 && !result3,
                    pureInteractive: result2,
                    errorHandling: !result4,
                    contentExtraction: !!contentTest
                };
            };
            
            /**
             * ===== 错误修复验证工具 =====
             */
            

            


            /**
             * ===== 动态点赞功能 =====
             */

            /**
             * 点赞动态
             * @param {string} momentId - 动态ID
             */
            window.QQ_LikeMoment = async function(momentId) {
                try {
                    console.log(`点赞动态: ${momentId}`);
                    
                    // 获取用户名
                    const userName = QQ_GetUserName();
                    if (!userName) {
                        console.warn('无法获取用户名，无法执行点赞操作');
                        return false;
                    }
                    
                    // 查找动态数据
                    const momentData = QQ_MomentsData.find(m => m.id === momentId);
                    if (!momentData) {
                        console.warn(`未找到动态数据: ${momentId}`);
                        return false;
                    }
                    
                    // 确保likes对象存在
                    if (!momentData.likes) {
                        momentData.likes = {
                            count: 0,
                            userLiked: false,
                            likedBy: [],
                            lastLikeTime: null
                        };
                    }
                    
                    // 切换点赞状态
                    const wasLiked = momentData.likes.userLiked;
                    if (wasLiked) {
                        // 取消点赞
                        momentData.likes.userLiked = false;
                        momentData.likes.count = Math.max(0, momentData.likes.count - 1);
                        momentData.likes.likedBy = momentData.likes.likedBy.filter(name => name !== userName);
                        momentData.likes.lastLikeTime = new Date().toISOString();
                        
                        console.log(`✅ 已取消点赞动态: ${momentId}`);
                    } else {
                        // 添加点赞
                        momentData.likes.userLiked = true;
                        momentData.likes.count += 1;
                        if (!momentData.likes.likedBy.includes(userName)) {
                            momentData.likes.likedBy.push(userName);
                        }
                        momentData.likes.lastLikeTime = new Date().toISOString();
                        
                        console.log(`✅ 已点赞动态: ${momentId}`);
                    }
                    
                    // 更新UI
                    QQ_UpdateLikeUI(momentId, momentData.likes);
                    
                    // 显示点赞提示
                    QQ_ShowLikePopup(momentId, !wasLiked, userName);
                    
                    // 保存到世界书
                    await QQ_Save_Moments();
                    console.log('点赞状态已保存到世界书');
                    
                    // 如果是点赞（非取消），记录用于AI反应
                    if (!wasLiked) {
                        await QQ_RecordLikeForAI(momentData, userName);
                    }
                    
                    return true;
                } catch (error) {
                    console.error('点赞操作失败:', error);
                    return false;
                }
            };

            /**
             * 更新点赞UI
             * @param {string} momentId - 动态ID
             * @param {Object} likes - 点赞数据
             */
            window.QQ_UpdateLikeUI = function(momentId, likes) {
                try {
                    const momentElement = $(`.user_moment[data-moment-id="${momentId}"]`);
                    if (momentElement.length === 0) {
                        console.warn(`未找到动态元素: ${momentId}`);
                        return;
                    }
                    
                    // 支持两种类型的点赞按钮
                    
                    // 类型1：Discord卡片中的.moment-like-button
                    const discordLikeButton = momentElement.find(`.moment-like-button[data-moment-id="${momentId}"]`);
                    const discordLikeCount = momentElement.find(`.moment-like-count`);
                    
                    if (discordLikeButton.length > 0) {
                        // Discord卡片样式更新
                        if (likes.userLiked) {
                            discordLikeButton.css('color', '#1677ff');
                            discordLikeButton.addClass('liked');
                        } else {
                            discordLikeButton.css('color', '#000000');
                            discordLikeButton.removeClass('liked');
                        }
                        discordLikeCount.text(likes.count);
                    }
                    
                    // 类型2：动态模板中的点赞结构（含👍的SVG部分）
                    const momentLikeSection = momentElement.find('span:contains("人已赞")').parent();
                    const momentLikeText = momentElement.find('span:contains("人已赞")');
                    
                    if (momentLikeText.length > 0) {
                        // 更新动态模板中的点赞文本
                        momentLikeText.text(`${likes.count}人已赞`);
                        
                        // 查找包含👍的SVG（通过path特征识别）
                        const thumbsUpSvg = momentElement.find('.moment_button svg').filter(function() {
                            const pathContent = $(this).find('path').attr('d');
                            return pathContent && pathContent.includes('471.411583');
                        });
                        
                        if (thumbsUpSvg.length > 0) {
                            const thumbPath = thumbsUpSvg.find('path');
                            if (likes.userLiked) {
                                // 点赞状态：蓝色 + 发光效果
                                thumbPath.attr('fill', '#1677ff');
                                thumbsUpSvg.css({
                                    'filter': 'drop-shadow(0 0 8px #1677ff)',
                                    'transform': 'scale(1.2)',
                                    'transition': 'all 0.3s ease',
                                    'cursor': 'pointer'
                                }).addClass('liked-thumb');
                                
                                // 添加脉冲动画
                                if (!thumbsUpSvg.hasClass('pulse-animation')) {
                                    thumbsUpSvg.addClass('pulse-animation');
                                    setTimeout(() => thumbsUpSvg.removeClass('pulse-animation'), 800);
                                }
                            } else {
                                // 未点赞状态：恢复原色
                                thumbPath.attr('fill', '#000000');
                                thumbsUpSvg.css({
                                    'filter': 'none',
                                    'transform': 'scale(1)',
                                    'transition': 'all 0.3s ease',
                                    'cursor': 'pointer'
                                }).removeClass('liked-thumb pulse-animation');
                            }
                        }
                        
                        // 处理用户已点赞提示
                        const userLikedTip = momentLikeText.next('.user-liked-tip');
                        if (likes.userLiked) {
                            if (userLikedTip.length === 0) {
                                // 添加用户已点赞提示
                                momentLikeText.after('<div class="user-liked-tip" style="color:#1677ff;font-size:11px;margin-top:2px;font-weight:500;">✓ 你已点赞</div>');
                            }
                        } else {
                            // 移除用户已点赞提示
                            userLikedTip.remove();
                        }
                    }
                    
                    console.log(`✅ 已更新动态 ${momentId} 的点赞UI: ${likes.count}人已赞, 用户已点赞: ${likes.userLiked}`);
                } catch (error) {
                    console.error('更新点赞UI失败:', error);
                }
            };

            /**
             * 显示点赞弹窗提示
             * @param {string} momentId - 动态ID
             * @param {boolean} isLike - 是否为点赞（true）还是取消点赞（false）
             * @param {string} userName - 用户名
             */
            window.QQ_ShowLikePopup = function(momentId, isLike, userName) {
                try {
                    const momentElement = $(`.user_moment[data-moment-id="${momentId}"]`);
                    const popup = momentElement.find('.moment-like-popup');
                    
                    if (isLike) {
                        popup.text(`${userName}已点赞`).show();
                    } else {
                        popup.text(`${userName}已取消点赞`).show();
                    }
                    
                    // 2秒后自动隐藏
                    setTimeout(() => {
                        popup.fadeOut(300);
                    }, 2000);
                } catch (error) {
                    console.error('显示点赞弹窗失败:', error);
                }
            };

            /**
             * 记录点赞信息供AI反应使用
             * @param {Object} momentData - 动态数据
             * @param {string} userName - 用户名
             */
            window.QQ_RecordLikeForAI = async function(momentData, userName) {
                try {
                    // 创建点赞记录
                    const likeRecord = {
                        type: 'moment_like',
                        momentId: momentData.id,
                        momentAuthor: momentData.userName,
                        momentContent: momentData.message.substring(0, 100), // 截取前100字符
                        likedBy: userName,
                        likeTime: new Date().toISOString(),
                        totalLikes: momentData.likes.count,
                        context: `用户"${userName}"对"${momentData.userName}"发布的动态进行了点赞。动态内容："${momentData.message.substring(0, 50)}${momentData.message.length > 50 ? '...' : ''}"。当前该动态共有${momentData.likes.count}人点赞。`
                    };
                    
                    // 保存到世界书用于AI反应
                    const result = await QQ_SafeSaveToWorldBook('点赞记录', likeRecord, 'QQ_点赞记录备份');
                    if (result) {
                        console.log('✅ 点赞记录已保存，AI可在下次对话中获取此信息');
                    }
                } catch (error) {
                    console.error('记录点赞信息失败:', error);
                }
            };

            /**
             * 初始化动态点赞功能
             */
            window.QQ_InitMomentLikes = function() {
                try {
                    // 类型1：绑定Discord卡片中的点赞按钮
                    $(document).off('click', '.moment-like-button').on('click', '.moment-like-button', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const momentId = $(this).data('moment-id');
                        if (momentId) {
                            QQ_LikeMoment(momentId);
                        }
                    });
                    
                    // 类型2：绑定动态模板中的👍点赞区域
                    $(document).off('click', '.moment_button svg').on('click', '.moment_button svg', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        // 查找动态ID - 向上查找包含data-moment-id的元素
                        const momentElement = $(this).closest('.user_moment[data-moment-id]');
                        const momentId = momentElement.data('moment-id');
                        
                        if (momentId) {
                            // 判断这是否是点赞按钮（通过路径内容或父元素判断）
                            const svgPath = $(this).find('path').attr('d');
                            // 检查是否是👍按钮（根据SVG path特征判断）
                            if (svgPath && svgPath.includes('471.411583')) { // 这是👍按钮的path特征
                                QQ_LikeMoment(momentId);
                            }
                        }
                    });
                    
                    // 类型3：直接绑定包含"人已赞"文本的区域
                    $(document).off('click', 'span:contains("人已赞")').on('click', 'span:contains("人已赞")', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const momentElement = $(this).closest('.user_moment[data-moment-id]');
                        const momentId = momentElement.data('moment-id');
                        
                        if (momentId) {
                            QQ_LikeMoment(momentId);
                        }
                    });
                    
                    console.log('✅ 动态点赞功能已初始化（支持多种点赞按钮类型）');
                } catch (error) {
                    console.error('初始化动态点赞功能失败:', error);
                }
            };

            /**
             * 加载已有动态的点赞状态
             */
            window.QQ_LoadMomentLikes = async function() {
                try {
                    if (!QQ_MomentsData || QQ_MomentsData.length === 0) {
                        return;
                    }
                    
                    const userName = QQ_GetUserName();
                    if (!userName) {
                        return;
                    }
                    
                    // 更新所有动态的点赞UI
                    for (const momentData of QQ_MomentsData) {
                        if (momentData.likes) {
                            QQ_UpdateLikeUI(momentData.id, momentData.likes);
                        }
                    }
                    
                    console.log('✅ 已加载动态点赞状态');
                } catch (error) {
                    console.error('加载动态点赞状态失败:', error);
                }
            };

            /**
             * 测试点赞功能
             */
            window.QQ_Test_Like_Function = function() {
                console.log('=== 测试动态点赞功能 ===');
                console.log('🔍 检查点赞功能状态...');
                
                // 检查数据结构
                if (typeof QQ_MomentsData === 'undefined' || QQ_MomentsData.length === 0) {
                    console.warn('⚠️ 没有动态数据可供测试');
                    return;
                }
                
                console.log(`✅ 找到 ${QQ_MomentsData.length} 条动态数据`);
                
                // 检查第一条动态的点赞数据
                const firstMoment = QQ_MomentsData[0];
                console.log('📊 第一条动态的点赞数据:', firstMoment.likes);
                
                // 检查UI元素
                const likeButtons = $('.moment-like-button');
                console.log(`🎯 找到 ${likeButtons.length} 个点赞按钮`);
                
                if (likeButtons.length > 0) {
                    const firstButton = likeButtons.first();
                    const momentId = firstButton.data('moment-id');
                    console.log(`🧪 测试点赞第一条动态: ${momentId}`);
                    
                    if (momentId) {
                        QQ_LikeMoment(momentId);
                    }
                } else {
                    console.warn('⚠️ 未找到点赞按钮，请确保页面已加载动态');
                }
                
                triggerSlash('/echo ✅ 点赞功能测试完成，请查看控制台详细结果');
            };

            /**
             * *** 新增：智能提取内容转换为标准格式函数 ***
             */
            window.QQ_ConvertExtractedToStandard = function(extractedInfo) {
                console.log('🔄 开始转换智能提取内容为标准格式...');
                
                if (!extractedInfo || !extractedInfo.hasValidInfo) {
                    console.log('❌ 提取信息无效，无法转换');
                    return null;
                }
                
                try {
                    const result = {};
                    
                    // 处理聊天消息
                    if (extractedInfo.messages && extractedInfo.messages.length > 0) {
                        console.log(`📝 处理 ${extractedInfo.messages.length} 条聊天消息`);
                        
                        // 分析聊天类型
                        let chatType = 'private'; // 默认私聊
                        let chatName = '';
                        
                        // 检查是否为群聊（支持中文和英文冒号）
                        if (extractedInfo.chatInfo && extractedInfo.chatInfo.includes('群聊')) {
                            chatType = 'group';
                            const groupMatch = extractedInfo.chatInfo.match(/群聊[：:]\s*(.+)/);
                            chatName = groupMatch ? groupMatch[1].trim() : '未知群聊';
                        } else if (extractedInfo.chatType === 'group') {
                            // 直接从chatType判断
                            chatType = 'group';
                            chatName = extractedInfo.chatName || '未知群聊';
                        } else if (extractedInfo.chatType === 'private') {
                            // 直接从chatType判断
                            chatType = 'private';
                            chatName = extractedInfo.chatName || '未知角色';
                        } else if (extractedInfo.chatInfo) {
                            // 私聊格式: "用户名和角色名的私聊/聊天"
                            const privateMatch = extractedInfo.chatInfo.match(/(.+?)和(.+?)的?(?:聊天|私聊)/);
                            if (privateMatch) {
                                // 判断哪个是用户名，哪个是角色名
                                const user1 = privateMatch[1].trim();
                                const user2 = privateMatch[2].trim();
                                
                                // 假设用户名包含在第一个位置，角色名在第二个位置
                                // 或者根据当前用户名判断
                                if (window.UserName && user1 === window.UserName) {
                                    chatName = user2; // 对方角色名
                                } else if (window.UserName && user2 === window.UserName) {
                                    chatName = user1; // 对方角色名
                                } else {
                                    chatName = user2; // 默认取第二个为角色名
                                }
                            } else {
                                // 尝试更简单的格式匹配 "用户名和角色名私聊"
                                const simpleMatch = extractedInfo.chatInfo.match(/(.+?)和(.+?)私聊/);
                                if (simpleMatch) {
                                    const user1 = simpleMatch[1].trim();
                                    const user2 = simpleMatch[2].trim();
                                    if (window.UserName && user1 === window.UserName) {
                                        chatName = user2;
                                    } else if (window.UserName && user2 === window.UserName) {
                                        chatName = user1;
                                    } else {
                                        chatName = user2;
                                    }
                                }
                            }
                        }
                        
                        console.log(`💬 聊天类型: ${chatType}, 聊天对象: ${chatName}`);
                        
                        // 构建标准格式
                        if (chatType === 'group') {
                            result.type = 'group';
                            result.groupName = chatName;
                            result.messages = extractedInfo.messages.map(msg => {
                                // 如果消息已经是对象格式（从QQ_ExtractMessagesFromContent返回）
                                if (typeof msg === 'object' && msg.name && msg.msg) {
                                    return {
                                        sender: msg.name,
                                        content: msg.msg,
                                        time: msg.time || new Date().toLocaleTimeString('zh-CN', { hour12: false }).substring(0, 5)
                                    };
                                }
                                
                                // 如果消息是字符串格式，尝试解析
                                if (typeof msg === 'string') {
                                    // 解析消息格式：角色名—内容—时间 或 角色名：内容
                                    const dashMatch = msg.match(/^(.+?)—(.+?)—(.+)$/);
                                    if (dashMatch) {
                                        return {
                                            sender: dashMatch[1].trim(),
                                            content: dashMatch[2].trim(),
                                            time: dashMatch[3].trim()
                                        };
                                    }
                                    
                                    const colonMatch = msg.match(/^(.+?)：(.+)$/);
                                    if (colonMatch) {
                                        return {
                                            sender: colonMatch[1].trim(),
                                            content: colonMatch[2].trim(),
                                            time: new Date().toLocaleTimeString('zh-CN', { hour12: false }).substring(0, 5)
                                        };
                                    }
                                }
                                
                                return null;
                            }).filter(msg => msg !== null);
                        } else {
                            result.type = 'private';
                            result.chatWith = chatName;
                            result.messages = extractedInfo.messages.map(msg => {
                                // 如果消息已经是对象格式（从QQ_ExtractMessagesFromContent返回）
                                if (typeof msg === 'object' && msg.name && msg.msg) {
                                    return {
                                        sender: msg.name,
                                        content: msg.msg,
                                        time: msg.time || new Date().toLocaleTimeString('zh-CN', { hour12: false }).substring(0, 5)
                                    };
                                }
                                
                                // 如果消息是字符串格式，尝试解析
                                if (typeof msg === 'string') {
                                    // 解析消息格式：角色名—内容—时间 或 角色名：内容
                                    const dashMatch = msg.match(/^(.+?)—(.+?)—(.+)$/);
                                    if (dashMatch) {
                                        return {
                                            sender: dashMatch[1].trim(),
                                            content: dashMatch[2].trim(),
                                            time: dashMatch[3].trim()
                                        };
                                    }
                                    
                                    const colonMatch = msg.match(/^(.+?)：(.+)$/);
                                    if (colonMatch) {
                                        return {
                                            sender: colonMatch[1].trim(),
                                            content: colonMatch[2].trim(),
                                            time: new Date().toLocaleTimeString('zh-CN', { hour12: false }).substring(0, 5)
                                        };
                                    }
                                }
                                
                                return null;
                            }).filter(msg => msg !== null);
                        }
                    }
                    
                    console.log('✅ 转换完成，结果:', result);
                    return result;
                    
                } catch (error) {
                    console.error('❌ 转换过程出错:', error);
                    return null;
                }
            };

            /**
             * *** 新增：MSG标签缺失问题的专门诊断工具 ***
             */
            window.QQ_Test_MSG_Tag_Issue = function() {
                console.log('=== 🔍 MSG标签缺失问题诊断 ===');
                
                // 模拟用户提供的实际内容格式（基于截图）
                const testContent = `MiPhone_JSON_START
<阿伟和可畏的私聊>
可畏—你，你这个笨蛋！准备你抱了！—11:21
可畏—Gab—气呼呼！—11:21  
可畏—我才没有期待！只是觉得你的说法很，很不知道呢！—11:22
可畏—当然了，不过虽然我们现在外面也这么私密说话，我觉得你的想想亲！—11:22
可畏—tyy—不过......如果你真的那么想的话，也不是......不可以考虑一下。!—11:23
</阿伟和可畏的私聊>
<阿伟和圣路易斯的私聊>
圣路易斯—呜呜，想抱紧我，让我动弹不得？—11:21
圣路易斯—有意思的挑战。不过，你确定你有这个能力吗，我的指挥官？—11:21
圣路易斯—别告诉你先动弹不得的，是你自己。—11:22
圣路易斯—图片<img src="https://files.catbox.moe/viewm.jpg" alt="光辉" title="光辉" style="width: 100%; height: auto;">！—11:22
圣路易斯—不过如果你的表现的，今晚，关我的房间，让我去身"检验"一下你的决心和力量吧。呵呵......—11:23
</阿伟和圣路易斯的私聊>
<群聊：港区>
可畏—喂，圣路易斯说。—11:21
可畏—别以为指挥官发了什么照片？—11:21
可畏—别以为没有看到，那么嚣张的呢礼服，简直不知廉耻！—11:22
圣路易斯—呜呜，可畏妹妹，是在重复提问自己最美的一面。这可不是"不知廉耻"，而是成熟女性的魅力。—11:23
圣路易斯—呯呯，指挥官似乎得各喜欢呢。不像某些人，只会用呻吟的音乐来吸引注意力。—11:23
可畏—你！你明说！抽落是这个！是灵魂的呐喊！才不是呻吟！—11:24
可畏—而且，我才没有嫉妒！我只是觉得，你不应该用这种方式来"勾引"指挥官！—11:25
圣路易斯—呜呜，是不是勾引，得由指挥官来判断呢。—11:25
圣路易斯—不过既然你这么有你的反应，有关我的方法权有效呢，亲爱的小可畏关心了，可畏姑娘。—11:26
可畏—呸！—11:26
</群聊：港区>
moment_start
可畏发了一条动态，表示感慨，请浏览 35—已点赞 10
moment_end
MiPhone_JSON_END`;

                console.log('\n📋 测试内容长度:', testContent.length);
                console.log('\n🔍 第一步：检查格式匹配');
                
                // 检查格式匹配
                const formatPatterns = [
                    /MiPhone_start([\s\S]+?)MiPhone_end/g,           // 标准格式
                    /MiPhone_JSON_START([\s\S]+?)MiPhone_JSON_END/g, // JSON格式
                    /MiPhone_JSON_start([\s\S]+?)MiPhone_JSON_end/g, // 混合格式1
                    /MiPhone_Start([\s\S]+?)MiPhone_End/g,           // 首字母大写
                    /MiPhone_START([\s\S]+?)MiPhone_END/g,           // 全大写
                    // 不完整格式支持
                    /MiPhone_JSON_START([\s\S]+?)$/g,                // 不完整JSON格式
                    /MiPhone_start([\s\S]+?)$/g,                     // 不完整标准格式
                    /MiPhone_Start([\s\S]+?)$/g,                     // 不完整首字母大写格式
                    /MiPhone_START([\s\S]+?)$/g,                     // 不完整全大写格式
                ];
                
                let matches = [];
                let matchedPattern = null;
                for (const pattern of formatPatterns) {
                    const currentMatches = [...testContent.matchAll(pattern)];
                    if (currentMatches.length > 0) {
                        matches = currentMatches;
                        matchedPattern = pattern;
                        console.log(`✅ 找到格式匹配 (${pattern.source.substring(0, 30)}...): ${currentMatches.length} 个`);
                        break;
                    }
                }
                
                if (matches.length === 0) {
                    console.log('❌ 格式匹配失败');
                    return;
                }
                
                const extractedContent = matches[0][1];
                console.log('\n📝 提取的内容长度:', extractedContent.length);
                console.log('📝 提取的内容预览:', extractedContent.substring(0, 200) + '...');
                
                console.log('\n🔍 第二步：检查MSG标签');
                const hasMsgStart = extractedContent.indexOf("msg_start") >= 0;
                const hasMsgEnd = extractedContent.indexOf("msg_end") >= 0;
                console.log(`msg_start 存在: ${hasMsgStart}`);
                console.log(`msg_end 存在: ${hasMsgEnd}`);
                
                if (!hasMsgStart || !hasMsgEnd) {
                    console.log('\n⚠️ 发现问题：缺少MSG标签');
                    
                    console.log('\n🔧 第三步：尝试自动补全MSG标签');
                    let fixedContent = extractedContent;
                    
                    if (!hasMsgStart) {
                        // 寻找聊天开始标签（优化正则表达式）
                        const start = fixedContent.match(
                            /<(群聊:.+?|[^>]+和[^>]+的(?:聊天|私聊))>/
                        );
                        if (start) {
                            console.log(`找到聊天开始标签: ${start[0]}`);
                            fixedContent = fixedContent.replace(
                                start[0],
                                `msg_start\n${start[0]}`
                            );
                        } else {
                            console.log('❌ 未找到合适的聊天开始标签');
                        }
                    }
                    
                    if (!hasMsgEnd) {
                        // 寻找聊天结束标签（优化正则表达式）
                        const endMatches = [...fixedContent.matchAll(
                            /<\/(群聊:.+?|[^>]+和[^>]+的(?:聊天|私聊))>/g
                        )];
                        if (endMatches.length > 0) {
                            const lastEnd = endMatches[endMatches.length - 1][0];
                            console.log(`找到聊天结束标签: ${lastEnd}`);
                            fixedContent = fixedContent.replace(
                                lastEnd,
                                `${lastEnd}\nmsg_end`
                            );
                        } else {
                            console.log('❌ 未找到合适的聊天结束标签');
                        }
                    }
                    
                    console.log('\n✅ 修复后的内容预览:');
                    console.log(fixedContent.substring(0, 300) + '...');
                    
                    console.log('\n🔍 第四步：验证修复后的MSG解析');
                    const msgMatch = fixedContent.match(/msg_start([\s\S]+?)msg_end/);
                    if (msgMatch) {
                        console.log('✅ MSG解析成功');
                        console.log('MSG内容长度:', msgMatch[1].length);
                        console.log('MSG内容预览:', msgMatch[1].substring(0, 200) + '...');
                        
                        // 尝试解析YAML/JSON
                        try {
                            const parsed = JsonYamlParse(msgMatch[1]);
                            if (parsed) {
                                console.log('✅ YAML/JSON解析成功');
                                console.log('解析结果类型:', Array.isArray(parsed) ? 'Array' : typeof parsed);
                                if (Array.isArray(parsed)) {
                                    console.log('消息数量:', parsed.length);
                                }
                            } else {
                                console.log('❌ YAML/JSON解析失败：返回null');
                            }
                        } catch (error) {
                            console.log('❌ YAML/JSON解析异常:', error.message);
                        }
                    } else {
                        console.log('❌ MSG解析仍然失败');
                    }
                }
                
                console.log('\n🔍 第五步：测试智能提取备用方案');
                const extractedInfo = QQ_ExtractValidInfo(extractedContent);
                console.log('智能提取结果:', extractedInfo);
                
                if (extractedInfo.hasValidInfo) {
                    console.log('\n🔄 第六步：测试智能提取内容转换');
                    const convertedResult = QQ_ConvertExtractedToStandard(extractedInfo);
                    if (convertedResult) {
                        console.log('✅ 转换成功，可以直接处理');
                        console.log('转换结果预览:', JSON.stringify(convertedResult, null, 2).substring(0, 500) + '...');
                        
                        console.log('\n🎯 第七步：模拟直接处理流程');
                        console.log('如果实际运行，将直接调用 QQ_Msg_Parse 处理转换后的内容');
                        console.log('跳过MSG标签处理，避免自动补全失败问题');
                    } else {
                        console.log('❌ 智能提取内容转换失败');
                    }
                } else {
                    console.log('❌ 智能提取未发现有效内容');
                }
                
                console.log('\n🔍 第八步：测试动态提取');
                const momentMatches = extractedContent.match(/moment_start([\s\S]*?)moment_end/g);
                console.log(`动态匹配结果: ${momentMatches ? momentMatches.length : 0} 个`);
                if (momentMatches) {
                    momentMatches.forEach((match, index) => {
                        console.log(`动态${index + 1}: ${match.substring(0, 100)}...`);
                    });
                }
                
                return {
                    description: 'MSG标签缺失问题诊断完成',
                    formatMatched: matches.length > 0,
                    msgTagsPresent: hasMsgStart && hasMsgEnd,
                    extractedContentLength: extractedContent.length,
                    intelligentExtractionResult: extractedInfo.hasValidInfo,
                    momentCount: momentMatches ? momentMatches.length : 0
                };
            };
            
            // *** 消息清理功能 ***
            // QQ_CleanMessageContent已合并到QQ_CleanNestedTags，使用QQ_CleanNestedTags替代
            
            // *** 已移除复杂的世界书初始化逻辑，改为简单的直接检查方式 ***
            
            /**
             * *** 新增：简化的数据管理使用说明 ***
             */
            window.QQ_ShowDataManagerHelp = function() {
                console.log('=== 📚 SillyTavern手机前端数据管理工具使用说明 ===');
                console.log('');
                console.log('🔧 主要功能：');
                console.log('• QQ_DataManager.showStats() - 显示所有数据统计');
                console.log('• QQ_DataManager.saveAll() - 手动保存所有数据');
                console.log('• QQ_DataManager.optimizeData() - 清理和优化数据');
                console.log('• QQ_DataManager.testWorldBook() - 测试世界书功能');
                console.log('');
                console.log('🧹 消息清理：');
                console.log('• QQ_CleanNestedTags(text) - 清理消息中的HTML注释、嵌套标签和思考内容');
                console.log('');
                console.log('🎯 互动内容：');
                console.log('• QQ_ProcessSurpriseMechanism(text) - 处理互动机制验证');
                console.log('• QQ_ValidateInteractiveContent(text) - 验证互动内容质量');
                console.log('');
                console.log('📊 数据存储机制：');
                console.log('• 动态数据：自动保存到世界书，最多200条');
                console.log('• 分组数据：按角色保存，支持联系人分组管理');
                console.log('• 互动内容：按角色分类保存，最多30个项目');
                console.log('');
                console.log('🔄 更新机制：');
                console.log('• 所有数据都通过统一的世界书API进行保存和加载');
                console.log('• 自动清理过期和冗余数据，保持性能优化');
                console.log('• 支持跨角色的数据管理和备份');
                console.log('');
                console.log('=== 使用示例 ===');
                console.log('QQ_DataManager.showStats(); // 查看当前数据统计');
                console.log('await QQ_DataManager.saveAll(); // 保存所有数据');
                console.log('QQ_CleanNestedTags("消息内容<!--consider: 思考-->"); // 清理消息和嵌套标签');
                console.log('');
                console.log('🔧 故障排除：');
                console.log('• 如果出现"世界书功能不可用"错误：');
                console.log('  1. 等待3-5秒让SillyTavern完全加载');
                console.log('  2. 刷新页面重新加载');
                console.log('  3. 检查SillyTavern是否正常运行');
                console.log('');
                console.log('✅ 如需技术支持，请查看控制台日志或联系开发者');
            };
            
            /**
             * *** 新增：错误检查和调试函数 ***
             */
            window.QQ_Check_Errors = function() {
                console.log('=== 🔍 错误检查开始 ===');
                
                const results = {
                    momentsDataCheck: false,
                    functionsCheck: false,
                    nextVariableCheck: false,
                    arrayOperationsCheck: false,
                    groupsDataCheck: false
                };
                
                try {
                    // 检查QQ_MomentsData
                    if (typeof QQ_MomentsData !== 'undefined' && Array.isArray(QQ_MomentsData)) {
                        console.log('✅ QQ_MomentsData 已正确定义，类型为数组，长度:', QQ_MomentsData.length);
                        results.momentsDataCheck = true;
                    } else {
                        console.warn('⚠️ QQ_MomentsData 未定义或不是数组:', typeof QQ_MomentsData);
                    }
                    
                    // 检查群聊相关数据
                    console.log('🧪 检查群聊数据结构...');
                    if (typeof loadGroupsFromStorage === 'function') {
                        console.log('✅ loadGroupsFromStorage 函数已定义');
                        try {
                            const groupsResult = loadGroupsFromStorage();
                            if (groupsResult && typeof groupsResult.then === 'function') {
                                // 如果返回Promise
                                groupsResult.then(groups => {
                                    if (groups && Array.isArray(groups)) {
                                        console.log('✅ 群聊数据加载正常，数量:', groups.length);
                                    } else {
                                        console.warn('⚠️ 群聊数据无效:', groups);
                                    }
                                }).catch(e => {
                                    console.warn('⚠️ 群聊数据加载失败:', e);
                                });
                            } else if (Array.isArray(groupsResult)) {
                                // 如果直接返回数组
                                console.log('✅ 群聊数据加载正常（同步），数量:', groupsResult.length);
                            } else {
                                console.warn('⚠️ loadGroupsFromStorage 返回值无效:', typeof groupsResult);
                            }
                        } catch (e) {
                            console.warn('⚠️ 群聊数据同步检查失败:', e);
                        }
                        results.groupsDataCheck = true;
                    } else {
                        console.warn('⚠️ loadGroupsFromStorage 函数未定义');
                    }
                    
                    // 检查关键函数
                    const functionList = ['QQ_Save_Moments', 'QQ_CleanOldMoments', 'QQ_OptimizeCommentsStorage', 'QQ_SendMsg', 'updateGroupLastMessageDisplay'];
                    let allFunctionsExist = true;
                    functionList.forEach(funcName => {
                        if (typeof window[funcName] === 'function') {
                            console.log(`✅ ${funcName} 函数已定义`);
                        } else {
                            console.warn(`⚠️ ${funcName} 函数未定义`);
                            allFunctionsExist = false;
                        }
                    });
                    results.functionsCheck = allFunctionsExist;
                    
                    // 检查是否有未定义的next变量引用
                    try {
                        if (typeof next !== 'undefined') {
                            console.log('⚠️ 检测到全局next变量:', next);
                        } else {
                            console.log('✅ 没有检测到全局next变量（这是正常的）');
                            results.nextVariableCheck = true;
                        }
                    } catch (e) {
                        console.log('✅ next变量未定义（这是预期的）');
                        results.nextVariableCheck = true;
                    }
                    
                    // 测试数组操作安全性
                    console.log('🧪 测试数组操作安全性...');
                    if (QQ_MomentsData && Array.isArray(QQ_MomentsData)) {
                        try {
                            let testCount = 0;
                            QQ_MomentsData.forEach(moment => {
                                testCount++;
                            });
                            console.log(`✅ QQ_MomentsData.forEach 操作正常，遍历了 ${testCount} 个元素`);
                            results.arrayOperationsCheck = true;
                        } catch (e) {
                            console.error('❌ QQ_MomentsData.forEach 操作失败:', e);
                        }
                    } else {
                        console.log('⚠️ 跳过数组操作测试，因为QQ_MomentsData不可用');
                    }
                    
                    // 测试清理函数
                    console.log('🧪 测试清理函数...');
                    try {
                        if (typeof QQ_CleanOldMoments === 'function') {
                            QQ_CleanOldMoments();
                            console.log('✅ QQ_CleanOldMoments 函数执行正常');
                        }
                        if (typeof QQ_OptimizeCommentsStorage === 'function') {
                            QQ_OptimizeCommentsStorage();
                            console.log('✅ QQ_OptimizeCommentsStorage 函数执行正常');
                        }
                    } catch (e) {
                        console.error('❌ 清理函数测试失败:', e);
                    }
                    
                    // 添加错误监听器来捕获运行时错误
                    window.addEventListener('error', function(e) {
                        if (e.message.includes('next is not defined')) {
                            console.error('🚨 捕获到next未定义错误:', e);
                            console.error('错误位置:', e.filename, '行号:', e.lineno);
                            console.error('错误堆栈:', e.error ? e.error.stack : '无堆栈信息');
                        }
                    });
                    
                } catch (error) {
                    console.error('❌ 错误检查过程中出现异常:', error);
                }
                
                console.log('=== 📊 错误检查结果 ===', results);
                console.log('=== ✅ 错误检查完成 ===');
                
                // 显示结果
                const passedTests = Object.values(results).filter(Boolean).length;
                const totalTests = Object.keys(results).length;
                triggerSlash(`/echo 🔍 错误检查完成: ${passedTests}/${totalTests} 项检查通过`);
                
                return results;
            };
            
            /**
             * *** 新增：专门检查QQ_SendMsg函数的错误 ***
             */
            window.QQ_Debug_SendMsg = function() {
                console.log('=== 🔧 QQ_SendMsg 调试开始 ===');
                
                try {
                    // 检查QQ_SendMsg函数定义
                    if (typeof QQ_SendMsg === 'function') {
                        console.log('✅ QQ_SendMsg 函数已定义');
                        
                        // 获取函数源码并检查是否有next引用
                        const funcStr = QQ_SendMsg.toString();
                        if (funcStr.includes('next(') || funcStr.includes('next;')) {
                            console.warn('⚠️ QQ_SendMsg 函数中可能包含next变量引用');
                            
                            // 尝试找到next引用的位置
                            const lines = funcStr.split('\n');
                            lines.forEach((line, index) => {
                                if (line.includes('next') && !line.includes('.next(')) {
                                    console.warn(`⚠️ 第${index + 1}行可能有问题: ${line.trim()}`);
                                }
                            });
                        } else {
                            console.log('✅ QQ_SendMsg 函数中未发现直接的next变量引用');
                        }
                    } else {
                        console.error('❌ QQ_SendMsg 函数未定义');
                        return;
                    }
                    
                } catch (error) {
                    console.error('❌ QQ_SendMsg 调试过程中出现异常:', error);
                }
                
                console.log('=== ✅ QQ_SendMsg 调试完成 ===');
            };
            
            /**
             * *** 新增：修复QQ_Gen回调函数问题 ***
             */
            window.QQ_Fix_Next_Error = function() {
                console.log('=== 🔧 修复QQ_Gen回调函数问题开始 ===');
                
                try {
                    // 检查QQ_Gen函数是否正确支持回调
                    if (typeof QQ_Gen === 'function') {
                        const funcStr = QQ_Gen.toString();
                        if (funcStr.includes('callback')) {
                            console.log('✅ QQ_Gen函数已正确支持回调参数');
                        } else {
                            console.warn('⚠️ QQ_Gen函数可能不支持回调参数');
                        }
                    }
                    
                    // 验证测试一个简单的QQ_Gen调用
                    console.log('🧪 测试QQ_Gen回调功能...');
                    if (typeof QQ_Gen === 'function') {
                        QQ_Gen('测试提示词', function(response) {
                            console.log('✅ QQ_Gen回调测试成功，收到响应:', response ? '有响应' : '无响应');
                        }).catch(error => {
                            console.warn('⚠️ QQ_Gen回调测试失败:', error);
                        });
                    }
                    
                } catch (error) {
                    console.error('❌ 修复QQ_Gen回调函数问题过程中出现异常:', error);
                }
                
                console.log('=== ✅ 修复QQ_Gen回调函数问题完成 ===');
            };
            


            /**
             * *** 新增：页面加载完成后的轻量化初始化流程 ***
             */
            $(document).ready(function() {
                console.log('📱 SillyTavern手机前端界面已加载完成！');
                console.log('💡 可用工具：');
                console.log('  • QQ_DataManager.showStats() - 查看数据统计');
                console.log('  • QQ_ShowDataManagerHelp() - 查看使用说明');
                console.log('  • QQ_Check_Errors() - 检查系统状态');
            });
            
            /**
             * *** 新增：清理重复的私聊群组 ***
             */
            window.QQ_CleanDuplicatePrivateChats = function() {
                console.log('🧹 开始清理重复的私聊群组...');
                
                try {
                    // 获取世界书中的群聊数据
                    const worldInfo = getWorldInfoSettings();
                    let hasChanges = false;
                    
                    if (worldInfo && worldInfo.entries) {
                        const duplicateGroups = [];
                        const seenChats = new Set();
                        
                        worldInfo.entries.forEach((entry, index) => {
                            if (entry.key && entry.key.includes('QQ_GroupChats_')) {
                                try {
                                    const data = JSON.parse(entry.content);
                                    
                                    // 检查是否有重复的私聊格式
                                    Object.keys(data).forEach(chatKey => {
                                        const normalizedKey = chatKey.replace('私聊', '聊天');
                                        
                                        if (chatKey !== normalizedKey && seenChats.has(normalizedKey)) {
                                            console.log(`🔍 发现重复私聊: "${chatKey}" 和 "${normalizedKey}"`);
                                            duplicateGroups.push({
                                                entryIndex: index,
                                                originalKey: chatKey,
                                                normalizedKey: normalizedKey,
                                                entry: entry
                                            });
                                        } else {
                                            seenChats.add(normalizedKey);
                                        }
                                    });
                                } catch (e) {
                                    console.warn('⚠️ 解析群聊数据失败:', entry.key, e);
                                }
                            }
                        });
                        
                        // 清理重复的条目
                        if (duplicateGroups.length > 0) {
                            console.log(`🗑️ 准备清理 ${duplicateGroups.length} 个重复群组`);
                            
                            duplicateGroups.forEach(duplicate => {
                                console.log(`删除重复群组: ${duplicate.originalKey}`);
                                // 这里可以选择删除或合并数据
                                // 为安全起见，我们先标记而不是直接删除
                                duplicate.entry.comment = `[待清理] 重复的私聊群组: ${duplicate.originalKey}`;
                                hasChanges = true;
                            });
                            
                            if (hasChanges) {
                                console.log('💾 保存清理后的世界书数据...');
                                saveWorldInfo(worldInfo);
                                console.log('✅ 重复群组清理完成！');
                                toastr.success(`已标记 ${duplicateGroups.length} 个重复群组待清理`, '数据清理');
                            }
                        } else {
                            console.log('✅ 未发现重复的私聊群组');
                            toastr.info('未发现重复的私聊群组', '数据清理');
                        }
                    }
                    
                } catch (error) {
                    console.error('❌ 清理重复群组时出错:', error);
                    toastr.error('清理过程中出现错误', '数据清理');
                }
            };
            
            /**
             * *** 新增：调试分组数据存储状况 ***
             */
            window.QQ_Debug_Group_Storage = function() {
                try {
                    const charId = getCurrentCharacterId() || 'default';
                    const expectedComment = `QQ_分组备份_${charId}`;
                    
                    console.log('=== 分组数据存储调试 ===');
                    console.log(`当前角色ID: ${charId}`);
                    console.log(`期望的世界书条目名: ${expectedComment}`);
                    console.log(`内存中的分组数量: ${contactGroups.length}`);
                    
                    if (!worldbook || !entries) {
                        console.log('❌ 世界书功能不可用');
                        return;
                    }
                    
                    // 查找所有分组相关的条目
                    const groupEntries = entries.filter(entry => 
                        entry.comment && entry.comment.includes('QQ_分组备份')
                    );
                    
                    console.log(`找到 ${groupEntries.length} 个分组相关条目:`);
                    groupEntries.forEach(entry => {
                        console.log(`- 条目名: ${entry.comment}`);
                        console.log(`- UID: ${entry.uid}`);
                        try {
                            const data = JSON.parse(entry.content);
                            const groups = data.content || [];
                            console.log(`- 分组数量: ${groups.length}`);
                            if (groups.length > 0) {
                                console.log(`- 分组详情: ${groups.map(g => g.name).join(', ')}`);
                            }
                        } catch (e) {
                            console.log(`- 解析失败: ${e.message}`);
                        }
                        console.log('---');
                    });
                    
                    // 尝试直接加载指定条目
                    const targetEntry = entries.find(entry => entry.comment === expectedComment);
                    if (targetEntry) {
                        console.log(`✅ 找到目标条目: ${expectedComment}`);
                        try {
                            const data = JSON.parse(targetEntry.content);
                            const groups = data.content || [];
                            console.log(`目标条目中的分组数量: ${groups.length}`);
                            if (groups.length > 0) {
                                console.log(`目标条目分组详情: ${groups.map(g => g.name).join(', ')}`);
                            }
                        } catch (e) {
                            console.log(`❌ 目标条目解析失败: ${e.message}`);
                        }
                    } else {
                        console.log(`❌ 未找到目标条目: ${expectedComment}`);
                    }
                    
                } catch (error) {
                    console.error('调试分组存储失败:', error);
                }
            };
            
            /**
             * *** 新增：测试角色间私聊和AI群聊保存功能 ***
             * 验证新功能是否正常工作
             */
            window.QQ_Test_Character_Chat_And_AI_Groups = function() {
                console.log('=== 测试角色间私聊和AI群聊保存功能 ===');
                
                // 测试1：角色间私聊功能
                console.log('\n1. 测试角色间私聊功能:');
                const testChatData = {
                    id: 'char_chat_test_Alice_Bob',
                    title: 'Alice和Bob的私聊',
                    char1: 'Alice',
                    char2: 'Bob',
                    messages: [
                        'Alice--你好Bob！--14:30',
                        'Bob--嗨Alice，最近怎么样？--14:31',
                        'Alice--还不错，你呢？--14:32'
                    ],
                    lastTime: '14:32',
                    lastMessage: '还不错，你呢？'
                };
                
                try {
                    QQ_CreateCharacterChatInterface(testChatData);
                    console.log('✅ 角色间私聊界面创建成功');
                    
                    // 添加测试数据到全局变量
                    if (!window.QQ_CharacterChats) {
                        window.QQ_CharacterChats = {};
                    }
                    window.QQ_CharacterChats['Alice和Bob的聊天'] = testChatData;
                    
                } catch (error) {
                    console.error('❌ 角色间私聊界面创建失败:', error);
                }
                
                // 测试2：角色间私聊保存到世界书
                console.log('\n2. 测试角色间私聊保存功能:');
                QQ_SaveCharacterChatToWorldbook(testChatData).then(result => {
                    if (result) {
                        console.log('✅ 角色间私聊保存到世界书成功');
                    } else {
                        console.log('❌ 角色间私聊保存到世界书失败');
                    }
                }).catch(error => {
                    console.error('❌ 角色间私聊保存到世界书出错:', error);
                });
                
                // 测试3：AI群聊数据结构验证
                console.log('\n3. 测试AI群聊数据结构:');
                const testGroupData = {
                    id: `group_test_${Date.now()}`,
                    name: '测试AI创建群聊',
                    members: ['Alice', 'Bob', 'Charlie'],
                    avatar: {
                        type: 'preset',
                        gradient: {
                            start: '#199AFF',
                            end: '#0066CC'
                        },
                        text: '群'
                    },
                    lastMessage: '群聊已创建',
                    lastTime: new Date().toLocaleTimeString('zh-CN', { hour12: false }).slice(0, 5),
                    timestamp: new Date().toLocaleTimeString('zh-CN', { hour12: false }).slice(0, 5)
                };
                
                if (typeof saveGroupToWorldbook === 'function') {
                    console.log('✅ saveGroupToWorldbook 函数存在');
                    console.log('测试群聊数据:', testGroupData);
                    
                    // 测试保存功能（如果世界书可用）
                    if (worldbook && entries) {
                        saveGroupToWorldbook(testGroupData).then(result => {
                            if (result) {
                                console.log('✅ AI群聊保存测试成功');
                            } else {
                                console.log('❌ AI群聊保存测试失败');
                            }
                        }).catch(error => {
                            console.error('❌ AI群聊保存测试出错:', error);
                        });
                    } else {
                        console.log('⚠️ 世界书不可用，跳过保存测试');
                    }
                } else {
                    console.error('❌ saveGroupToWorldbook 函数不存在');
                }
                
                // 测试4：数据结构检查
                console.log('\n4. 检查全局数据结构:');
                console.log('window.QQ_CharacterChats:', window.QQ_CharacterChats || '未初始化');
                
                // 测试5：功能可用性检查
                console.log('\n5. 功能可用性检查:');
                const functions = [
                    'QQ_HandleCharacterChat',
                    'QQ_CreateCharacterChatInterface', 
                    'QQ_ShowCharacterChatDialog',
                    'QQ_SaveCharacterChatToWorldbook'
                ];
                
                functions.forEach(funcName => {
                    if (typeof window[funcName] === 'function') {
                        console.log(`✅ ${funcName} 函数可用`);
                    } else {
                        console.log(`❌ ${funcName} 函数不可用`);
                    }
                });
                
                // 测试6：模拟AI输出的角色间私聊
                console.log('\n6. 测试模拟AI输出处理:');
                const mockAIOutput = `
                {
                    "私聊": {
                        "可畏和圣路易斯的聊天": [
                            "可畏--你这个笨蛋！--14:30",
                            "圣路易斯--呵呵，可畏真可爱呢--14:31"
                        ]
                    },
                    "群聊": {}
                }
                `;
                
                try {
                    const testData = JSON.parse(mockAIOutput);
                    console.log('✅ 模拟AI输出解析成功');
                    
                    // 检查是否会触发角色间私聊处理
                    for (let str in testData.私聊) {
                        const match = str.match(/(.+?)和(.+?)的聊天/);
                        if (match) {
                            const char1 = match[1];
                            const char2 = match[2];
                            if (char1 !== '${UserName}' && char2 !== '${UserName}') {
                                console.log(`✅ 检测到角色间私聊: ${char1} 和 ${char2}`);
                                console.log('  消息数量:', testData.私聊[str].length);
                            }
                        }
                    }
                } catch (error) {
                    console.error('❌ 模拟AI输出解析失败:', error);
                }
                
                console.log('\n=== 测试完成 ===');
                console.log('📖 使用说明:');
                console.log('- 角色间私聊会显示在联系人列表中，带有紫色💬图标和"只读"标签');
                console.log('- 点击角色间私聊可查看完整对话历史');
                console.log('- AI创建的新群聊会自动保存到世界书');
                console.log('- 所有数据都会持久化存储');
                console.log('- 使用 window.QQ_CharacterChats 查看当前角色间私聊数据');
                
                return {
                    success: true,
                    testCount: 6,
                    features: [
                        '角色间私聊界面创建',
                        '角色间私聊数据保存',
                        'AI群聊自动保存',
                        '数据结构管理',
                        '功能可用性验证',
                        'AI输出处理测试'
                    ]
                };
            };
            
            /**
             * *** 新增：快速创建测试角色间私聊 ***
             * 用于快速测试界面效果
             */
            window.QQ_Create_Test_Character_Chat = function(char1 = 'Alice', char2 = 'Bob') {
                console.log(`创建测试角色间私聊: ${char1} 和 ${char2}`);
                
                const testMessages = [
                    `${char1}--你好${char2}！--${new Date().toLocaleTimeString('zh-CN', { hour12: false }).slice(0, 5)}`,
                    `${char2}--嗨${char1}，最近怎么样？--${new Date().toLocaleTimeString('zh-CN', { hour12: false }).slice(0, 5)}`,
                    `${char1}--还不错，你呢？--${new Date().toLocaleTimeString('zh-CN', { hour12: false }).slice(0, 5)}`
                ];
                
                return QQ_HandleCharacterChat(
                    `${char1}和${char2}的聊天`,
                    testMessages,
                    char1,
                    char2
                );
            };
            
            /**
             * *** 新增：测试优化后的互动空间加载时机 ***
             * 验证精灵面板预加载功能和公共互动空间的加载时机
             */
            window.QQ_Test_Optimized_Interactive_Loading = function() {
                console.log('=== 🚀 测试优化后的互动空间加载时机 ===');
                
                try {
                    // 1. 测试预加载状态
                    console.log('\n📊 1. 检查预加载状态:');
                    const preloadedCount = window.QQ_PreloadedCharacters ? window.QQ_PreloadedCharacters.size : 0;
                    console.log(`- 已预加载角色数量: ${preloadedCount}`);
                    if (window.QQ_PreloadedCharacters && preloadedCount > 0) {
                        console.log(`- 已预加载角色列表:`, Array.from(window.QQ_PreloadedCharacters));
                    }
                    
                    // 2. 测试公共空间缓存
                    console.log('\n🌐 2. 检查公共互动空间数据:');
                    const publicSpaceCount = QQ_InteractiveSpaces ? Object.keys(QQ_InteractiveSpaces).length : 0;
                    console.log(`- 公共互动空间数量: ${publicSpaceCount}`);
                    
                    // 3. 测试角色专属空间
                    console.log('\n👤 3. 检查角色专属空间数据:');
                    const characterSpaceCount = QQ_CharacterSpaces ? Object.keys(QQ_CharacterSpaces).length : 0;
                    console.log(`- 角色专属空间数量: ${characterSpaceCount}`);
                    Object.keys(QQ_CharacterSpaces || {}).forEach(charName => {
                        const spaceCount = Object.keys(QQ_CharacterSpaces[charName]).length;
                        console.log(`  - ${charName}: ${spaceCount} 个空间`);
                    });
                    
                    // 4. 测试加载时机函数可用性
                    console.log('\n🔧 4. 检查优化后的加载函数:');
                    const functions = [
                        // 精灵预加载相关
                        'QQ_PreloadCharacterDataFromWorldbook',
                        'QQ_LoadSpecificCharacterSpaces', 
                        'QQ_LoadCharacterInteractiveContent',
                        // 公共空间相关
                        'QQ_ShowPublicInteractiveSpaces',
                        'QQ_ShowPublicSpacesLoadingUI',
                        'QQ_ShowPublicSpacesContent',
                        'QQ_ShowPublicSpacesError',
                        'QQ_ForceReloadInteractiveSpaces'
                    ];
                    
                    functions.forEach(funcName => {
                        const exists = typeof window[funcName] === 'function';
                        console.log(`${exists ? '✅' : '❌'} ${funcName}: ${exists ? '可用' : '不存在'}`);
                    });
                    
                    // 5. 测试加载时机逻辑
                    console.log('\n⚡ 5. 测试加载时机逻辑:');
                    console.log('- 精灵面板打开时：立即预加载角色相关数据');
                    console.log('- 互动记录点击时：立即显示加载界面，然后从世界书重新加载');
                    console.log('- 点击小精灵互动空间按钮时：检查预加载状态，未预加载则立即加载');
                    
                    // 6. 提供手动测试建议  
                    console.log('\n🧪 6. 手动测试建议:');
                    console.log('请按以下步骤验证加载时机优化:');
                    console.log('a) 点击任意角色的精灵按钮（🧚‍♀️图标）→ 观察控制台预加载日志');
                    console.log('b) 点击使用者头像 → 点击"互动记录"按钮 → 观察加载动画和日志');
                    console.log('c) 点击精灵面板中的"互动空间"→ 观察是否使用预加载数据');
                    console.log('d) 观察控制台中的🚀🔄⚡等加载标识符');
                    
                    // 7. 性能统计
                    console.log('\n📈 7. 当前性能状态:');
                    console.log(`- 预加载覆盖率: ${preloadedCount} 个角色已预加载`);
                    console.log(`- 公共空间缓存: ${publicSpaceCount} 个空间已缓存`);
                    console.log(`- 角色空间缓存: ${characterSpaceCount} 个角色的空间已缓存`);
                    
                    const hasAnyCache = preloadedCount > 0 || publicSpaceCount > 0 || characterSpaceCount > 0;
                    const cacheStatus = hasAnyCache ? '良好' : '需要初始化';
                    console.log(`- 整体缓存状态: ${cacheStatus}`);
                    
                    if (!hasAnyCache) {
                        console.log('\n💡 建议: 尝试点击任一角色精灵或用户互动记录来初始化缓存');
                    }
                    
                    toastr.success('互动空间加载时机测试完成，请查看控制台详细信息', '测试完成');
                    
                } catch (error) {
                    console.error('❌ 测试优化后的加载时机时出错:', error);
                    toastr.error('测试过程中出现错误，请查看控制台', '测试失败');
                }
            }
            
            /**
             * *** 新增：清理重复的私聊群组 ***
             */
            window.QQ_CleanDuplicatePrivateChats = function() {
                console.log('🧹 开始清理重复的私聊群组...');
                
                try {
                    // 获取世界书中的群聊数据
                    const worldInfo = getWorldInfoSettings();
                    let hasChanges = false;
                    
                    if (worldInfo && worldInfo.entries) {
                        const duplicateGroups = [];
                        const seenChats = new Set();
                        
                        worldInfo.entries.forEach((entry, index) => {
                            if (entry.key && entry.key.includes('QQ_GroupChats_')) {
                                try {
                                    const data = JSON.parse(entry.content);
                                    
                                    // 检查是否有重复的私聊格式
                                    Object.keys(data).forEach(chatKey => {
                                        const normalizedKey = chatKey.replace('私聊', '聊天');
                                        
                                        if (chatKey !== normalizedKey && seenChats.has(normalizedKey)) {
                                            console.log(`🔍 发现重复私聊: "${chatKey}" 和 "${normalizedKey}"`);
                                            duplicateGroups.push({
                                                entryIndex: index,
                                                originalKey: chatKey,
                                                normalizedKey: normalizedKey,
                                                entry: entry
                                            });
                                        } else {
                                            seenChats.add(normalizedKey);
                                        }
                                    });
                                } catch (e) {
                                    console.warn('⚠️ 解析群聊数据失败:', entry.key, e);
                                }
                            }
                        });
                        
                        // 清理重复的条目
                        if (duplicateGroups.length > 0) {
                            console.log(`🗑️ 准备清理 ${duplicateGroups.length} 个重复群组`);
                            
                            duplicateGroups.forEach(duplicate => {
                                console.log(`删除重复群组: ${duplicate.originalKey}`);
                                // 这里可以选择删除或合并数据
                                // 为安全起见，我们先标记而不是直接删除
                                duplicate.entry.comment = `[待清理] 重复的私聊群组: ${duplicate.originalKey}`;
                                hasChanges = true;
                            });
                            
                            if (hasChanges) {
                                console.log('💾 保存清理后的世界书数据...');
                                saveWorldInfo(worldInfo);
                                console.log('✅ 重复群组清理完成！');
                                toastr.success(`已标记 ${duplicateGroups.length} 个重复群组待清理`, '数据清理');
                            }
                        } else {
                            console.log('✅ 未发现重复的私聊群组');
                            toastr.info('未发现重复的私聊群组', '数据清理');
                        }
                    }
                    
                } catch (error) {
                    console.error('❌ 清理重复群组时出错:', error);
                    toastr.error('清理过程中出现错误', '数据清理');
                }
            };
            

            
        </script>
    </body>
</html>